{
  "id": "confluence_display_KAFKA_Kafka+mirroring",
  "title": "Kafka mirroring - Apache Kafka - Apache Software Foundation",
  "content": "Note: The embedded consumer approach is deprecated by the MirrorMaker approach in 0.7.1. See\nhttps://cwiki.apache.org/confluence/display/KAFKA/Kafka+mirroring+(MirrorMaker)\nfor details.\nKafka mirroring\nKafka's mirroring feature makes it possible to maintain a replica of an existing Kafka cluster.\nThe Kafka mirror cluster uses an embedded Kafka consumer to consume messages from a source cluster, and re-publishes those messages to the local cluster using an embedded Kafka producer.\nHow to set up a mirror\nSetting up a mirror cluster is easy - simply provide the embedded consumer's configuration and the embedded producer's configuration, in addition to the server configuration configuration when you start up the Kafka brokers in the mirror cluster. You need to point the consumer to the source cluster's ZooKeeper, and the producer to the mirror cluster's ZooKeeper. By default, the mirror cluster will mirror all topics present on the source cluster. You can instead configure a whitelist or blacklist as described in the next section.\nThe following demo uses the sample configurations provided for the Kafka\nquick-start\n, and the following configuration files:\nmirror-server.properties\n,\nmirror-consumer.properties\n,\nmirror-producer.properties\n,\nmirror-zookeeper.properties\n.\nStart the primary cluster:\nbin/zookeeper-server-start.sh config/zookeeper.properties\nbin/kafka-server-start.sh config/server.properties\nStart the mirror cluster:\nbin/zookeeper-server-start.sh config/mirror-zookeeper.properties\nJMX_PORT=8888 bin/kafka-server-start.sh config/mirror-server.properties config/mirror-consumer.properties config/mirror-producer.properties\nIf you now send messages to topics on the source cluster, the mirror cluster will eventually mirror those topics.\nImportant configuration parameters for a mirror\nEmbedded producer timeout\nIn order to sustain a higher throughput, you would typically use an asynchronous embedded producer and it should be configured to be in blocking mode (i.e.,\nqueue.enqueueTimeout.ms=-1\n). This recommendation is to ensure that messages will not be lost. Otherwise, the default enqueue timeout of the asynchronous producer is zero which means if the producer's internal queue is full, then messages will be dropped due to\nQueueFullException\ns. A blocking producer however, will wait if the queue is full, and effectively throttle back the embedded consumer's consumption rate. You can enable trace logging in the producer to observe the remaining queue size over time. If the producer's queue is consistently full, it indicates that the mirror cluster is bottle-necked on re-publishing messages to the local (mirror) cluster and/or flushing messages to disk.\nEmbedded consumer whitelist or blacklist\nIf you do not wish to have full mirroring, you may use either the whitelist(\nmirror.topics.whitelist\n) configuration option to specify which topics to include, or the blacklist (\nmirror.topics.blacklist\n) configuration option to specify which topics to exclude. (It is invalid to specify both a whitelist and a blacklist.) These options accept a comma-separated list of topics.\nEmbedded consumer and source cluster socket buffer sizes\nMirroring is often used in cross-DC scenarios, and there are a few configuration options that you may want to tune to help deal with inter-DC communication latencies and performance bottlenecks on your specific hardware. In general, you should set a high value for the socket buffer size on the mirror cluster's consumer configuration (\nsocket.buffersize\n) and the source cluster's broker configuration (\nsocket.send.buffer\n). Also, the embedded consumer's fetch size (\nfetch.size\n) should be higher than the consumer's socket buffer size. Note that the socket buffer size configurations are a hint to the underlying platform's networking code. If you enable trace logging, you can check the actual receive buffer size and determine whether the setting in the OS networking layer also needs to be adjusted.\nHow to check whether a mirror is keeping up\nThe consumer offset checker tool is useful to gauge how well your mirror is keeping up with the source cluster. For example, the following was executed during the above demo:\nbin/kafka-run-class.sh kafka.tools.ConsumerOffsetChecker --group KafkaMirror --zkconnect localhost:2181 --topic test-topic\nKafkaMirror,topic1,0-0 (Group,Topic,BrokerId-PartitionId)\nOwner = KafkaMirror_jkoshy-ld-1320972386342-beb4bfc9-0\nConsumer offset = 561154288\n= 561,154,288 (0.52G)\nLog size = 2231392259\n= 2,231,392,259 (2.08G)\nConsumer lag = 1670237971\n= 1,670,237,971 (1.56G)\nBROKER INFO\n0 -> 127.0.0.1:9092\nNote that the --zkconnect argument should point to the source cluster's ZooKeeper. Also, if the topic is not specified, then the tool prints information for all topics under the given consumer group.\nCurrent limitations\nThere are few limitations with the current implementation of mirroring:\nThe embedded producer uses the default (random) partitioner. So if you use a\ncustom partitioner\nin your source cluster, the mirror cluster is not capable of using the same partitioning scheme.\nThe embedded consumer instantiates the same number of message streams for each topic according to the\nmirror.consumer.numthreads\nconfiguration option. There is no per-topic override at the moment.\nThe whitelist and blacklist configuration options do not accept regular expressions and only one of these options can be used in a given mirror setup.",
  "url": "https://cwiki.apache.org/confluence/display/KAFKA/Kafka+mirroring",
  "space": "KAFKA",
  "labels": [],
  "last_modified": null,
  "source_type": "confluence"
}