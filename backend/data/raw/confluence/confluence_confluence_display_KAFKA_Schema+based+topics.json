{
  "id": "confluence_display_KAFKA_Schema+based+topics",
  "title": "Schema based topics - Apache Kafka - Apache Software Foundation",
  "content": "The idea here is for topics to have associated a plug-able set of schema's that the Kafka broker will validate against when produced. The broker will also execute the plugged in logic based on that topic's associated field for plug-ins. This should be >= 1 so we can implement a pass through of iterations on the data prior to save (e.g. Security Authorizations).\nTo best facilitate this we could store <TBD> a list of schemaIdHash + schema.  Every topic would have a class file associated with it to run the management of the schemes for the topic. The plugin could hold the schemas compiled or in another repository.  The storage of the schemas should be key/value based [schemaIdHash] = schema. We may want to order and priortize these so that certain plug-in can iterator on the message before others (e.g. you should do authorizations first).\n1) We are going to need a cli tool for the crud\nhttps://issues.apache.org/jira/browse/KAFKA-1694\nand other things that exist today.\n2) Besides validation of the schema on the producer side and keeping client compatibility with that we also need a way for consumers once subscribed to a topic (from a group perspective) to read in the key/value schema information.  This could just be part of the OffsetResponse\nA Guide To The Kafka Protocol#OffsetResponse\n3) We should lump the client compatibility kit (some thoughts on that\nhttps://github.com/stealthly/kafka-clients/wiki/Compatibility\n) work into this effort too.\n5) This design also can work to implement Authorizations for the data in regards ACL (at least the security bits on the data to validate).\n6) I think built in initial support for Avro would be awesome and probably account for the largest percentage of existing Kafka installations.  We could use Camus encoders/decoders for avro\nhttps://github.com/linkedin/camus/blob/master/camus-kafka-coders/src/main/java/com/linkedin/camus/etl/kafka/coders/KafkaAvroMessageEncoder.java\n/\nhttps://github.com/linkedin/camus/blob/master/camus-kafka-coders/src/main/java/com/linkedin/camus/etl/kafka/coders/KafkaAvroMessageDecoder.java\nand json\nhttps://github.com/linkedin/camus/blob/master/camus-kafka-coders/src/main/java/com/linkedin/camus/etl/kafka/coders/JsonStringMessageDecoder.java\nbut with a layer of faster xml databind over it e.g.\nimport com.fasterxml.jackson.databind.{DeserializationFeature, ObjectMapper}\nimport com.fasterxml.jackson.module.scala.experimental.ScalaObjectMapper\nimport com.fasterxml.jackson.module.scala.DefaultScalaModule\nobject JsonUtil {\nval mapper = new ObjectMapper() with ScalaObjectMapper\nmapper.registerModule(DefaultScalaModule)\nmapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)\ndef toJson(value: Map[Symbol, Any]): String = {\ntoJson(value map { case (k,v) => k.name -> v})\n}\ndef toJson(value: Any): String = {\nmapper.writeValueAsString(value)\n}\ndef toMap[V](json:String)(implicit m: Manifest[V]) = fromJson[Map[String,V]](json)\ndef toObj[V](json:String)(implicit m: Manifest[V]) = fromJson[V](json)\ndef toSeq[V](json:String)(implicit m: Manifest[V]) = fromJson[Seq[V]](json)\ndef fromJson[T](json: String)(implicit m : Manifest[T]): T = {\nmapper.readValue[T](json)\n}\n}\nobject MarshallableImplicits {\nimplicit class Unmarshallable(unMarshallMe: String) {\ndef toMapFrom: Map[String,Any] = JsonUtil.toMap(unMarshallMe)\ndef toMapOf[V]()(implicit m: Manifest[V]): Map[String,V] = JsonUtil.toMap[V](unMarshallMe)\ndef toObj[V]()(implicit m: Manifest[V]): V = JsonUtil.toObj[V](unMarshallMe)\ndef toSeq[V]()(implicit m: Manifest[V]): Seq[V] = JsonUtil.toSeq[V](unMarshallMe)\ndef fromJson[T]()(implicit m: Manifest[T]): T =  JsonUtil.fromJson[T](unMarshallMe)\n}\nimplicit class Marshallable[T](marshallMe: T) {\ndef toJson: String = JsonUtil.toJson(marshallMe)\n}\n}\nThen we can make our objects from json easily.  Starting with this first is another approach it would definitly get things work better faster and we can refactor in avro to make sure it does support plugins.",
  "url": "https://cwiki.apache.org/confluence/display/KAFKA/Schema+based+topics",
  "space": "KAFKA",
  "labels": [],
  "last_modified": null,
  "source_type": "confluence"
}