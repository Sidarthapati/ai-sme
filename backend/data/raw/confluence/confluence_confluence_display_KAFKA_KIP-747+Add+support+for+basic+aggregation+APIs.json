{
  "id": "confluence_display_KAFKA_KIP-747+Add+support+for+basic+aggregation+APIs",
  "title": "KIP-747 Add support for basic aggregation APIs - Apache Kafka - Apache Software Foundation",
  "content": "Status\nCurrent state\n:\n\"Under Discussion\"\nDiscussion thread\n:\nhere\nJIRA\n: TBD\nPlease keep the discussion on the mailing list rather than commenting on the wiki (wiki discussions get unwieldy fast).\nMotivation\nAnalytics applications use aggregations over data as a fundamental building block. Streaming frameworks like Spark provide functions like min, max, sum and many more as part of the Spark SQL aggregations. Kafka streams library supports count as part of KGroupedStream, KGroupedTable, TimeWindowedKStream and SessionWindowedStream. For other aggregations, application developers need to develop their own custom aggregators.  Most applications have standard templates for many such functions. In some cases, the implementation may not be optimal and it spreads across many applications which may become hard to debug.\nThis document proposes some of the basic aggregation functions that will be useful for many applications. As we gain experience with this, we can expand the APIs to include other functions.\nPublic Interfaces\nAggregation APIs\npublic interface KGroupedStream<K, V> {\n<VR extends Number> KTable<K, VR> min(Function<V, VR> func,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> min(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> max(Function<V, VR> func,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> max(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> sum(Function<V, VR> func,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> sum(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n}\npublic interface TimeWindowedKStream<K, V> {\n<VR extends Number> KTable<Windowed<K>, VR> min(Function<V, VR> func,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> min(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> max(Function<V, VR> func,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> max(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> sum(Function<V, VR> func,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> sum(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, WindowStore<Bytes, byte[]>> materialized);\n}\npublic interface SessionWindowedKStream<K, V> {\n<VR extends Number> KTable<Windowed<K>, VR> min(Function<V, VR> func,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> min(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> max(Function<V, VR> func,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> max(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> sum(Function<V, VR> func,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<Windowed<K>, VR> sum(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, SessionStore<Bytes, byte[]>> materialized);\n}\npublic interface KGroupedTable<K, V> {\n<VR extends Number> KTable<K, VR> sum(Function<V, VR> func,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n<VR extends Number> KTable<K, VR> sum(Function<V, VR> func, final Named named,\nfinal Materialized<K, Long, KeyValueStore<Bytes, byte[]>> materialized);\n}\nThe scala interfaces will also be changed accordingly.\nProposed Changes\nThe functionality of the changes are self-explanatory. The new APIs return the min, max and sum of of the values in the current KStream or KTable. The API provides a functional interface (func) to extract the value for which the min/max/sum should be calculated. The return value (VR) is upper bounded to be a Number as the operations make sense only for subclasses of the Number.\nThe following variants of the API that are supported by\ncount\nis not supported by min/max/sum.\nKTable<K, Long> count();\nKTable<K, Long> count(\nfinal\nNamed named);\nCount API assumes that the \"valueSerde\" is Long. In the case of min/max/sum we should be able to support the other Number types also. As the type of return value of the \"func\" is not known at the time of building the topology, the user has to explicitly provide this using the Materialized parameter. The valueSerde cannot be null. One alternate way of supporting the above forms is to assume some generic serde and at run time inspect the return value of the func and install the right Serde. This adds to the complexity and hence not supported.\nAlso KTable version of the API supports only \"sum\" and it does not support min/max. KTable aggregations has the notion of \"adder\" and \"subtractor\" where state can be subtracted when there is deletion or change to the previous value that is already aggregated. For min and max, this implies that we store all the old values which could be very expensive. Hence, they are not supported  by KGroupedTable.\nThe aggregations have an initializer which initializes the aggregate to some starting value. This requires the aggregation type which is not explicitly passed in. One possible way to infer this using \"valueSerde\" which is not very desirable as the the application could be using its own implementation of Serdes. There are two possibilities\nProvide an explicit parameter\nAssume a default type e.g., Long\nThis is an open issue and the APIs will be modified after the mailing list discussion.\nImplementation details are described below.\nKGroupedStream ,  SessionWindowedKStream, TimeWindowedKStream, SlidingWindowedKStream\nWe can model the implementation similar to how \"count\" is implemented. GroupedStreamAggregateBuilder holds the definition for countInitializer and countAggregator. Similarly we can have initializer and aggregator definitions for min/max and sum.\nKGroupedTable\nWe can model the implementation similar to how \"count\" is implemented. KGroupedTableImpl class holds the definition for countInitializer, countAdder and countSubtractor. Similarly we can have the definition for sum.\nCompatibility, Deprecation, and Migration Plan\nN/A\nRejected Alternatives\nSee the discussion above",
  "url": "https://cwiki.apache.org/confluence/display/KAFKA/KIP-747+Add+support+for+basic+aggregation+APIs",
  "space": "KAFKA",
  "labels": [],
  "last_modified": null,
  "source_type": "confluence"
}