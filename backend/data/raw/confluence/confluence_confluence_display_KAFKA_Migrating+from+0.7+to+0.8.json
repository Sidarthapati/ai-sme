{
  "id": "confluence_display_KAFKA_Migrating+from+0.7+to+0.8",
  "title": "Migrating from 0.7 to 0.8 - Apache Kafka - Apache Software Foundation",
  "content": "Kafka provides the ability to seamlessly migrate from 0.7 to 0.8 using a migration tool. The tool uses a 0.7 Kafka consumer to consume messages from the 0.7 source cluster and re-publishes those messages to the 0.8 target cluster using an embedded Kafka producer.\nSteps to move from 0.7 to 0.8\n1. Setup a separate 0.8 cluster (Do not modify anything in the existing 0.7 cluster). More info on setup can be found here -\nhttps://cwiki.apache.org/confluence/display/KAFKA/Kafka+0.8+Quick+Start\n2. Setup the migration tool to consume messages from the 0.7 cluster and re-publish them to the 0.8 cluster (Details below)\n3. Move the 0.7 consumers consuming from the 0.7 cluster to 0.8\n4. Move the 0.7 producers to 0.8\nThe rest of the document describes how the migration tool can be setup followed by some FAQ.\nHow to set up the Migration tool\nThe migration tool takes one or more consumer configurations, a producer configuration, kafka 0.7 jar and zkclient.01 jar (Needed by kafka 0.7 consumer) and either a whitelist or a blacklist. You need to point the consumer to the source cluster's ZooKeeper, and the producer to the 0.8 broker.list.\nkafka-run-class.sh kafka.tools.KafkaMigrationTool --kafka.07.jar kafka-0.7.19.jar --zkclient.01.jar zkclient-0.2.0.jar --num.producers 16 --consumer.config=sourceCluster2Consumer.config --producer.config=targetClusterProducer.config --whitelist=.*\nImport configuration parameters for the migration tool\nWhitelist or blacklist\nThe migration tool accepts exactly one of whitelist or blacklist. These are standard Java regex patterns.\nBlocking producer\nIn order to sustain a higher throughput, you would typically use an asynchronous embedded producer and it should be configured to be in blocking mode (i.e.,\nqueue.enqueueTimeout.ms=-1\n). This recommendation is to ensure that messages will not be lost. Otherwise, the default enqueue timeout of the asynchronous producer is zero which means if the producer's internal queue is full, then messages will be dropped due to\nQueueFullExceptions\n. A blocking producer however, will wait if the queue is full, and effectively throttle back the embedded consumer's consumption rate. You can enable trace logging in the producer to observe the remaining queue size over time. If the producer's queue is consistently full, it indicates that the migration tool is bottle-necked on re-publishing messages to the target cluster and/or flushing messages to disk.\nNumber of producers\nYou can use the\n--num.producers\noption to use a producer pool in the migration tool to increase throughput. This helps because each producer's requests are effectively handled by a single thread on the receiving Kafka broker. i.e., even if you have multiple consumption streams (see next section), the throughput can be bottle-necked at the handling stage of the migration tool's producer requests.\nNumber of consumption streams\nUse the --num.streams option to specify the number of consumer threads to create. Note that if you start multiple migration tool processes, you may want to look at the distribution of partitions on the source cluster. If the number of consumption streams is too high per migration tool process, then some of the consumer threads will be idle by virtue of the consumer rebalancing algorithm (if they do not end up owning any partitions for consumption).\nFAQ\nIs shallow iteration supported for the Migration tool's consumer config?\nNo. The message format has changed from 0.7 to 0.8. The migration tool needs to convert the messages to the new format for which it needs to do the deep iteration.\nWhen the 0.8 consumer is made to consume from the 0.8 cluster, what happens to the offsets?\nIn 0.8, we have moved to logical offsets from physical offsets. This means that the offsets are not compatible. When you try to consume using the 0.7 offsets, you would hit \"OffsetOutOfRangeException\". The default behavior of the consumer when this happens is based on the config value of \"auto.offset.reset\". If it is set to \"smallest\", the consumer will start consuming from the beginning. If it is set to \"largest\", the consumer will start consuming from the end.",
  "url": "https://cwiki.apache.org/confluence/display/KAFKA/Migrating+from+0.7+to+0.8",
  "space": "KAFKA",
  "labels": [],
  "last_modified": null,
  "source_type": "confluence"
}