{
  "id": "confluence_display_KAFKA_1-Pager%3A+Testing+Strategy+for+New+Kafka+Consumer",
  "title": "1-Pager: Testing Strategy for New Kafka Consumer - Apache Kafka - Apache Software Foundation",
  "content": "This is a follow up task for the:\nConsumer threading refactor design\nObjective\nTo ensure that our new Kafka consumer is robust, performant, and scalable by rigorously testing its capabilities in various scenarios, including different message sizes, numbers, consumer counts, and CPU throttling conditions.\nScope\nConsumption Rate\nVarying message sizes: 100B, 1KB, 10KB, 100KB\nVarying message numbers: 100, 1000, 10,000, 100,000\nCPU Throttling\nNo throttling\n99.99%\nSpecial Scenarios\nSchema registry usage\nSlow schema resolution\nPerformance Testing Strategy\nSetup\nKafka Cluster: n-broker setup (do we need more than 1?)\nProducer: Pre-configured to produce varying sizes and volumes of messages\nConsumer: Async Consumer and the current KafkaConsumer implementation\nConsumption Rate\nVarying Message Sizes\n: Measure the rate of message consumption across different message sizes.\nMetrics: Throughput (messages/sec), Latency\nTools: Kafka built-in monitoring, custom logging\nVarying Message Numbers\n: Measure how well the consumer handles varying amounts of messages.\nMetrics: Throughput, Backlog drain time\nTools: Kafka monitoring, custom logging\nCPU Throttling\nNo Throttling\n: Baseline performance metrics.\nMetrics: Throughput, CPU, and Memory Usage\n50% and 75% Throttling\n: Simulate CPU constraint scenarios.\nMetrics: Throughput, Latency, CPU and Memory Usage\nSpecial Scenarios\nHigh Deserialization CPU Cost\n: Simulate a high-CPU cost deserialization algorithm.\nMetrics: Throughput, Latency, CPU Utilization\nTools: Kafka monitoring, Profiling tools\nSchema Registry\n: Measure the impact of using a schema registry for deserialization.\nMetrics: Throughput, Latency, Schema registry lookup time\nTools: Kafka monitoring, Schema Registry logs\nStochastic Testing Strategy\nGoal\nWe need to deterministically emulate all possible real-world usage of the async consumer.  Despite integration testing and unit testing cover some aspect of it, I think it is necessary for us to try to generate a large number of usage patterns and verify the consequence of these actions.  For example - offsetComit follows by consumer.subscribe should yield nothing because the consumer has not made any progress.  Consumer poll should trigger auto commit and we need to verify that the previously return data was committed to the coordinator.\nThe goal is to simulate a series of events in pseudo-randomly and verify the outcome of each action.  If an unexpected result is detected, we should be able to retrieve the sequence of actions so that we can debug the issue.\nComponents\nA random action/sequence generator: We should generate the next action based on the current state of the consumer by probability.\nState tracker: We record the state of the consumer and predict the consequence of the following action.\nA sequence logger: The actions are logged into a sequence of events, chronologically so that we can always reproduce the actions.\nResponse simulator: Based on the request sent from the client, we pseudo-randomlly generate responses for a given request.  Each response can be branched into a separate consumer state for testing.",
  "url": "https://cwiki.apache.org/confluence/display/KAFKA/1-Pager%3A+Testing+Strategy+for+New+Kafka+Consumer",
  "space": "KAFKA",
  "labels": [],
  "last_modified": null,
  "source_type": "confluence"
}