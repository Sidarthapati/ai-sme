{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_MockProducer.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "content": "    public void completeTransaction(PreparedTxnState preparedTxnState) throws ProducerFencedException {\n        verifyNotClosed();\n        verifyNotFenced();\n        verifyTransactionsInitialized();\n        \n        if (!this.transactionInFlight) {\n            throw new IllegalStateException(\"There is no prepared transaction to complete.\");\n        }\n\n        // For testing purposes, we'll consider a prepared state with producerId=1000L and epoch=1 as valid\n        // This should match what's returned in prepareTransaction()\n        PreparedTxnState currentState = new PreparedTxnState(1000L, (short) 1);\n        \n        if (currentState.equals(preparedTxnState)) {\n            commitTransaction();\n        } else {\n            abortTransaction();\n        }\n    }\n\n    private synchronized void verifyNotClosed() {\n        if (this.closed) {\n            throw new IllegalStateException(\"MockProducer is already closed.\");\n        }\n    }\n\n    private synchronized void verifyNotFenced() {\n        if (this.producerFenced) {\n            throw new ProducerFencedException(\"MockProducer is fenced.\");\n        }\n    }\n\n    private void verifyTransactionsInitialized() {\n        if (!this.transactionInitialized) {\n            throw new IllegalStateException(\"MockProducer hasn't been initialized for transactions.\");\n        }\n    }\n\n    private void verifyTransactionInFlight() {\n        if (!this.transactionInFlight) {\n            throw new IllegalStateException(\"There is no open transaction.\");\n        }\n    }\n\n    /**\n     * Adds the record to the list of sent records. The {@link RecordMetadata} returned will be immediately satisfied.\n     *\n     * @see #history()\n     */\n    @Override\n    public synchronized Future<RecordMetadata> send(ProducerRecord<K, V> record) {\n        return send(record, null);\n    }\n\n    /**\n     * Adds the record to the list of sent records.\n     *\n     * @see #history()\n     */\n    @Override\n    public synchronized Future<RecordMetadata> send(ProducerRecord<K, V> record, Callback callback) {\n        if (this.closed) {\n            throw new IllegalStateException(\"MockProducer is already closed.\");\n        }\n\n        if (this.producerFenced) {\n            throw new KafkaException(\"MockProducer is fenced.\", new ProducerFencedException(\"Fenced\"));\n        }\n        if (this.sendException != null) {\n            throw this.sendException;\n        }\n\n        int partition = 0;\n        if (!this.cluster.partitionsForTopic(record.topic()).isEmpty())\n            partition = partition(record, this.cluster);\n        else {\n            //just to throw ClassCastException if serializers are not the proper ones to serialize key/value\n            keySerializer.serialize(record.topic(), new RecordHeaders(), record.key());\n            valueSerializer.serialize(record.topic(), new RecordHeaders(), record.value());\n        }\n\n        TopicPartition topicPartition = new TopicPartition(record.topic(), partition);\n        ProduceRequestResult result = new ProduceRequestResult(topicPartition);\n        FutureRecordMetadata future = new FutureRecordMetadata(result, 0, RecordBatch.NO_TIMESTAMP,\n                0, 0, Time.SYSTEM);\n        long offset = nextOffset(topicPartition);\n        long baseOffset = Math.max(0, offset - Integer.MAX_VALUE);\n        int batchIndex = (int) Math.min(Integer.MAX_VALUE, offset);\n        Completion completion = new Completion(offset, new RecordMetadata(topicPartition, baseOffset, batchIndex,\n                RecordBatch.NO_TIMESTAMP, 0, 0), result, callback, topicPartition);\n\n        if (!this.transactionInFlight)\n            this.sent.add(record);\n        else\n            this.uncommittedSends.add(record);\n\n        if (autoComplete)\n            completion.complete(null);\n        else\n            this.completions.addLast(completion);\n\n        return future;\n    }\n\n    /**\n     * Get the next offset for this topic/partition\n     */\n    private long nextOffset(TopicPartition tp) {\n        Long offset = this.offsets.get(tp);\n        if (offset == null) {\n            this.offsets.put(tp, 1L);\n            return 0L;\n        } else {\n            Long next = offset + 1;\n            this.offsets.put(tp, next);\n            return offset;\n        }\n    }\n\n    public synchronized void flush() {\n        verifyNotClosed();\n\n        if (this.flushException != null) {\n            throw this.flushException;\n        }\n\n        while (!this.completions.isEmpty())\n            completeNext();\n    }\n\n    public List<PartitionInfo> partitionsFor(String topic) {\n        if (this.partitionsForException != null) {\n            throw this.partitionsForException;\n        }\n\n        return this.cluster.partitionsForTopic(topic);\n    }\n\n    public void disableTelemetry() {\n        telemetryDisabled = true;\n    }\n\n    /**\n     * @param injectTimeoutExceptionCounter use -1 for infinite\n     */\n    public void injectTimeoutException(final int injectTimeoutExceptionCounter) {\n        this.injectTimeoutExceptionCounter = injectTimeoutExceptionCounter;\n    }\n\n    public void setClientInstanceId(final Uuid instanceId) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.608364",
  "source_type": "github"
}