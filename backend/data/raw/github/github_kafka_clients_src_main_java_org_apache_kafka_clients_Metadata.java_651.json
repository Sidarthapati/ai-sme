{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_Metadata.java_651",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "content": "    }\n\n    private KafkaException recoverableExceptionForTopic(String topic) {\n        if (unauthorizedTopics.contains(topic))\n            return new TopicAuthorizationException(Collections.singleton(topic));\n        else if (invalidTopics.contains(topic))\n            return new InvalidTopicException(Collections.singleton(topic));\n        else\n            return null;\n    }\n\n    private void clearRecoverableErrors() {\n        invalidTopics = Collections.emptySet();\n        unauthorizedTopics = Collections.emptySet();\n    }\n\n    /**\n     * Record an attempt to update the metadata that failed. We need to keep track of this\n     * to avoid retrying immediately.\n     */\n    public synchronized void failedUpdate(long now) {\n        this.lastRefreshMs = now;\n        this.attempts++;\n        this.equivalentResponseCount = 0;\n    }\n\n    /**\n     * Propagate a fatal error which affects the ability to fetch metadata for the cluster.\n     * Two examples are authentication and unsupported version exceptions.\n     *\n     * @param exception The fatal exception\n     */\n    public synchronized void fatalError(KafkaException exception) {\n        this.fatalException = exception;\n    }\n\n    /**\n     * @return The current metadata updateVersion\n     */\n    public synchronized int updateVersion() {\n        return this.updateVersion;\n    }\n\n    /**\n     * The last time metadata was successfully updated.\n     */\n    public synchronized long lastSuccessfulUpdate() {\n        return this.lastSuccessfulRefreshMs;\n    }\n\n    /**\n     * Close this metadata instance to indicate that metadata updates are no longer possible.\n     */\n    @Override\n    public synchronized void close() {\n        this.isClosed = true;\n    }\n\n    /**\n     * Check if this metadata instance has been closed. See {@link #close()} for more information.\n     *\n     * @return True if this instance has been closed; false otherwise\n     */\n    public synchronized boolean isClosed() {\n        return this.isClosed;\n    }\n\n    public synchronized MetadataRequestAndVersion newMetadataRequestAndVersion(long nowMs) {\n        MetadataRequest.Builder request = null;\n        boolean isPartialUpdate = false;\n\n        // Perform a partial update only if a full update hasn't been requested, and the last successful\n        // hasn't exceeded the metadata refresh time.\n        if (!this.needFullUpdate && this.lastSuccessfulRefreshMs + this.metadataExpireMs > nowMs) {\n            request = newMetadataRequestBuilderForNewTopics();\n            isPartialUpdate = true;\n        }\n        if (request == null) {\n            request = newMetadataRequestBuilder();\n            isPartialUpdate = false;\n        }\n        return new MetadataRequestAndVersion(request, requestVersion, isPartialUpdate);\n    }\n\n    /**\n     * Constructs and returns a metadata request builder for fetching cluster data and all active topics.\n     *\n     * @return the constructed non-null metadata builder\n     */\n    protected MetadataRequest.Builder newMetadataRequestBuilder() {\n        return MetadataRequest.Builder.allTopics();\n    }\n\n    /**\n     * Constructs and returns a metadata request builder for fetching cluster data and any uncached topics,\n     * otherwise null if the functionality is not supported.\n     *\n     * @return the constructed metadata builder, or null if not supported\n     */\n    protected MetadataRequest.Builder newMetadataRequestBuilderForNewTopics() {\n        return null;\n    }\n\n    /**\n     * @return Mapping from topic IDs to topic names for all topics in the cache.\n     */\n    public Map<Uuid, String> topicNames() {\n        return metadataSnapshot.topicNames();\n    }\n\n    /**\n     * Based on the topic name, check if the topic metadata should be kept when received in a metadata response.\n     */\n    protected boolean retainTopic(String topic, boolean isInternal, long nowMs) {\n        return true;\n    }\n\n    /**\n     * Based on the topic name and topic ID, check if the topic metadata should be kept when received in a metadata response.\n     */\n    protected boolean retainTopic(String topicName, Uuid topicId, boolean isInternal, long nowMs) {\n        return retainTopic(topicName, isInternal, nowMs);\n    }\n\n    public static class MetadataRequestAndVersion {\n        public final MetadataRequest.Builder requestBuilder;\n        public final int requestVersion;\n        public final boolean isPartialUpdate;\n\n        private MetadataRequestAndVersion(MetadataRequest.Builder requestBuilder,\n                                          int requestVersion,\n                                          boolean isPartialUpdate) {\n            this.requestBuilder = requestBuilder;\n            this.requestVersion = requestVersion;\n            this.isPartialUpdate = isPartialUpdate;\n        }\n    }\n\n    /**\n     * Represents current leader state known in metadata. It is possible that we know the leader, but not the\n     * epoch if the metadata is received from a broker which does not support a sufficient Metadata API version.\n     * It is also possible that we know of the leader epoch, but not the leader when it is derived\n     * from an external source (e.g. a committed offset).\n     */\n    public static class LeaderAndEpoch {\n        private static final LeaderAndEpoch NO_LEADER_OR_EPOCH = new LeaderAndEpoch(Optional.empty(), Optional.empty());\n\n        public final Optional<Node> leader;\n        public final Optional<Integer> epoch;\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/Metadata.java#L651-L800",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 651,
  "end_line": 800,
  "last_modified": "2026-02-06T01:16:27.578514",
  "source_type": "github"
}