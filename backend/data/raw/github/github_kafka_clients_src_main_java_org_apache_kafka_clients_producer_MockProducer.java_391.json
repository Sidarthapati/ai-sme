{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_MockProducer.java_391",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "content": "    public List<PartitionInfo> partitionsFor(String topic) {\n        if (this.partitionsForException != null) {\n            throw this.partitionsForException;\n        }\n\n        return this.cluster.partitionsForTopic(topic);\n    }\n\n    public void disableTelemetry() {\n        telemetryDisabled = true;\n    }\n\n    /**\n     * @param injectTimeoutExceptionCounter use -1 for infinite\n     */\n    public void injectTimeoutException(final int injectTimeoutExceptionCounter) {\n        this.injectTimeoutExceptionCounter = injectTimeoutExceptionCounter;\n    }\n\n    public void setClientInstanceId(final Uuid instanceId) {\n        clientInstanceId = instanceId;\n    }\n\n    @Override\n    public Uuid clientInstanceId(Duration timeout) {\n        if (telemetryDisabled) {\n            throw new IllegalStateException();\n        }\n        if (clientInstanceId == null) {\n            throw new UnsupportedOperationException(\"clientInstanceId not set\");\n        }\n        if (injectTimeoutExceptionCounter != 0) {\n            // -1 is used as \"infinite\"\n            if (injectTimeoutExceptionCounter > 0) {\n                --injectTimeoutExceptionCounter;\n            }\n            throw new TimeoutException(\"TimeoutExceptions are successfully injected for test.\");\n        }\n\n        return clientInstanceId;\n    }\n\n    public Map<MetricName, Metric> metrics() {\n        return mockMetrics;\n    }\n\n    /**\n     * Set a mock metric for testing purpose\n     */\n    public void setMockMetrics(MetricName name, Metric metric) {\n        mockMetrics.put(name, metric);\n    }\n\n    @Override\n    public void close() {\n        close(Duration.ofMillis(0));\n    }\n\n    @Override\n    public void close(Duration timeout) {\n        if (this.closeException != null) {\n            throw this.closeException;\n        }\n\n        this.closed = true;\n    }\n\n    public boolean closed() {\n        return this.closed;\n    }\n\n    public synchronized void fenceProducer() {\n        verifyNotClosed();\n        verifyNotFenced();\n        verifyTransactionsInitialized();\n        this.producerFenced = true;\n    }\n\n    public boolean transactionInitialized() {\n        return this.transactionInitialized;\n    }\n\n    public boolean transactionInFlight() {\n        return this.transactionInFlight;\n    }\n\n    public boolean transactionCommitted() {\n        return this.transactionCommitted;\n    }\n\n    public boolean transactionAborted() {\n        return this.transactionAborted;\n    }\n\n    public boolean flushed() {\n        return this.completions.isEmpty();\n    }\n\n    public boolean sentOffsets() {\n        return this.sentOffsets;\n    }\n\n    public long commitCount() {\n        return this.commitCount;\n    }\n\n    /**\n     * Get the list of sent records since the last call to {@link #clear()}\n     */\n    public synchronized List<ProducerRecord<K, V>> history() {\n        return new ArrayList<>(this.sent);\n    }\n\n    public synchronized List<ProducerRecord<K, V>> uncommittedRecords() {\n        return new ArrayList<>(this.uncommittedSends);\n    }\n\n    /**\n     *\n     * Get the list of committed consumer group offsets since the last call to {@link #clear()}\n     */\n    public synchronized List<Map<String, Map<TopicPartition, OffsetAndMetadata>>> consumerGroupOffsetsHistory() {\n        return new ArrayList<>(this.consumerGroupOffsets);\n    }\n\n    public synchronized Map<String, Map<TopicPartition, OffsetAndMetadata>> uncommittedOffsets() {\n        return this.uncommittedConsumerGroupOffsets;\n    }\n\n    /**\n     * Clear the stored history of sent records, consumer group offsets\n     */\n    public synchronized void clear() {\n        this.sent.clear();\n        this.uncommittedSends.clear();\n        this.sentOffsets = false;\n        this.completions.clear();\n        this.consumerGroupOffsets.clear();\n        this.uncommittedConsumerGroupOffsets.clear();\n    }\n\n    /**\n     * Complete the earliest uncompleted call successfully.\n     *\n     * @return true if there was an uncompleted call to complete\n     */\n    public synchronized boolean completeNext() {\n        return errorNext(null);\n    }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java#L391-L540",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 391,
  "end_line": 540,
  "last_modified": "2026-02-06T01:16:27.608364",
  "source_type": "github"
}