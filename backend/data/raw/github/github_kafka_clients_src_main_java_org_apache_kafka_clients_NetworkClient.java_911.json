{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_911",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "     * The connection to the node associated with the request will be terminated and will be treated as a disconnection.\n     *\n     * @param responses The list of responses to update\n     * @param now The current time\n     */\n    private void handleTimedOutRequests(List<ClientResponse> responses, long now) {\n        List<String> nodeIds = this.inFlightRequests.nodesWithTimedOutRequests(now);\n        for (String nodeId : nodeIds) {\n            // close connection to the node\n            this.selector.close(nodeId);\n            log.info(\"Disconnecting from node {} due to request timeout.\", nodeId);\n            processTimeoutDisconnection(responses, nodeId, now);\n        }\n    }\n\n    private void handleAbortedSends(List<ClientResponse> responses) {\n        responses.addAll(abortedSends);\n        abortedSends.clear();\n    }\n\n    /**\n     * Handle socket channel connection timeout. The timeout will hit iff a connection\n     * stays at the ConnectionState.CONNECTING state longer than the timeout value,\n     * as indicated by ClusterConnectionStates.NodeConnectionState.\n     *\n     * @param responses The list of responses to update\n     * @param now The current time\n     */\n    private void handleTimedOutConnections(List<ClientResponse> responses, long now) {\n        List<String> nodes = connectionStates.nodesWithConnectionSetupTimeout(now);\n        for (String nodeId : nodes) {\n            this.selector.close(nodeId);\n            log.info(\n                \"Disconnecting from node {} due to socket connection setup timeout. \" +\n                \"The timeout value is {} ms.\",\n                nodeId,\n                connectionStates.connectionSetupTimeoutMs(nodeId));\n            processTimeoutDisconnection(responses, nodeId, now);\n        }\n    }\n\n    /**\n     * Handle any completed request send. In particular if no response is expected consider the request complete.\n     *\n     * @param responses The list of responses to update\n     * @param now The current time\n     */\n    private void handleCompletedSends(List<ClientResponse> responses, long now) {\n        // if no response is expected then when the send is completed, return it\n        for (NetworkSend send : this.selector.completedSends()) {\n            InFlightRequest request = this.inFlightRequests.lastSent(send.destinationId());\n            if (!request.expectResponse) {\n                this.inFlightRequests.completeLastSent(send.destinationId());\n                responses.add(request.completed(null, now));\n            }\n        }\n    }\n\n    /**\n     * If a response from a node includes a non-zero throttle delay and client-side throttling has been enabled for\n     * the connection to the node, throttle the connection for the specified delay.\n     *\n     * @param response the response\n     * @param apiVersion the API version of the response\n     * @param nodeId the id of the node\n     * @param now The current time\n     */\n    private void maybeThrottle(AbstractResponse response, short apiVersion, String nodeId, long now) {\n        int throttleTimeMs = response.throttleTimeMs();\n        if (throttleTimeMs > 0 && response.shouldClientThrottle(apiVersion)) {\n            inFlightRequests.incrementThrottleTime(nodeId, throttleTimeMs);\n            connectionStates.throttle(nodeId, now + throttleTimeMs);\n            log.trace(\"Connection to node {} is throttled for {} ms until timestamp {}\", nodeId, throttleTimeMs,\n                      now + throttleTimeMs);\n        }\n    }\n\n    /**\n     * Handle any completed receives and update the response list with the responses received.\n     *\n     * @param responses The list of responses to update\n     * @param now The current time\n     */\n    private void handleCompletedReceives(List<ClientResponse> responses, long now) {\n        for (NetworkReceive receive : this.selector.completedReceives()) {\n            String source = receive.source();\n            InFlightRequest req = inFlightRequests.completeNext(source);\n\n            AbstractResponse response = parseResponse(receive.payload(), req.header);\n            if (throttleTimeSensor != null)\n                throttleTimeSensor.record(response.throttleTimeMs(), now);\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Received {} response from node {} for request with header {}: {}\",\n                    req.header.apiKey(), req.destination, req.header, response);\n            }\n\n            // If the received response includes a throttle delay, throttle the connection.\n            maybeThrottle(response, req.header.apiVersion(), req.destination, now);\n            if (req.isInternalRequest && response instanceof MetadataResponse)\n                metadataUpdater.handleSuccessfulResponse(req.header, now, (MetadataResponse) response);\n            else if (req.isInternalRequest && response instanceof ApiVersionsResponse)\n                handleApiVersionsResponse(responses, req, now, (ApiVersionsResponse) response);\n            else if (req.isInternalRequest && response instanceof GetTelemetrySubscriptionsResponse)\n                telemetrySender.handleResponse((GetTelemetrySubscriptionsResponse) response);\n            else if (req.isInternalRequest && response instanceof PushTelemetryResponse)\n                telemetrySender.handleResponse((PushTelemetryResponse) response);\n            else\n                responses.add(req.completed(response, now));\n        }\n    }\n\n    private void handleApiVersionsResponse(List<ClientResponse> responses,\n                                           InFlightRequest req, long now, ApiVersionsResponse apiVersionsResponse) {\n        final String node = req.destination;\n        if (apiVersionsResponse.data().errorCode() != Errors.NONE.code()) {\n            if (req.request.version() == 0 || apiVersionsResponse.data().errorCode() != Errors.UNSUPPORTED_VERSION.code()) {\n                log.warn(\"Received error {} from node {} when making an ApiVersionsRequest with correlation id {}. Disconnecting.\",\n                        Errors.forCode(apiVersionsResponse.data().errorCode()), node, req.header.correlationId());\n                this.selector.close(node);\n                processDisconnection(responses, node, now, ChannelState.LOCAL_CLOSE);\n            } else {\n                // Starting from Apache Kafka 2.4, ApiKeys field is populated with the supported versions of\n                // the ApiVersionsRequest when an UNSUPPORTED_VERSION error is returned.\n                // If not provided, the client falls back to version 0.\n                short maxApiVersion = 0;\n                if (apiVersionsResponse.data().apiKeys().size() > 0) {\n                    ApiVersion apiVersion = apiVersionsResponse.data().apiKeys().find(ApiKeys.API_VERSIONS.id);\n                    if (apiVersion != null) {\n                        maxApiVersion = apiVersion.maxVersion();\n                    }\n                }\n                nodesNeedingApiVersionsFetch.put(node, new ApiVersionsRequest.Builder(maxApiVersion));\n            }\n            return;\n        }\n        NodeApiVersions nodeVersionInfo = new NodeApiVersions(\n            apiVersionsResponse.data().apiKeys(),\n            apiVersionsResponse.data().supportedFeatures(),\n            apiVersionsResponse.data().finalizedFeatures(),\n            apiVersionsResponse.data().finalizedFeaturesEpoch());\n        apiVersions.update(node, nodeVersionInfo);\n        this.connectionStates.ready(node);\n        log.debug(\"Node {} has finalized features epoch: {}, finalized features: {}, supported features: {}, API versions: {}.\",\n                node, apiVersionsResponse.data().finalizedFeaturesEpoch(), apiVersionsResponse.data().finalizedFeatures(),\n                apiVersionsResponse.data().supportedFeatures(), nodeVersionInfo);\n    }\n\n    /**\n     * Handle any disconnected connections",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L911-L1060",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 911,
  "end_line": 1060,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}