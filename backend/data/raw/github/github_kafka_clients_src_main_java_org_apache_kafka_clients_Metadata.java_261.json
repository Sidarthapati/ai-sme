{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_Metadata.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "content": "     * Check whether an update has been explicitly requested.\n     *\n     * @return true if an update was requested, false otherwise\n     */\n    public synchronized boolean updateRequested() {\n        return this.needFullUpdate || this.needPartialUpdate;\n    }\n\n    public synchronized void addClusterUpdateListener(ClusterResourceListener listener) {\n        this.clusterResourceListeners.maybeAdd(listener);\n    }\n\n    /**\n     * Return the cached partition info if it exists and a newer leader epoch isn't known about.\n     */\n    public synchronized Optional<MetadataResponse.PartitionMetadata> partitionMetadataIfCurrent(TopicPartition topicPartition) {\n        Integer epoch = lastSeenLeaderEpochs.get(topicPartition);\n        Optional<MetadataResponse.PartitionMetadata> partitionMetadata = metadataSnapshot.partitionMetadata(topicPartition);\n        if (epoch == null) {\n            // old cluster format (no epochs)\n            return partitionMetadata;\n        } else {\n            return partitionMetadata.filter(metadata ->\n                    metadata.leaderEpoch.orElse(NO_PARTITION_LEADER_EPOCH).equals(epoch));\n        }\n    }\n\n    /**\n     * @return a mapping from topic names to topic IDs for all topics with valid IDs in the cache\n     */\n    public Map<String, Uuid> topicIds() {\n        return metadataSnapshot.topicIds();\n    }\n\n    public synchronized LeaderAndEpoch currentLeader(TopicPartition topicPartition) {\n        Optional<MetadataResponse.PartitionMetadata> maybeMetadata = partitionMetadataIfCurrent(topicPartition);\n        if (maybeMetadata.isEmpty())\n            return new LeaderAndEpoch(Optional.empty(), Optional.ofNullable(lastSeenLeaderEpochs.get(topicPartition)));\n\n        MetadataResponse.PartitionMetadata partitionMetadata = maybeMetadata.get();\n        Optional<Integer> leaderEpochOpt = partitionMetadata.leaderEpoch;\n        Optional<Node> leaderNodeOpt = partitionMetadata.leaderId.flatMap(metadataSnapshot::nodeById);\n        return new LeaderAndEpoch(leaderNodeOpt, leaderEpochOpt);\n    }\n\n    public synchronized void bootstrap(List<InetSocketAddress> addresses) {\n        this.needFullUpdate = true;\n        this.updateVersion += 1;\n        this.metadataSnapshot = MetadataSnapshot.bootstrap(addresses);\n        this.bootstrapAddresses = addresses;\n    }\n\n    public synchronized void rebootstrap() {\n        log.info(\"Rebootstrapping with {}\", this.bootstrapAddresses);\n        this.bootstrap(this.bootstrapAddresses);\n    }\n\n    /**\n     * Update metadata assuming the current request version.\n     *\n     * For testing only.\n     */\n    public synchronized void updateWithCurrentRequestVersion(MetadataResponse response, boolean isPartialUpdate, long nowMs) {\n        this.update(this.requestVersion, response, isPartialUpdate, nowMs);\n    }\n\n    /**\n     * Updates the cluster metadata. If topic expiry is enabled, expiry time\n     * is set for topics if required and expired topics are removed from the metadata.\n     *\n     * @param requestVersion The request version corresponding to the update response, as provided by\n     *     {@link #newMetadataRequestAndVersion(long)}.\n     * @param response metadata response received from the broker\n     * @param isPartialUpdate whether the metadata request was for a subset of the active topics\n     * @param nowMs current time in milliseconds\n     */\n    public synchronized void update(int requestVersion, MetadataResponse response, boolean isPartialUpdate, long nowMs) {\n        Objects.requireNonNull(response, \"Metadata response cannot be null\");\n        if (isClosed())\n            throw new IllegalStateException(\"Update requested after metadata close\");\n\n        this.needPartialUpdate = requestVersion < this.requestVersion;\n        this.lastRefreshMs = nowMs;\n        this.attempts = 0;\n        this.updateVersion += 1;\n        if (!isPartialUpdate) {\n            this.needFullUpdate = false;\n            this.lastSuccessfulRefreshMs = nowMs;\n        }\n        // If we subsequently find that the metadata response is not equivalent to the metadata already known,\n        // this count is reset to 0 in updateLatestMetadata()\n        this.equivalentResponseCount++;\n\n        String previousClusterId = metadataSnapshot.clusterResource().clusterId();\n\n        this.metadataSnapshot = handleMetadataResponse(response, isPartialUpdate, nowMs);\n\n        Cluster cluster = metadataSnapshot.cluster();\n        maybeSetMetadataError(cluster);\n\n        this.lastSeenLeaderEpochs.keySet().removeIf(tp -> !retainTopic(tp.topic(), false, nowMs));\n\n        String newClusterId = metadataSnapshot.clusterResource().clusterId();\n        if (!Objects.equals(previousClusterId, newClusterId)) {\n            log.info(\"Cluster ID: {}\", newClusterId);\n        }\n        clusterResourceListeners.onUpdate(metadataSnapshot.clusterResource());\n\n        log.debug(\"Updated cluster metadata updateVersion {} to {}\", this.updateVersion, this.metadataSnapshot);\n    }\n\n    /**\n     * Updates the partition-leadership info in the metadata. Update is done by merging existing metadata with the input leader information and nodes.\n     * This is called whenever partition-leadership updates are returned in a response from broker(ex - ProduceResponse & FetchResponse).\n     * Note that the updates via Metadata RPC are handled separately in ({@link #update}).\n     * Both partitionLeader and leaderNodes override the existing metadata. Non-overlapping metadata is kept as it is.\n     * @param partitionLeaders map of new leadership information for partitions.\n     * @param leaderNodes a list of nodes for leaders in the above map.\n     * @return a set of partitions, for which leaders were updated.\n     */\n    public synchronized Set<TopicPartition> updatePartitionLeadership(Map<TopicPartition, LeaderIdAndEpoch> partitionLeaders, List<Node> leaderNodes) {\n        Map<Integer, Node> newNodes = leaderNodes.stream().collect(Collectors.toMap(Node::id, node -> node));\n        // Insert non-overlapping nodes from existing-nodes into new-nodes.\n        this.metadataSnapshot.cluster().nodes().forEach(node -> newNodes.putIfAbsent(node.id(), node));\n\n        // Create partition-metadata for all updated partitions. Exclude updates for partitions -\n        // 1. for which the corresponding partition has newer leader in existing metadata.\n        // 2. for which corresponding leader's node is missing in the new-nodes.\n        // 3. for which the existing metadata doesn't know about the partition.\n        List<PartitionMetadata> updatePartitionMetadata = new ArrayList<>();\n        for (Entry<TopicPartition, Metadata.LeaderIdAndEpoch> partitionLeader: partitionLeaders.entrySet()) {\n            TopicPartition partition = partitionLeader.getKey();\n            Metadata.LeaderAndEpoch currentLeader = currentLeader(partition);\n            Metadata.LeaderIdAndEpoch newLeader = partitionLeader.getValue();\n            if (newLeader.epoch.isEmpty() || newLeader.leaderId.isEmpty()) {\n                log.debug(\"For {}, incoming leader information is incomplete {}\", partition, newLeader);\n                continue;\n            }\n            if (currentLeader.epoch.isPresent() && newLeader.epoch.get() <= currentLeader.epoch.get()) {\n                log.debug(\"For {}, incoming leader({}) is not-newer than the one in the existing metadata {}, so ignoring.\", partition, newLeader, currentLeader);\n                continue;\n            }\n            if (!newNodes.containsKey(newLeader.leaderId.get())) {\n                log.debug(\"For {}, incoming leader({}), the corresponding node information for node-id {} is missing, so ignoring.\", partition, newLeader, newLeader.leaderId.get());\n                continue;\n            }\n            if (this.metadataSnapshot.partitionMetadata(partition).isEmpty()) {\n                log.debug(\"For {}, incoming leader({}), partition metadata is no longer cached, ignoring.\", partition, newLeader);\n                continue;\n            }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/Metadata.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.578514",
  "source_type": "github"
}