{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_KafkaProducer.java_781",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "content": "    /**\n     * Prepares the current transaction for a two-phase commit. This method will flush all pending messages\n     * and transition the producer into a mode where only {@link #commitTransaction()}, {@link #abortTransaction()},\n     * or completeTransaction(PreparedTxnState) may be called.\n     * <p>\n     * This method is used as part of a two-phase commit protocol:\n     * <ol>\n     *   <li>Prepare the transaction by calling this method. This returns a {@link PreparedTxnState} if successful.</li>\n     *   <li>Make any external system changes that need to be atomic with this transaction.</li>\n     *   <li>Complete the transaction by calling {@link #commitTransaction()}, {@link #abortTransaction()} or\n     *       completeTransaction(PreparedTxnState).</li>\n     * </ol>\n     *\n     * @return the prepared transaction state to use when completing the transaction\n     *\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started yet.\n     * @throws InvalidTxnStateException if the producer is not in a state where preparing\n     *         a transaction is possible or 2PC is not enabled.\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws UnsupportedVersionException fatal error indicating the broker\n     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)\n     * @throws AuthorizationException fatal error indicating that the configured\n     *         transactional.id is not authorized. See the exception for more details\n     * @throws KafkaException if the producer has encountered a previous fatal error or for any other unexpected error\n     * @throws TimeoutException if the time taken for preparing the transaction has surpassed <code>max.block.ms</code>\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    @Override\n    public PreparedTxnState prepareTransaction() throws ProducerFencedException {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        throwIfInPreparedState();\n        if (!transactionManager.is2PCEnabled()) {\n            throw new InvalidTxnStateException(\"Cannot prepare a transaction when 2PC is not enabled\");\n        }\n        long now = time.nanoseconds();\n        flush();\n        transactionManager.prepareTransaction();\n        producerMetrics.recordPrepareTxn(time.nanoseconds() - now);\n        ProducerIdAndEpoch producerIdAndEpoch = transactionManager.preparedTransactionState();\n        return new PreparedTxnState(producerIdAndEpoch.producerId, producerIdAndEpoch.epoch);\n    }\n\n    /**\n     * Commits the ongoing transaction. This method will flush any unsent records before actually committing the transaction.\n     * <p>\n     * Further, if any of the {@link #send(ProducerRecord)} calls which were part of the transaction hit irrecoverable\n     * errors, this method will throw the last received exception immediately and the transaction will not be committed.\n     * So all {@link #send(ProducerRecord)} calls in a transaction must succeed in order for this method to succeed.\n     * <p>\n     * If the transaction is committed successfully and this method returns without throwing an exception, it is guaranteed\n     * that all {@link Callback callbacks} for records in the transaction will have been invoked and completed.\n     * Note that exceptions thrown by callbacks are ignored; the producer proceeds to commit the transaction in any case.\n     * <p>\n     * Note that this method will raise {@link TimeoutException} if the transaction cannot be committed before expiration\n     * of {@code max.block.ms}, but this does not mean the request did not actually reach the broker. In fact, it only indicates\n     * that we cannot get the acknowledgement response in time, so it's up to the application's logic\n     * to decide how to handle timeouts.\n     * Additionally, it will raise {@link InterruptException} if interrupted.\n     * It is safe to retry in either case, but it is not possible to attempt a different operation (such as abortTransaction)\n     * since the commit may already be in the progress of completing. If not retrying, the only option is to close the producer.\n     *\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker\n     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)\n     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured\n     *         transactional.id is not authorized. See the exception for more details\n     * @throws org.apache.kafka.common.errors.InvalidProducerEpochException if the producer has attempted to produce with an old epoch\n     *         to the partition leader. See the exception for more details\n     * @throws KafkaException if the producer has encountered a previous fatal or abortable error, or for any\n     *         other unexpected error\n     * @throws TimeoutException if the time taken for committing the transaction has surpassed <code>max.block.ms</code>.\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    public void commitTransaction() throws ProducerFencedException {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        long commitStart = time.nanoseconds();\n        TransactionalRequestResult result = transactionManager.beginCommit();\n        sender.wakeup();\n        result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS, COMMIT_TXN_TIMEOUT_MSG);\n        producerMetrics.recordCommitTxn(time.nanoseconds() - commitStart);\n    }\n\n    /**\n     * Aborts the ongoing transaction. Any unflushed produce messages will be aborted when this call is made.\n     * This call will throw an exception immediately if any prior {@link #send(ProducerRecord)} calls failed with a\n     * {@link ProducerFencedException} or an instance of {@link org.apache.kafka.common.errors.AuthorizationException}.\n     * <p>\n     * Note that this method will raise {@link TimeoutException} if the transaction cannot be aborted before expiration\n     * of {@code max.block.ms}, but this does not mean the request did not actually reach the broker. In fact, it only indicates\n     * that we cannot get the acknowledgement response in time, so it's up to the application's logic\n     * to decide how to handle timeouts. Additionally, it will raise {@link InterruptException} if interrupted.\n     * It is safe to retry in either case, but it is not possible to attempt a different operation (such as {@link #commitTransaction})\n     * since the abort may already be in the progress of completing. If not retrying, the only option is to close the producer.\n     *\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws org.apache.kafka.common.errors.InvalidProducerEpochException if the producer has attempted to produce with an old epoch\n     *         to the partition leader. See the exception for more details\n     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker\n     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)\n     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured\n     *         transactional.id is not authorized. See the exception for more details\n     * @throws KafkaException if the producer has encountered a previous fatal error or for any other unexpected error\n     * @throws TimeoutException if the time taken for aborting the transaction has surpassed <code>max.block.ms</code>.\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    public void abortTransaction() throws ProducerFencedException {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        log.info(\"Aborting incomplete transaction\");\n        long abortStart = time.nanoseconds();\n        TransactionalRequestResult result = transactionManager.beginAbort();\n        sender.wakeup();\n        result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS, ABORT_TXN_TIMEOUT_MSG);\n        producerMetrics.recordAbortTxn(time.nanoseconds() - abortStart);\n    }\n\n    /**\n     * Completes a prepared transaction by comparing the provided prepared transaction state with the\n     * current prepared state on the producer.\n     * If they match, the transaction is committed; otherwise, it is aborted.\n     * \n     * @param preparedTxnState              The prepared transaction state to compare against the current state\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started\n     * @throws InvalidTxnStateException if the producer is not in prepared state\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws KafkaException if the producer has encountered a previous fatal error or for any other unexpected error\n     * @throws TimeoutException if the time taken for completing the transaction has surpassed <code>max.block.ms</code>\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    @Override\n    public void completeTransaction(PreparedTxnState preparedTxnState) throws ProducerFencedException {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        \n        if (!transactionManager.isPrepared()) {\n            throw new InvalidTxnStateException(\"Cannot complete transaction because no transaction has been prepared. \" +\n                \"Call prepareTransaction() first, or make sure initTransaction(true) was called.\");\n        }\n        \n        // Get the current prepared transaction state\n        ProducerIdAndEpoch currentProducerIdAndEpoch = transactionManager.preparedTransactionState();\n        PreparedTxnState currentPreparedState = new PreparedTxnState(currentProducerIdAndEpoch.producerId, currentProducerIdAndEpoch.epoch);\n        \n        // Compare the prepared transaction state token and commit or abort accordingly\n        if (currentPreparedState.equals(preparedTxnState)) {\n            commitTransaction();",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L781-L930",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 781,
  "end_line": 930,
  "last_modified": "2026-02-06T01:16:27.608270",
  "source_type": "github"
}