{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1041",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "         * The remaining milliseconds until the next timeout will be updated.\n         *\n         * @param calls The collection of calls.\n         * @return The number of calls which were timed out.\n         */\n        int handleTimeouts(Collection<Call> calls, String msg) {\n            int numTimedOut = 0;\n            for (Iterator<Call> iter = calls.iterator(); iter.hasNext(); ) {\n                Call call = iter.next();\n                int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);\n                if (remainingMs < 0) {\n                    call.fail(now, new TimeoutException(msg + \" Call: \" + call.callName));\n                    iter.remove();\n                    numTimedOut++;\n                } else {\n                    nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);\n                }\n            }\n            return numTimedOut;\n        }\n\n        /**\n         * Check whether a call should be timed out.\n         * The remaining milliseconds until the next timeout will be updated.\n         *\n         * @param call The call.\n         * @return True if the call should be timed out.\n         */\n        boolean callHasExpired(Call call) {\n            int remainingMs = calcTimeoutMsRemainingAsInt(now, call.deadlineMs);\n            if (remainingMs < 0)\n                return true;\n            nextTimeoutMs = Math.min(nextTimeoutMs, remainingMs);\n            return false;\n        }\n\n        int nextTimeoutMs() {\n            return nextTimeoutMs;\n        }\n    }\n\n    private final class AdminClientRunnable implements Runnable {\n        /**\n         * Calls which have not yet been assigned to a node.\n         * Only accessed from this thread.\n         */\n        private final ArrayList<Call> pendingCalls = new ArrayList<>();\n\n        /**\n         * Maps nodes to calls that we want to send.\n         * Only accessed from this thread.\n         */\n        private final Map<Node, List<Call>> callsToSend = new HashMap<>();\n\n        /**\n         * Maps node ID strings to calls that have been sent.\n         * Only accessed from this thread.\n         */\n        private final Map<String, Call> callsInFlight = new HashMap<>();\n\n        /**\n         * Maps correlation IDs to calls that have been sent.\n         * Only accessed from this thread.\n         */\n        private final Map<Integer, Call> correlationIdToCalls = new HashMap<>();\n\n        /**\n         * Pending calls. Protected by the object monitor.\n         */\n        private final List<Call> newCalls = new LinkedList<>();\n\n        /**\n         * Maps node ID strings to their readiness deadlines.  A node will appear in this\n         * map if there are callsToSend which are waiting for it to be ready, and there\n         * are no calls in flight using the node.\n         */\n        private final Map<Node, Long> nodeReadyDeadlines = new HashMap<>();\n\n        /**\n         * Whether the admin client is closing.\n         */\n        private volatile boolean closing = false;\n\n        /**\n         * Time out the elements in the pendingCalls list which are expired.\n         *\n         * @param processor The timeout processor.\n         */\n        private void timeoutPendingCalls(TimeoutProcessor processor) {\n            int numTimedOut = processor.handleTimeouts(pendingCalls, \"Timed out waiting for a node assignment.\");\n            if (numTimedOut > 0)\n                log.debug(\"Timed out {} pending calls.\", numTimedOut);\n        }\n\n        /**\n         * Time out calls which have been assigned to nodes.\n         *\n         * @param processor The timeout processor.\n         */\n        private int timeoutCallsToSend(TimeoutProcessor processor) {\n            int numTimedOut = 0;\n            for (List<Call> callList : callsToSend.values()) {\n                numTimedOut += processor.handleTimeouts(callList,\n                    \"Timed out waiting to send the call.\");\n            }\n            if (numTimedOut > 0)\n                log.debug(\"Timed out {} call(s) with assigned nodes.\", numTimedOut);\n            return numTimedOut;\n        }\n\n        /**\n         * Drain all the calls from newCalls into pendingCalls.\n         * <p>\n         * This function holds the lock for the minimum amount of time, to avoid blocking\n         * users of AdminClient who will also take the lock to add new calls.\n         */\n        private synchronized void drainNewCalls() {\n            transitionToPendingAndClearList(newCalls);\n        }\n\n        /**\n         * Add some calls to pendingCalls, and then clear the input list.\n         * Also clears Call#curNode.\n         *\n         * @param calls The calls to add.\n         */\n        private void transitionToPendingAndClearList(List<Call> calls) {\n            for (Call call : calls) {\n                call.curNode = null;\n                pendingCalls.add(call);\n            }\n            calls.clear();\n        }\n\n        /**\n         * Choose nodes for the calls in the pendingCalls list.\n         *\n         * @param now The current time in milliseconds.\n         * @return The minimum time until a call is ready to be retried if any of the pending\n         * calls are backing off after a failure\n         */\n        private long maybeDrainPendingCalls(long now) {\n            long pollTimeout = Long.MAX_VALUE;\n            log.trace(\"Trying to choose nodes for {} at {}\", pendingCalls, now);\n\n            List<Call> toRemove = new ArrayList<>();\n            // Using pendingCalls.size() to get the list size before the for-loop to avoid infinite loop.\n            // If call.fail keeps adding the call to pendingCalls,\n            // the loop like for (int i = 0; i < pendingCalls.size(); i++) can't stop.\n            int pendingSize = pendingCalls.size();",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1041-L1190",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1041,
  "end_line": 1190,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}