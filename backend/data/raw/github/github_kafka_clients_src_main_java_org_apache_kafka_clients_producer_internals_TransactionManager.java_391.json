{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_391",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "    }\n\n    private TransactionalRequestResult beginCompletingTransaction(TransactionResult transactionResult) {\n        if (!newPartitionsInTransaction.isEmpty())\n            enqueueRequest(addPartitionsToTransactionHandler());\n\n        EndTxnRequest.Builder builder = new EndTxnRequest.Builder(\n            new EndTxnRequestData()\n                .setTransactionalId(transactionalId)\n                .setProducerId(producerIdAndEpoch.producerId)\n                .setProducerEpoch(producerIdAndEpoch.epoch)\n                .setCommitted(transactionResult.id),\n            isTransactionV2Enabled\n        );\n\n        // Maybe update the transaction version here before we enqueue the EndTxn request so there are no races with\n        // completion of the EndTxn request. Since this method may update clientSideEpochBumpRequired, we want to update\n        // before the check below, but we also want to call it after the EndTxnRequest.Builder so we complete the transaction\n        // with the same version as it started.\n        maybeUpdateTransactionV2Enabled(false);\n\n        EndTxnHandler handler = new EndTxnHandler(builder);\n        enqueueRequest(handler);\n\n        // If an epoch bump is required for recovery, initialize the transaction after completing the EndTxn request.\n        // If we are upgrading to TV2 transactions on the next transaction, also bump the epoch.\n        if (clientSideEpochBumpRequired) {\n            return initializeTransactions(this.producerIdAndEpoch);\n        }\n\n        return handler.result;\n    }\n\n    public synchronized TransactionalRequestResult sendOffsetsToTransaction(final Map<TopicPartition, OffsetAndMetadata> offsets,\n                                                                            final ConsumerGroupMetadata groupMetadata) {\n        ensureTransactional();\n        throwIfPendingState(TransactionOperation.SEND_OFFSETS_TO_TRANSACTION);\n        maybeFailWithError();\n\n        if (currentState != State.IN_TRANSACTION) {\n            throw new IllegalStateException(\"Cannot send offsets if a transaction is not in progress \" +\n                \"(currentState= \" + currentState + \")\");\n        }\n\n        // In transaction V2, the client will skip sending AddOffsetsToTxn before sending txnOffsetCommit.\n        TxnRequestHandler handler;\n        if (isTransactionV2Enabled()) {\n            log.debug(\"Begin adding offsets {} for consumer group {} to transaction with transaction protocol V2\", offsets, groupMetadata);\n            handler = txnOffsetCommitHandler(null, offsets, groupMetadata);\n            transactionStarted = true;\n        } else {\n            log.debug(\"Begin adding offsets {} for consumer group {} to transaction\", offsets, groupMetadata);\n            AddOffsetsToTxnRequest.Builder builder = new AddOffsetsToTxnRequest.Builder(\n                    new AddOffsetsToTxnRequestData()\n                            .setTransactionalId(transactionalId)\n                            .setProducerId(producerIdAndEpoch.producerId)\n                            .setProducerEpoch(producerIdAndEpoch.epoch)\n                            .setGroupId(groupMetadata.groupId())\n            );\n            handler = new AddOffsetsToTxnHandler(builder, offsets, groupMetadata);\n        }\n\n        enqueueRequest(handler);\n        return handler.result;\n    }\n\n    public synchronized void maybeAddPartition(TopicPartition topicPartition) {\n        maybeFailWithError();\n        throwIfPendingState(TransactionOperation.SEND);\n\n        if (isTransactional()) {\n            if (!hasProducerId()) {\n                throw new IllegalStateException(\"Cannot add partition \" + topicPartition +\n                    \" to transaction before completing a call to initTransactions\");\n            } else if (currentState != State.IN_TRANSACTION) {\n                throw new IllegalStateException(\"Cannot add partition \" + topicPartition +\n                    \" to transaction while in state  \" + currentState);\n            } else if (isTransactionV2Enabled()) {\n                txnPartitionMap.getOrCreate(topicPartition);\n                partitionsInTransaction.add(topicPartition);\n                transactionStarted = true;\n            } else if (transactionContainsPartition(topicPartition) || isPartitionPendingAdd(topicPartition)) {\n                return;\n            } else {\n                log.debug(\"Begin adding new partition {} to transaction\", topicPartition);\n                txnPartitionMap.getOrCreate(topicPartition);\n                newPartitionsInTransaction.add(topicPartition);\n            }\n        }\n    }\n\n    RuntimeException lastError() {\n        return lastError;\n    }\n\n    synchronized boolean isSendToPartitionAllowed(TopicPartition tp) {\n        if (hasFatalError())\n            return false;\n        return !isTransactional() || partitionsInTransaction.contains(tp);\n    }\n\n    public String transactionalId() {\n        return transactionalId;\n    }\n\n    public boolean hasProducerId() {\n        return producerIdAndEpoch.isValid();\n    }\n\n    public boolean isTransactional() {\n        return transactionalId != null;\n    }\n\n    /**\n     *  Check all the finalized features from apiVersions to verify whether the transaction V2 is enabled.\n     *  Sets clientSideEpochBumpRequired if upgrading to V2 since we need to bump the epoch.\n     *  This is because V2 no longer adds partitions explicitly and there are some edge cases on upgrade\n     *  that can be avoided by fencing the old V1 transaction epoch. For example, we won't consider\n     *  partitions from the previous transaction as already added to the new V2 transaction if the epoch is fenced.\n     */\n\n    public synchronized void maybeUpdateTransactionV2Enabled(boolean onInitiatialization) {\n        if (latestFinalizedFeaturesEpoch >= apiVersions.getMaxFinalizedFeaturesEpoch()) {\n            return;\n        }\n        ApiVersions.FinalizedFeaturesInfo info = apiVersions.getFinalizedFeaturesInfo();\n        latestFinalizedFeaturesEpoch = info.finalizedFeaturesEpoch;\n        Short transactionVersion = info.finalizedFeatures.get(\"transaction.version\");\n        boolean wasTransactionV2Enabled = isTransactionV2Enabled;\n        isTransactionV2Enabled = transactionVersion != null && transactionVersion >= 2;\n        log.debug(\"Updating isTV2 enabled to {} with FinalizedFeaturesEpoch {}\", isTransactionV2Enabled, latestFinalizedFeaturesEpoch);\n        if (!onInitiatialization && !wasTransactionV2Enabled && isTransactionV2Enabled)\n            clientSideEpochBumpRequired = true;\n    }\n\n    public boolean isTransactionV2Enabled() {\n        return isTransactionV2Enabled;\n    }\n\n    public boolean is2PCEnabled() {\n        return enable2PC;\n    }\n\n    synchronized boolean hasPartitionsToAdd() {\n        return !newPartitionsInTransaction.isEmpty() || !pendingPartitionsInTransaction.isEmpty();\n    }\n\n    synchronized boolean isCompleting() {\n        return currentState == State.COMMITTING_TRANSACTION || currentState == State.ABORTING_TRANSACTION;\n    }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L391-L540",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 391,
  "end_line": 540,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}