{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_KafkaProducer.java_651",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "content": "     *      messages issued by the producer.</li>\n     * </ol>\n     *\n     * <p>\n     * When {@code keepPreparedTxn} is set to {@code true}, the producer does <em>not</em> automatically abort existing\n     * transactions. Instead, it enters a recovery mode allowing only finalization of those previously\n     * prepared transactions.\n     * This behavior is especially crucial for 2PC scenarios, where transactions should remain intact\n     * until the external transaction manager decides whether to commit or abort.\n     * <p>\n     *\n     * @param keepPreparedTxn true to retain any in-flight prepared transactions (necessary for 2PC\n     *                        recovery), false to abort existing transactions and behave like\n     *                        the standard initTransactions.\n     *\n     * Note that this method will raise {@link TimeoutException} if the transactional state cannot\n     * be initialized before expiration of {@code max.block.ms}. Additionally, it will raise {@link InterruptException}\n     * if interrupted. It is safe to retry in either case, but once the transactional state has been successfully\n     * initialized, this method should no longer be used.\n     *\n     * @throws IllegalStateException if no {@code transactional.id} is configured\n     * @throws org.apache.kafka.common.errors.UnsupportedVersionException if the broker does not\n     *         support transactions (i.e. if its version is lower than 0.11.0.0)\n     * @throws org.apache.kafka.common.errors.TransactionalIdAuthorizationException if the configured\n     *         {@code transactional.id} is unauthorized either for normal transaction writes or 2PC.\n     * @throws KafkaException if the producer encounters a fatal error or any other unexpected error\n     * @throws TimeoutException if the time taken for initialize the transaction has surpassed <code>max.block.ms</code>.\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    public void initTransactions(boolean keepPreparedTxn) {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        throwIfInPreparedState();\n        long now = time.nanoseconds();\n        TransactionalRequestResult result = transactionManager.initializeTransactions(keepPreparedTxn);\n        sender.wakeup();\n        result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS, INIT_TXN_TIMEOUT_MSG);\n        producerMetrics.recordInit(time.nanoseconds() - now);\n        transactionManager.maybeUpdateTransactionV2Enabled(true);\n    }\n\n    /**\n     * Should be called before the start of each new transaction. Note that prior to the first invocation\n     * of this method, you must invoke {@link #initTransactions()} exactly one time.\n     *\n     * @throws IllegalStateException if no {@code transactional.id} has been configured or if {@link #initTransactions()}\n     *         has not yet been invoked\n     * @throws ProducerFencedException if another producer with the same transactional.id is active\n     * @throws org.apache.kafka.common.errors.InvalidProducerEpochException if the producer has attempted to produce with an old epoch\n     *         to the partition leader. See the exception for more details\n     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker\n     *         does not support transactions (i.e. if its version is lower than 0.11.0.0)\n     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured\n     *         {@code transactional.id} is not authorized. See the exception for more details\n     * @throws KafkaException if the producer has encountered a previous fatal error or for any other unexpected error\n     */\n    public void beginTransaction() throws ProducerFencedException {\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        throwIfInPreparedState();\n        long now = time.nanoseconds();\n        transactionManager.beginTransaction();\n        producerMetrics.recordBeginTxn(time.nanoseconds() - now);\n    }\n\n    /**\n     * Sends a list of specified offsets to the consumer group coordinator, and also marks\n     * those offsets as part of the current transaction. These offsets will be considered\n     * committed only if the transaction is committed successfully. The committed offset should\n     * be the next message your application will consume, i.e. {@code nextRecordToBeProcessed.offset()}\n     * (or {@link ConsumerRecords#nextOffsets()}). You should also add the leader epoch as commit metadata,\n     * which can be obtained from {@link ConsumerRecord#leaderEpoch()} or {@link ConsumerRecords#nextOffsets()}.\n     * <p>\n     * This method should be used when you need to batch consumed and produced messages\n     * together, typically in a consume-transform-produce pattern. Thus, the specified\n     * {@code groupMetadata} should be extracted from the used {@link KafkaConsumer consumer} via\n     * {@link KafkaConsumer#groupMetadata()} to leverage consumer group metadata. This will provide\n     * stronger fencing than just supplying the {@code consumerGroupId} and passing in {@code new ConsumerGroupMetadata(consumerGroupId)},\n     * however note that the full set of consumer group metadata returned by {@link KafkaConsumer#groupMetadata()}\n     * requires the brokers to be on version 2.5 or newer to understand.\n     *\n     * <p>\n     * This method is a blocking call that waits until the request has been received and acknowledged by the consumer group\n     * coordinator; but the offsets are not considered as committed until the transaction itself is successfully committed later (via\n     * the {@link #commitTransaction()} call).\n     *\n     * <p>\n     * Note, that the consumer should have {@code enable.auto.commit=false} and should\n     * also not commit offsets manually (via {@link KafkaConsumer#commitSync(Map) sync} or\n     * {@link KafkaConsumer#commitAsync(Map, OffsetCommitCallback) async} commits).\n     * This method will raise {@link TimeoutException} if the producer cannot send offsets before expiration of {@code max.block.ms}.\n     * Additionally, it will raise {@link InterruptException} if interrupted.\n     *\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started.\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws org.apache.kafka.common.errors.UnsupportedVersionException fatal error indicating the broker\n     *         does not support transactions (i.e. if its version is lower than 0.11.0.0) or\n     *         the broker doesn't support the latest version of transactional API with all consumer group metadata\n     *         (i.e. if its version is lower than 2.5.0).\n     * @throws org.apache.kafka.common.errors.UnsupportedForMessageFormatException fatal error indicating the message\n     *         format used for the offsets topic on the broker does not support transactions\n     * @throws org.apache.kafka.common.errors.AuthorizationException fatal error indicating that the configured\n     *         transactional.id is not authorized, or the consumer group id is not authorized.\n     * @throws org.apache.kafka.clients.consumer.CommitFailedException if the commit failed and cannot be retried\n     *         (e.g. if the consumer has been kicked out of the group). Users should handle this by aborting the transaction.\n     * @throws org.apache.kafka.common.errors.FencedInstanceIdException if this producer instance gets fenced by broker due to a\n     *                                                                  mis-configured consumer instance id within group metadata.\n     * @throws org.apache.kafka.common.errors.InvalidProducerEpochException if the producer has attempted to produce with an old epoch\n     *         to the partition leader. See the exception for more details\n     * @throws KafkaException if the producer has encountered a previous fatal or abortable error, or for any\n     *         other unexpected error\n     * @throws TimeoutException if the time taken for sending the offsets has surpassed <code>max.block.ms</code>.\n     * @throws InterruptException if the thread is interrupted while blocked\n     */\n    public void sendOffsetsToTransaction(Map<TopicPartition, OffsetAndMetadata> offsets,\n                                         ConsumerGroupMetadata groupMetadata) throws ProducerFencedException {\n        throwIfInvalidGroupMetadata(groupMetadata);\n        throwIfNoTransactionManager();\n        throwIfProducerClosed();\n        throwIfInPreparedState();\n\n        if (!offsets.isEmpty()) {\n            long start = time.nanoseconds();\n            TransactionalRequestResult result = transactionManager.sendOffsetsToTransaction(offsets, groupMetadata);\n            sender.wakeup();\n            result.await(maxBlockTimeMs, TimeUnit.MILLISECONDS, SEND_OFFSETS_TIMEOUT_MSG);\n            producerMetrics.recordSendOffsets(time.nanoseconds() - start);\n        }\n    }\n\n    /**\n     * Prepares the current transaction for a two-phase commit. This method will flush all pending messages\n     * and transition the producer into a mode where only {@link #commitTransaction()}, {@link #abortTransaction()},\n     * or completeTransaction(PreparedTxnState) may be called.\n     * <p>\n     * This method is used as part of a two-phase commit protocol:\n     * <ol>\n     *   <li>Prepare the transaction by calling this method. This returns a {@link PreparedTxnState} if successful.</li>\n     *   <li>Make any external system changes that need to be atomic with this transaction.</li>\n     *   <li>Complete the transaction by calling {@link #commitTransaction()}, {@link #abortTransaction()} or\n     *       completeTransaction(PreparedTxnState).</li>\n     * </ol>\n     *\n     * @return the prepared transaction state to use when completing the transaction\n     *\n     * @throws IllegalStateException if no transactional.id has been configured or no transaction has been started yet.\n     * @throws InvalidTxnStateException if the producer is not in a state where preparing\n     *         a transaction is possible or 2PC is not enabled.\n     * @throws ProducerFencedException fatal error indicating another producer with the same transactional.id is active\n     * @throws UnsupportedVersionException fatal error indicating the broker",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L651-L800",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 651,
  "end_line": 800,
  "last_modified": "2026-02-06T01:16:27.608270",
  "source_type": "github"
}