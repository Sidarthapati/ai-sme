{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_651",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "        long updatedNow = this.time.milliseconds();\n        List<ClientResponse> responses = new ArrayList<>();\n        handleCompletedSends(responses, updatedNow);\n        handleCompletedReceives(responses, updatedNow);\n        handleDisconnections(responses, updatedNow);\n        handleConnections();\n        handleInitiateApiVersionRequests(updatedNow);\n        handleTimedOutConnections(responses, updatedNow);\n        handleTimedOutRequests(responses, updatedNow);\n        handleRebootstrap(responses, updatedNow);\n        completeResponses(responses);\n\n        return responses;\n    }\n\n    private void completeResponses(List<ClientResponse> responses) {\n        for (ClientResponse response : responses) {\n            try {\n                response.onComplete();\n            } catch (Exception e) {\n                log.error(\"Uncaught error in request completion:\", e);\n            }\n        }\n    }\n\n    /**\n     * Get the number of in-flight requests\n     */\n    @Override\n    public int inFlightRequestCount() {\n        return this.inFlightRequests.count();\n    }\n\n    @Override\n    public boolean hasInFlightRequests() {\n        return !this.inFlightRequests.isEmpty();\n    }\n\n    /**\n     * Get the number of in-flight requests for a given node\n     */\n    @Override\n    public int inFlightRequestCount(String node) {\n        return this.inFlightRequests.count(node);\n    }\n\n    @Override\n    public boolean hasInFlightRequests(String node) {\n        return !this.inFlightRequests.isEmpty(node);\n    }\n\n    @Override\n    public boolean hasReadyNodes(long now) {\n        return connectionStates.hasReadyNodes(now);\n    }\n\n    /**\n     * Interrupt the client if it is blocked waiting on I/O.\n     */\n    @Override\n    public void wakeup() {\n        this.selector.wakeup();\n    }\n\n    @Override\n    public void initiateClose() {\n        if (state.compareAndSet(State.ACTIVE, State.CLOSING)) {\n            wakeup();\n        }\n    }\n\n    @Override\n    public boolean active() {\n        return state.get() == State.ACTIVE;\n    }\n\n    private void ensureActive() {\n        if (!active())\n            throw new DisconnectException(\"NetworkClient is no longer active, state is \" + state);\n    }\n\n    /**\n     * Close the network client\n     */\n    @Override\n    public void close() {\n        state.compareAndSet(State.ACTIVE, State.CLOSING);\n        if (state.compareAndSet(State.CLOSING, State.CLOSED)) {\n            this.selector.close();\n            this.metadataUpdater.close();\n            if (telemetrySender != null)\n                telemetrySender.close();\n        } else {\n            log.warn(\"Attempting to close NetworkClient that has already been closed.\");\n        }\n    }\n\n    /**\n     * Choose the node with the fewest outstanding requests which is at least eligible for connection. This method will\n     * prefer a node with an existing connection, but will potentially choose a node for which we don't yet have a\n     * connection if all existing connections are in use. If no connection exists, this method will prefer a node\n     * with least recent connection attempts. This method will never choose a node for which there is no\n     * existing connection and from which we have disconnected within the reconnect backoff period, or an active\n     * connection which is being throttled.\n     *\n     * @return The node with the fewest in-flight requests.\n     */\n    @Override\n    public LeastLoadedNode leastLoadedNode(long now) {\n        List<Node> nodes = this.metadataUpdater.fetchNodes();\n        if (nodes.isEmpty())\n            throw new IllegalStateException(\"There are no nodes in the Kafka cluster\");\n        int inflight = Integer.MAX_VALUE;\n\n        Node foundConnecting = null;\n        Node foundCanConnect = null;\n        Node foundReady = null;\n\n        boolean atLeastOneConnectionReady = false;\n\n        int offset = this.randOffset.nextInt(nodes.size());\n        for (int i = 0; i < nodes.size(); i++) {\n            int idx = (offset + i) % nodes.size();\n            Node node = nodes.get(idx);\n\n            if (!atLeastOneConnectionReady\n                    && connectionStates.isReady(node.idString(), now)\n                    && selector.isChannelReady(node.idString())) {\n                atLeastOneConnectionReady = true;\n            }\n\n            if (canSendRequest(node.idString(), now)) {\n                int currInflight = this.inFlightRequests.count(node.idString());\n                if (currInflight == 0) {\n                    // if we find an established connection with no in-flight requests we can stop right away\n                    log.trace(\"Found least loaded node {} connected with no in-flight requests\", node);\n                    return new LeastLoadedNode(node, true);\n                } else if (currInflight < inflight) {\n                    // otherwise if this is the best we have found so far, record that\n                    inflight = currInflight;\n                    foundReady = node;\n                }\n            } else if (connectionStates.isPreparingConnection(node.idString())) {\n                foundConnecting = node;\n            } else if (canConnect(node, now)) {\n                if (foundCanConnect == null ||\n                        this.connectionStates.lastConnectAttemptMs(foundCanConnect.idString()) >\n                                this.connectionStates.lastConnectAttemptMs(node.idString())) {\n                    foundCanConnect = node;\n                }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L651-L800",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 651,
  "end_line": 800,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}