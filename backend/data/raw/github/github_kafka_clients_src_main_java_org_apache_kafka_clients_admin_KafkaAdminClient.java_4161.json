{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_4161",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "        if ((resource.type() == ConfigResource.Type.BROKER && !resource.isDefault())\n            || resource.type() == ConfigResource.Type.BROKER_LOGGER) {\n            return Integer.valueOf(resource.name());\n        } else {\n            return null;\n        }\n    }\n\n    private KafkaFutureImpl<List<MemberIdentity>> getMembersFromGroup(String groupId, String reason) {\n        KafkaFutureImpl<List<MemberIdentity>> future = new KafkaFutureImpl<>();\n\n        describeConsumerGroups(Collections.singleton(groupId)).describedGroups().get(groupId).whenComplete((res, ex) -> {\n            if (ex != null) {\n                future.completeExceptionally(new KafkaException(\"Encounter exception when trying to get members from group: \" + groupId, ex));\n            } else {\n                List<MemberIdentity> membersToRemove = res.members().stream().map(member ->\n                    member.groupInstanceId().map(id -> new MemberIdentity().setGroupInstanceId(id))\n                        .orElseGet(() -> new MemberIdentity().setMemberId(member.consumerId()))\n                        .setReason(reason)\n                ).collect(Collectors.toList());\n\n                future.complete(membersToRemove);\n            }\n        });\n\n        return future;\n    }\n\n    @Override\n    public void registerMetricForSubscription(KafkaMetric metric) {\n        if (clientTelemetryReporter.isPresent()) {\n            ClientTelemetryReporter reporter = clientTelemetryReporter.get();\n            reporter.metricChange(metric);\n        }\n    }\n\n    @Override\n    public void unregisterMetricFromSubscription(KafkaMetric metric) {\n        if (clientTelemetryReporter.isPresent()) {\n            ClientTelemetryReporter reporter = clientTelemetryReporter.get();\n            reporter.metricRemoval(metric);\n        }\n    }\n\n    @Override\n    public RemoveMembersFromConsumerGroupResult removeMembersFromConsumerGroup(String groupId,\n                                                                               RemoveMembersFromConsumerGroupOptions options) {\n        String reason = options.reason() == null || options.reason().isEmpty() ?\n            DEFAULT_LEAVE_GROUP_REASON : JoinGroupRequest.maybeTruncateReason(options.reason());\n\n        final SimpleAdminApiFuture<CoordinatorKey, Map<MemberIdentity, Errors>> adminFuture =\n            RemoveMembersFromConsumerGroupHandler.newFuture(groupId);\n\n        KafkaFutureImpl<List<MemberIdentity>> memFuture;\n        if (options.removeAll()) {\n            memFuture = getMembersFromGroup(groupId, reason);\n        } else {\n            memFuture = new KafkaFutureImpl<>();\n            memFuture.complete(options.members().stream()\n                .map(m -> m.toMemberIdentity().setReason(reason))\n                .collect(Collectors.toList()));\n        }\n\n        memFuture.whenComplete((members, ex) -> {\n            if (ex != null) {\n                adminFuture.completeExceptionally(Collections.singletonMap(CoordinatorKey.byGroupId(groupId), ex));\n            } else {\n                RemoveMembersFromConsumerGroupHandler handler = new RemoveMembersFromConsumerGroupHandler(groupId, members, logContext);\n                invokeDriver(handler, adminFuture, options.timeoutMs());\n            }\n        });\n\n        return new RemoveMembersFromConsumerGroupResult(adminFuture.get(CoordinatorKey.byGroupId(groupId)), options.members());\n    }\n\n    @Override\n    public AlterConsumerGroupOffsetsResult alterConsumerGroupOffsets(\n        String groupId,\n        Map<TopicPartition, OffsetAndMetadata> offsets,\n        AlterConsumerGroupOffsetsOptions options\n    ) {\n        SimpleAdminApiFuture<CoordinatorKey, Map<TopicPartition, Errors>> future =\n            AlterConsumerGroupOffsetsHandler.newFuture(groupId);\n        AlterConsumerGroupOffsetsHandler handler = new AlterConsumerGroupOffsetsHandler(groupId, offsets, logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new AlterConsumerGroupOffsetsResult(future.get(CoordinatorKey.byGroupId(groupId)));\n    }\n\n    @Override\n    public AlterStreamsGroupOffsetsResult alterStreamsGroupOffsets(\n        String groupId,\n        Map<TopicPartition, OffsetAndMetadata> offsets,\n        AlterStreamsGroupOffsetsOptions options\n    ) {\n        AlterConsumerGroupOffsetsOptions consumerGroupOptions = new AlterConsumerGroupOffsetsOptions()\n            .timeoutMs(options.timeoutMs());\n        return new AlterStreamsGroupOffsetsResult(alterConsumerGroupOffsets(groupId, offsets, consumerGroupOptions));\n    }\n\n    @Override\n    public ListOffsetsResult listOffsets(Map<TopicPartition, OffsetSpec> topicPartitionOffsets,\n                                         ListOffsetsOptions options) {\n        PartitionLeaderStrategy.PartitionLeaderFuture<ListOffsetsResultInfo> future =\n            ListOffsetsHandler.newFuture(topicPartitionOffsets.keySet(), partitionLeaderCache);\n        Map<TopicPartition, Long> offsetQueriesByPartition = topicPartitionOffsets.entrySet().stream()\n            .collect(Collectors.toMap(Map.Entry::getKey, e -> getOffsetFromSpec(e.getValue())));\n        ListOffsetsHandler handler = new ListOffsetsHandler(offsetQueriesByPartition, options, logContext, defaultApiTimeoutMs);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new ListOffsetsResult(future.all());\n    }\n\n    @Override\n    public DescribeClientQuotasResult describeClientQuotas(ClientQuotaFilter filter, DescribeClientQuotasOptions options) {\n        KafkaFutureImpl<Map<ClientQuotaEntity, Map<String, Double>>> future = new KafkaFutureImpl<>();\n\n        final long now = time.milliseconds();\n        runnable.call(new Call(\"describeClientQuotas\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedNodeProvider()) {\n\n            @Override\n            DescribeClientQuotasRequest.Builder createRequest(int timeoutMs) {\n                return new DescribeClientQuotasRequest.Builder(filter);\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                DescribeClientQuotasResponse response = (DescribeClientQuotasResponse) abstractResponse;\n                response.complete(future);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new DescribeClientQuotasResult(future);\n    }\n\n    @Override\n    public AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlteration> entries, AlterClientQuotasOptions options) {\n        Map<ClientQuotaEntity, KafkaFutureImpl<Void>> futures = new HashMap<>(entries.size());\n        for (ClientQuotaAlteration entry : entries) {\n            futures.put(entry.entity(), new KafkaFutureImpl<>());\n        }\n\n        final long now = time.milliseconds();\n        runnable.call(new Call(\"alterClientQuotas\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedNodeProvider()) {\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L4161-L4310",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 4161,
  "end_line": 4310,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}