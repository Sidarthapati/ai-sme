{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_1041",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "                    }\n                }\n                nodesNeedingApiVersionsFetch.put(node, new ApiVersionsRequest.Builder(maxApiVersion));\n            }\n            return;\n        }\n        NodeApiVersions nodeVersionInfo = new NodeApiVersions(\n            apiVersionsResponse.data().apiKeys(),\n            apiVersionsResponse.data().supportedFeatures(),\n            apiVersionsResponse.data().finalizedFeatures(),\n            apiVersionsResponse.data().finalizedFeaturesEpoch());\n        apiVersions.update(node, nodeVersionInfo);\n        this.connectionStates.ready(node);\n        log.debug(\"Node {} has finalized features epoch: {}, finalized features: {}, supported features: {}, API versions: {}.\",\n                node, apiVersionsResponse.data().finalizedFeaturesEpoch(), apiVersionsResponse.data().finalizedFeatures(),\n                apiVersionsResponse.data().supportedFeatures(), nodeVersionInfo);\n    }\n\n    /**\n     * Handle any disconnected connections\n     *\n     * @param responses The list of responses that completed with the disconnection\n     * @param now The current time\n     */\n    private void handleDisconnections(List<ClientResponse> responses, long now) {\n        for (Map.Entry<String, ChannelState> entry : this.selector.disconnected().entrySet()) {\n            String node = entry.getKey();\n            ChannelState channelState = entry.getValue();\n            if (channelState == ChannelState.EXPIRED) {\n                log.debug(\"Idle connection to node {} disconnected.\", node);\n            } else {\n                log.info(\"Node {} disconnected.\", node);\n            }\n            processDisconnection(responses, node, now, channelState);\n        }\n    }\n\n    /**\n     * Record any newly completed connections\n     */\n    private void handleConnections() {\n        for (String node : this.selector.connected()) {\n            // We are now connected.  Note that we might not still be able to send requests. For instance,\n            // if SSL is enabled, the SSL handshake happens after the connection is established.\n            // Therefore, it is still necessary to check isChannelReady before attempting to send on this\n            // connection.\n            if (discoverBrokerVersions) {\n                nodesNeedingApiVersionsFetch.put(node, new ApiVersionsRequest.Builder());\n                log.debug(\"Completed connection to node {}. Fetching API versions.\", node);\n            } else {\n                this.connectionStates.ready(node);\n                log.debug(\"Completed connection to node {}. Ready.\", node);\n            }\n        }\n    }\n\n    private void handleInitiateApiVersionRequests(long now) {\n        Iterator<Map.Entry<String, ApiVersionsRequest.Builder>> iter = nodesNeedingApiVersionsFetch.entrySet().iterator();\n        while (iter.hasNext()) {\n            Map.Entry<String, ApiVersionsRequest.Builder> entry = iter.next();\n            String node = entry.getKey();\n            if (selector.isChannelReady(node) && inFlightRequests.canSendMore(node)) {\n                log.debug(\"Initiating API versions fetch from node {}.\", node);\n                // We transition the connection to the CHECKING_API_VERSIONS state only when\n                // the ApiVersionsRequest is queued up to be sent out. Without this, the client\n                // could remain in the CHECKING_API_VERSIONS state forever if the channel does\n                // not before ready.\n                this.connectionStates.checkingApiVersions(node);\n                ApiVersionsRequest.Builder apiVersionRequestBuilder = entry.getValue();\n                ClientRequest clientRequest = newClientRequest(node, apiVersionRequestBuilder, now, true);\n                doSend(clientRequest, true, now);\n                iter.remove();\n            }\n        }\n    }\n\n    private void handleRebootstrap(List<ClientResponse> responses, long now) {\n        if (metadataRecoveryStrategy == MetadataRecoveryStrategy.REBOOTSTRAP && metadataUpdater.needsRebootstrap(now, rebootstrapTriggerMs)) {\n            this.metadataUpdater.fetchNodes().forEach(node -> {\n                String nodeId = node.idString();\n                this.selector.close(nodeId);\n                if (connectionStates.isConnecting(nodeId) || connectionStates.isConnected(nodeId)) {\n                    log.info(\"Disconnecting from node {} due to client rebootstrap.\", nodeId);\n                    processDisconnection(responses, nodeId, now, ChannelState.LOCAL_CLOSE);\n                }\n            });\n            metadataUpdater.rebootstrap(now);\n        }\n    }\n\n    /**\n     * Initiate a connection to the given node\n     * @param node the node to connect to\n     * @param now current time in epoch milliseconds\n     */\n    private void initiateConnect(Node node, long now) {\n        String nodeConnectionId = node.idString();\n        try {\n            connectionStates.connecting(nodeConnectionId, now, node.host());\n            InetAddress address = connectionStates.currentAddress(nodeConnectionId);\n            log.debug(\"Initiating connection to node {} using address {}\", node, address);\n            selector.connect(nodeConnectionId,\n                    new InetSocketAddress(address, node.port()),\n                    this.socketSendBuffer,\n                    this.socketReceiveBuffer);\n        } catch (IOException e) {\n            log.warn(\"Error connecting to node {}\", node, e);\n            // Attempt failed, we'll try again after the backoff\n            connectionStates.disconnected(nodeConnectionId, now);\n            // Notify metadata updater of the connection failure\n            metadataUpdater.handleServerDisconnect(now, nodeConnectionId, Optional.empty());\n        }\n    }\n\n    /**\n     * Return true if there's at least one connection establishment is currently underway\n     */\n    private boolean isAnyNodeConnecting() {\n        for (Node node : metadataUpdater.fetchNodes()) {\n            if (connectionStates.isConnecting(node.idString())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Return true if the ApiKey belongs to the Telemetry API.\n     */\n    private boolean isTelemetryApi(ApiKeys apiKey) {\n        return apiKey == ApiKeys.GET_TELEMETRY_SUBSCRIPTIONS || apiKey == ApiKeys.PUSH_TELEMETRY;\n    }\n\n    class DefaultMetadataUpdater implements MetadataUpdater {\n\n        /* the current cluster metadata */\n        private final Metadata metadata;\n\n        // Defined if there is a request in progress, null otherwise\n        private InProgressData inProgress;\n\n        /*\n         * The time in wall-clock milliseconds when we started attempts to fetch metadata. If empty,\n         * metadata has not been requested. This is the start time based on which rebootstrap is\n         * triggered if metadata is not obtained for the configured rebootstrap trigger interval.\n         * Set to Optional.of(0L) to force rebootstrap immediately.\n         */\n        private Optional<Long> metadataAttemptStartMs = Optional.empty();\n\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L1041-L1190",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1041,
  "end_line": 1190,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}