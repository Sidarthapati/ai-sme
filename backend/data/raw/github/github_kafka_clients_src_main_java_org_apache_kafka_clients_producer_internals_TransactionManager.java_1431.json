{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1431",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "                if (response.wasDisconnected()) {\n                    log.debug(\"Disconnected from {}. Will retry.\", response.destination());\n                    if (this.needsCoordinator())\n                        lookupCoordinator(this.coordinatorType(), this.coordinatorKey());\n                    reenqueue();\n                } else if (response.versionMismatch() != null) {\n                    fatalError(response.versionMismatch());\n                } else if (response.hasResponse()) {\n                    log.trace(\"Received transactional response {} for request {}\", response.responseBody(),\n                            requestBuilder());\n                    synchronized (TransactionManager.this) {\n                        handleResponse(response.responseBody());\n                    }\n                } else {\n                    fatalError(new KafkaException(\"Could not execute transactional request for unknown reasons\"));\n                }\n            }\n        }\n\n        boolean needsCoordinator() {\n            return coordinatorType() != null;\n        }\n\n        FindCoordinatorRequest.CoordinatorType coordinatorType() {\n            return FindCoordinatorRequest.CoordinatorType.TRANSACTION;\n        }\n\n        String coordinatorKey() {\n            return transactionalId;\n        }\n\n        void setRetry() {\n            this.isRetry = true;\n        }\n\n        boolean isRetry() {\n            return isRetry;\n        }\n\n        boolean isEndTxn() {\n            return false;\n        }\n\n        abstract AbstractRequest.Builder<?> requestBuilder();\n\n        abstract void handleResponse(AbstractResponse responseBody);\n\n        abstract Priority priority();\n    }\n\n    private class InitProducerIdHandler extends TxnRequestHandler {\n        private final InitProducerIdRequest.Builder builder;\n        private final boolean isEpochBump;\n\n        private InitProducerIdHandler(InitProducerIdRequest.Builder builder, boolean isEpochBump) {\n            super(\"InitProducerId\");\n            this.builder = builder;\n            this.isEpochBump = isEpochBump;\n        }\n\n        @Override\n        InitProducerIdRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return this.isEpochBump ? Priority.EPOCH_BUMP : Priority.INIT_PRODUCER_ID;\n        }\n\n        @Override\n        FindCoordinatorRequest.CoordinatorType coordinatorType() {\n            if (isTransactional()) {\n                return FindCoordinatorRequest.CoordinatorType.TRANSACTION;\n            } else {\n                return null;\n            }\n        }\n\n        @Override\n        public void handleResponse(AbstractResponse response) {\n            InitProducerIdResponse initProducerIdResponse = (InitProducerIdResponse) response;\n            Errors error = initProducerIdResponse.error();\n\n            if (error == Errors.NONE) {\n                ProducerIdAndEpoch producerIdAndEpoch = new ProducerIdAndEpoch(initProducerIdResponse.data().producerId(),\n                        initProducerIdResponse.data().producerEpoch());\n                setProducerIdAndEpoch(producerIdAndEpoch);\n                // If this is a transaction with keepPreparedTxn=true, transition directly\n                // to PREPARED_TRANSACTION state IFF there is an ongoing transaction.\n                if (builder.data.keepPreparedTxn() &&\n                    initProducerIdResponse.data().ongoingTxnProducerId() != RecordBatch.NO_PRODUCER_ID\n                ) {\n                    transitionTo(State.PREPARED_TRANSACTION);\n                    // Update the preparedTxnState with the ongoing pid and epoch from the response.\n                    // This will be used to complete the transaction later.\n                    TransactionManager.this.preparedTxnState = new ProducerIdAndEpoch(\n                        initProducerIdResponse.data().ongoingTxnProducerId(),\n                        initProducerIdResponse.data().ongoingTxnProducerEpoch()\n                    );\n                } else {\n                    transitionTo(State.READY);\n                }\n                lastError = null;\n                if (this.isEpochBump) {\n                    resetSequenceNumbers();\n                }\n                result.done();\n            } else if (error == Errors.NOT_COORDINATOR || error == Errors.COORDINATOR_NOT_AVAILABLE) {\n                lookupCoordinator(FindCoordinatorRequest.CoordinatorType.TRANSACTION, transactionalId);\n                reenqueue();\n            } else if (error.exception() instanceof RetriableException) {\n                reenqueue();\n            } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED ||\n                    error == Errors.CLUSTER_AUTHORIZATION_FAILED) {\n                log.info(\"Abortable authorization error: {}.  Transition the producer state to {}\", error.message(), State.ABORTABLE_ERROR);\n                lastError = error.exception();\n                abortableError(error.exception());\n            } else if (error == Errors.INVALID_PRODUCER_EPOCH || error == Errors.PRODUCER_FENCED) {\n                // We could still receive INVALID_PRODUCER_EPOCH from old versioned transaction coordinator,\n                // just treat it the same as PRODUCE_FENCED.\n                fatalError(Errors.PRODUCER_FENCED.exception());\n            } else if (error == Errors.TRANSACTION_ABORTABLE) {\n                abortableError(error.exception());\n            } else {\n                fatalError(new KafkaException(\"Unexpected error in InitProducerIdResponse; \" + error.message()));\n            }\n        }\n    }\n\n    private class AddPartitionsToTxnHandler extends TxnRequestHandler {\n        private final AddPartitionsToTxnRequest.Builder builder;\n        private long retryBackoffMs;\n\n        private AddPartitionsToTxnHandler(AddPartitionsToTxnRequest.Builder builder) {\n            super(\"AddPartitionsToTxn\");\n            this.builder = builder;\n            this.retryBackoffMs = TransactionManager.this.retryBackoffMs;\n        }\n\n        @Override\n        AddPartitionsToTxnRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return Priority.ADD_PARTITIONS_OR_OFFSETS;\n        }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1431-L1580",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1431,
  "end_line": 1580,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}