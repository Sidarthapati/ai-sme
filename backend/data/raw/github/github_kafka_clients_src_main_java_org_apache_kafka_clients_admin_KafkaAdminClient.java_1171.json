{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1171",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "            }\n            calls.clear();\n        }\n\n        /**\n         * Choose nodes for the calls in the pendingCalls list.\n         *\n         * @param now The current time in milliseconds.\n         * @return The minimum time until a call is ready to be retried if any of the pending\n         * calls are backing off after a failure\n         */\n        private long maybeDrainPendingCalls(long now) {\n            long pollTimeout = Long.MAX_VALUE;\n            log.trace(\"Trying to choose nodes for {} at {}\", pendingCalls, now);\n\n            List<Call> toRemove = new ArrayList<>();\n            // Using pendingCalls.size() to get the list size before the for-loop to avoid infinite loop.\n            // If call.fail keeps adding the call to pendingCalls,\n            // the loop like for (int i = 0; i < pendingCalls.size(); i++) can't stop.\n            int pendingSize = pendingCalls.size();\n            // pendingCalls could be modified in this loop,\n            // hence using for-loop instead of iterator to avoid ConcurrentModificationException.\n            for (int i = 0; i < pendingSize; i++) {\n                Call call = pendingCalls.get(i);\n                // If the call is being retried, await the proper backoff before finding the node\n                if (now < call.nextAllowedTryMs) {\n                    pollTimeout = Math.min(pollTimeout, call.nextAllowedTryMs - now);\n                } else if (maybeDrainPendingCall(call, now)) {\n                    toRemove.add(call);\n                }\n            }\n\n            // Use remove instead of removeAll to avoid delete all matched elements\n            for (Call call : toRemove) {\n                pendingCalls.remove(call);\n            }\n            return pollTimeout;\n        }\n\n        /**\n         * Check whether a pending call can be assigned a node. Return true if the pending call was either\n         * transferred to the callsToSend collection or if the call was failed. Return false if it\n         * should remain pending.\n         */\n        private boolean maybeDrainPendingCall(Call call, long now) {\n            try {\n                Node node = call.nodeProvider.provide();\n                if (node != null) {\n                    log.trace(\"Assigned {} to node {}\", call, node);\n                    call.curNode = node;\n                    getOrCreateListValue(callsToSend, node).add(call);\n                    return true;\n                } else {\n                    log.trace(\"Unable to assign {} to a node.\", call);\n                    return false;\n                }\n            } catch (Throwable t) {\n                // Handle authentication errors while choosing nodes.\n                log.debug(\"Unable to choose node for {}\", call, t);\n                call.fail(now, t);\n                return true;\n            }\n        }\n\n        /**\n         * Send the calls which are ready.\n         *\n         * @param now The current time in milliseconds.\n         * @return The minimum timeout we need for poll().\n         */\n        private long sendEligibleCalls(long now) {\n            long pollTimeout = Long.MAX_VALUE;\n            for (Iterator<Map.Entry<Node, List<Call>>> iter = callsToSend.entrySet().iterator(); iter.hasNext(); ) {\n                Map.Entry<Node, List<Call>> entry = iter.next();\n                List<Call> calls = entry.getValue();\n                if (calls.isEmpty()) {\n                    iter.remove();\n                    continue;\n                }\n                Node node = entry.getKey();\n                if (callsInFlight.containsKey(node.idString())) {\n                    log.trace(\"Still waiting for other calls to finish on node {}.\", node);\n                    nodeReadyDeadlines.remove(node);\n                    continue;\n                }\n                if (!client.ready(node, now)) {\n                    Long deadline = nodeReadyDeadlines.get(node);\n                    if (deadline != null) {\n                        if (now >= deadline) {\n                            log.info(\"Disconnecting from {} and revoking {} node assignment(s) \" +\n                                    \"because the node is taking too long to become ready.\",\n                                node.idString(), calls.size());\n                            transitionToPendingAndClearList(calls);\n                            client.disconnect(node.idString());\n                            nodeReadyDeadlines.remove(node);\n                            iter.remove();\n                            continue;\n                        }\n                        pollTimeout = Math.min(pollTimeout, deadline - now);\n                    } else {\n                        nodeReadyDeadlines.put(node, now + requestTimeoutMs);\n                    }\n                    long nodeTimeout = client.pollDelayMs(node, now);\n                    pollTimeout = Math.min(pollTimeout, nodeTimeout);\n                    log.trace(\"Client is not ready to send to {}. Must delay {} ms\", node, nodeTimeout);\n                    continue;\n                }\n                // Subtract the time we spent waiting for the node to become ready from\n                // the total request time.\n                int remainingRequestTime;\n                Long deadlineMs = nodeReadyDeadlines.remove(node);\n                if (deadlineMs == null) {\n                    remainingRequestTime = requestTimeoutMs;\n                } else {\n                    remainingRequestTime = calcTimeoutMsRemainingAsInt(now, deadlineMs);\n                }\n                while (!calls.isEmpty()) {\n                    Call call = calls.remove(0);\n                    int timeoutMs = Math.min(remainingRequestTime,\n                        calcTimeoutMsRemainingAsInt(now, call.deadlineMs));\n                    AbstractRequest.Builder<?> requestBuilder;\n                    try {\n                        requestBuilder = call.createRequest(timeoutMs);\n                    } catch (Throwable t) {\n                        call.fail(now, new KafkaException(String.format(\n                            \"Internal error sending %s to %s.\", call.callName, node), t));\n                        continue;\n                    }\n                    ClientRequest clientRequest = client.newClientRequest(node.idString(),\n                        requestBuilder, now, true, timeoutMs, null);\n                    log.debug(\"Sending {} to {}. correlationId={}, timeoutMs={}\",\n                        requestBuilder, node, clientRequest.correlationId(), timeoutMs);\n                    client.send(clientRequest, now);\n                    callsInFlight.put(node.idString(), call);\n                    correlationIdToCalls.put(clientRequest.correlationId(), call);\n                    break;\n                }\n            }\n            return pollTimeout;\n        }\n\n        /**\n         * Time out expired calls that are in flight.\n         * <p>\n         * Calls that are in flight may have been partially or completely sent over the wire. They may\n         * even be in the process of being processed by the remote server. At the moment, our only option\n         * to time them out is to close the entire connection.\n         *\n         * @param processor The timeout processor.\n         */",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1171-L1320",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1171,
  "end_line": 1320,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}