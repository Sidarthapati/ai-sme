{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_391",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "        log.info(\"Client requested disconnect from node {}\", nodeId);\n        selector.close(nodeId);\n        long now = time.milliseconds();\n        cancelInFlightRequests(nodeId, now, abortedSends, false);\n        connectionStates.disconnected(nodeId, now);\n    }\n\n    private void cancelInFlightRequests(String nodeId,\n                                        long now,\n                                        Collection<ClientResponse> responses,\n                                        boolean timedOut) {\n        Iterable<InFlightRequest> inFlightRequests = this.inFlightRequests.clearAll(nodeId);\n        for (InFlightRequest request : inFlightRequests) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Cancelled in-flight {} request with correlation id {} due to node {} being disconnected \" +\n                        \"(elapsed time since creation: {}ms, elapsed time since send: {}ms, throttle time: {}ms, request timeout: {}ms): {}\",\n                    request.header.apiKey(), request.header.correlationId(), nodeId,\n                    request.timeElapsedSinceCreateMs(now), request.timeElapsedSinceSendMs(now),\n                    request.throttleTimeMs(), request.requestTimeoutMs, request.request);\n            } else {\n                log.info(\"Cancelled in-flight {} request with correlation id {} due to node {} being disconnected \" +\n                        \"(elapsed time since creation: {}ms, elapsed time since send: {}ms, throttle time: {}ms, request timeout: {}ms)\",\n                    request.header.apiKey(), request.header.correlationId(), nodeId,\n                    request.timeElapsedSinceCreateMs(now), request.timeElapsedSinceSendMs(now),\n                    request.throttleTimeMs(), request.requestTimeoutMs);\n            }\n\n            if (!request.isInternalRequest) {\n                if (responses != null) {\n                    ClientResponse clientResponse;\n\n                    if (timedOut)\n                        clientResponse = request.timedOut(now);\n                    else\n                        clientResponse = request.disconnected(now);\n\n                    responses.add(clientResponse);\n                }\n            } else if (request.header.apiKey() == ApiKeys.METADATA) {\n                metadataUpdater.handleFailedRequest(now, Optional.empty());\n            } else if (isTelemetryApi(request.header.apiKey()) && telemetrySender != null) {\n                telemetrySender.handleFailedRequest(request.header.apiKey(), null);\n            }\n        }\n    }\n\n    /**\n     * Closes the connection to a particular node (if there is one).\n     * All requests on the connection will be cleared.  ClientRequest callbacks will not be invoked\n     * for the cleared requests, nor will they be returned from poll().\n     *\n     * @param nodeId The id of the node\n     */\n    @Override\n    public void close(String nodeId) {\n        log.info(\"Client requested connection close from node {}\", nodeId);\n        selector.close(nodeId);\n        long now = time.milliseconds();\n        cancelInFlightRequests(nodeId, now, null, false);\n        connectionStates.remove(nodeId);\n        apiVersions.remove(nodeId);\n        nodesNeedingApiVersionsFetch.remove(nodeId);\n    }\n\n    /**\n     * Returns the number of milliseconds to wait, based on the connection state, before attempting to send data. When\n     * disconnected, this respects the reconnect backoff time. When connecting or connected, this handles slow/stalled\n     * connections.\n     *\n     * @param node The node to check\n     * @param now The current timestamp\n     * @return The number of milliseconds to wait.\n     */\n    @Override\n    public long connectionDelay(Node node, long now) {\n        return connectionStates.connectionDelay(node.idString(), now);\n    }\n\n    // Return the remaining throttling delay in milliseconds if throttling is in progress. Return 0, otherwise.\n    // This is for testing.\n    public long throttleDelayMs(Node node, long now) {\n        return connectionStates.throttleDelayMs(node.idString(), now);\n    }\n\n    /**\n     * Return the poll delay in milliseconds based on both connection and throttle delay.\n     * @param node the connection to check\n     * @param now the current time in ms\n     */\n    @Override\n    public long pollDelayMs(Node node, long now) {\n        return connectionStates.pollDelayMs(node.idString(), now);\n    }\n\n    /**\n     * Check if the connection of the node has failed, based on the connection state. Such connection failure are\n     * usually transient and can be resumed in the next {@link #ready(org.apache.kafka.common.Node, long)} }\n     * call, but there are cases where transient failures needs to be caught and re-acted upon.\n     *\n     * @param node the node to check\n     * @return true iff the connection has failed and the node is disconnected\n     */\n    @Override\n    public boolean connectionFailed(Node node) {\n        return connectionStates.isDisconnected(node.idString());\n    }\n\n    /**\n     * Check if authentication to this node has failed, based on the connection state. Authentication failures are\n     * propagated without any retries.\n     *\n     * @param node the node to check\n     * @return an AuthenticationException iff authentication has failed, null otherwise\n     */\n    @Override\n    public AuthenticationException authenticationException(Node node) {\n        return connectionStates.authenticationException(node.idString());\n    }\n\n    /**\n     * Check if the node with the given id is ready to send more requests.\n     *\n     * @param node The node\n     * @param now The current time in ms\n     * @return true if the node is ready\n     */\n    @Override\n    public boolean isReady(Node node, long now) {\n        // if we need to update our metadata now declare all requests unready to make metadata requests first\n        // priority\n        return !metadataUpdater.isUpdateDue(now) && canSendRequest(node.idString(), now);\n    }\n\n    /**\n     * Are we connected and ready and able to send more requests to the given connection?\n     *\n     * @param node The node\n     * @param now the current timestamp\n     */\n    private boolean canSendRequest(String node, long now) {\n        return connectionStates.isReady(node, now) && selector.isChannelReady(node) &&\n            inFlightRequests.canSendMore(node);\n    }\n\n    /**\n     * Queue up the given request for sending. Requests can only be sent out to ready nodes.\n     * @param request The request\n     * @param now The current timestamp\n     */\n    @Override",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L391-L540",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 391,
  "end_line": 540,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}