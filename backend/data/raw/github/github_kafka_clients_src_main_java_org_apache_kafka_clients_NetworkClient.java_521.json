{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_521",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "        return !metadataUpdater.isUpdateDue(now) && canSendRequest(node.idString(), now);\n    }\n\n    /**\n     * Are we connected and ready and able to send more requests to the given connection?\n     *\n     * @param node The node\n     * @param now the current timestamp\n     */\n    private boolean canSendRequest(String node, long now) {\n        return connectionStates.isReady(node, now) && selector.isChannelReady(node) &&\n            inFlightRequests.canSendMore(node);\n    }\n\n    /**\n     * Queue up the given request for sending. Requests can only be sent out to ready nodes.\n     * @param request The request\n     * @param now The current timestamp\n     */\n    @Override\n    public void send(ClientRequest request, long now) {\n        doSend(request, false, now);\n    }\n\n    // package-private for testing\n    void sendInternalMetadataRequest(MetadataRequest.Builder builder, String nodeConnectionId, long now) {\n        ClientRequest clientRequest = newClientRequest(nodeConnectionId, builder, now, true);\n        doSend(clientRequest, true, now);\n    }\n\n    private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long now) {\n        ensureActive();\n        String nodeId = clientRequest.destination();\n        if (!isInternalRequest) {\n            // If this request came from outside the NetworkClient, validate\n            // that we can send data.  If the request is internal, we trust\n            // that internal code has done this validation.  Validation\n            // will be slightly different for some internal requests (for\n            // example, ApiVersionsRequests can be sent prior to being in\n            // READY state.)\n            if (!canSendRequest(nodeId, now))\n                throw new IllegalStateException(\"Attempt to send a request to node \" + nodeId + \" which is not ready.\");\n        }\n        AbstractRequest.Builder<?> builder = clientRequest.requestBuilder();\n        try {\n            NodeApiVersions versionInfo = apiVersions.get(nodeId);\n            short version;\n            // Note: if versionInfo is null, we have no server version information. This would be\n            // the case when sending the initial ApiVersionRequest which fetches the version\n            // information itself.  It is also the case when discoverBrokerVersions is set to false.\n            if (versionInfo == null) {\n                version = builder.latestAllowedVersion();\n                if (discoverBrokerVersions && log.isTraceEnabled())\n                    log.trace(\"No version information found when sending {} with correlation id {} to node {}. \" +\n                            \"Assuming version {}.\", clientRequest.apiKey(), clientRequest.correlationId(), nodeId, version);\n            } else {\n                version = versionInfo.latestUsableVersion(clientRequest.apiKey(), builder.oldestAllowedVersion(),\n                        builder.latestAllowedVersion());\n            }\n            // The call to build may also throw UnsupportedVersionException, if there are essential\n            // fields that cannot be represented in the chosen version.\n            doSend(clientRequest, isInternalRequest, now, builder.build(version));\n        } catch (UnsupportedVersionException unsupportedVersionException) {\n            // If the version is not supported, skip sending the request over the wire.\n            // Instead, simply add it to the local queue of aborted requests.\n            log.debug(\"Version mismatch when attempting to send {} with correlation id {} to {}\", builder,\n                    clientRequest.correlationId(), clientRequest.destination(), unsupportedVersionException);\n            ClientResponse clientResponse = new ClientResponse(clientRequest.makeHeader(builder.latestAllowedVersion()),\n                    clientRequest.callback(), clientRequest.destination(), now, now,\n                    false, unsupportedVersionException, null, null);\n\n            if (!isInternalRequest)\n                abortedSends.add(clientResponse);\n            else if (clientRequest.apiKey() == ApiKeys.METADATA)\n                metadataUpdater.handleFailedRequest(now, Optional.of(unsupportedVersionException));\n            else if (isTelemetryApi(clientRequest.apiKey()) && telemetrySender != null)\n                telemetrySender.handleFailedRequest(clientRequest.apiKey(), unsupportedVersionException);\n        }\n    }\n\n    private void doSend(ClientRequest clientRequest, boolean isInternalRequest, long now, AbstractRequest request) {\n        String destination = clientRequest.destination();\n        RequestHeader header = clientRequest.makeHeader(request.version());\n        if (log.isDebugEnabled()) {\n            log.debug(\"Sending {} request with header {} and timeout {} to node {}: {}\",\n                clientRequest.apiKey(), header, clientRequest.requestTimeoutMs(), destination, request);\n        }\n        Send send = request.toSend(header);\n        InFlightRequest inFlightRequest = new InFlightRequest(\n                clientRequest,\n                header,\n                isInternalRequest,\n                request,\n                send,\n                now);\n        this.inFlightRequests.add(inFlightRequest);\n        selector.send(new NetworkSend(clientRequest.destination(), send));\n    }\n\n    /**\n     * Do actual reads and writes to sockets.\n     *\n     * @param timeout The maximum amount of time to wait (in ms) for responses if there are none immediately,\n     *                must be non-negative. The actual timeout will be the minimum of timeout, request timeout and\n     *                metadata timeout\n     * @param now The current time in milliseconds\n     * @return The list of responses received\n     */\n    @Override\n    public List<ClientResponse> poll(long timeout, long now) {\n        ensureActive();\n\n        if (!abortedSends.isEmpty()) {\n            // If there are aborted sends because of unsupported version exceptions or disconnects,\n            // handle them immediately without waiting for Selector#poll.\n            List<ClientResponse> responses = new ArrayList<>();\n            handleAbortedSends(responses);\n            completeResponses(responses);\n            return responses;\n        }\n\n        long metadataTimeout = metadataUpdater.maybeUpdate(now);\n        long telemetryTimeout = telemetrySender != null ? telemetrySender.maybeUpdate(now) : Integer.MAX_VALUE;\n        try {\n            this.selector.poll(Utils.min(timeout, metadataTimeout, telemetryTimeout, defaultRequestTimeoutMs));\n        } catch (IOException e) {\n            log.error(\"Unexpected error during I/O\", e);\n        }\n\n        // process completed actions\n        long updatedNow = this.time.milliseconds();\n        List<ClientResponse> responses = new ArrayList<>();\n        handleCompletedSends(responses, updatedNow);\n        handleCompletedReceives(responses, updatedNow);\n        handleDisconnections(responses, updatedNow);\n        handleConnections();\n        handleInitiateApiVersionRequests(updatedNow);\n        handleTimedOutConnections(responses, updatedNow);\n        handleTimedOutRequests(responses, updatedNow);\n        handleRebootstrap(responses, updatedNow);\n        completeResponses(responses);\n\n        return responses;\n    }\n\n    private void completeResponses(List<ClientResponse> responses) {\n        for (ClientResponse response : responses) {\n            try {\n                response.onComplete();\n            } catch (Exception e) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L521-L670",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 521,
  "end_line": 670,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}