{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1171",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "\n    private void maybeFailWithError() {\n        if (!hasError()) {\n            return;\n        }\n        // for ProducerFencedException, do not wrap it as a KafkaException\n        // but create a new instance without the call trace since it was not thrown because of the current call\n        if (lastError instanceof ProducerFencedException) {\n            throw new ProducerFencedException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" has been fenced by another producer \" +\n                    \"with the same transactionalId\");\n        }\n        if (lastError instanceof InvalidProducerEpochException) {\n            throw new InvalidProducerEpochException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" attempted to produce with an old epoch\");\n        }\n        if (lastError instanceof IllegalStateException) {\n            throw new IllegalStateException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" cannot execute transactional method because of previous invalid state transition attempt\", lastError);\n        }\n        throw new KafkaException(\"Cannot execute transactional method because we are in an error state\", lastError);\n    }\n\n    private boolean maybeTerminateRequestWithError(TxnRequestHandler requestHandler) {\n        if (hasError()) {\n            if (hasAbortableError() && requestHandler instanceof FindCoordinatorHandler)\n                // No harm letting the FindCoordinator request go through if we're expecting to abort\n                return false;\n\n            requestHandler.fail(lastError);\n            return true;\n        }\n        return false;\n    }\n\n    private void enqueueRequest(TxnRequestHandler requestHandler) {\n        log.debug(\"Enqueuing transactional request {}\", requestHandler.requestBuilder());\n        pendingRequests.add(requestHandler);\n    }\n\n    private void lookupCoordinator(FindCoordinatorRequest.CoordinatorType type, String coordinatorKey) {\n        switch (type) {\n            case GROUP:\n                consumerGroupCoordinator = null;\n                break;\n            case TRANSACTION:\n                transactionCoordinator = null;\n                break;\n            default:\n                throw new IllegalStateException(\"Invalid coordinator type: \" + type);\n        }\n\n        FindCoordinatorRequestData data = new FindCoordinatorRequestData()\n                .setKeyType(type.id())\n                .setKey(coordinatorKey);\n        FindCoordinatorRequest.Builder builder = new FindCoordinatorRequest.Builder(data);\n        enqueueRequest(new FindCoordinatorHandler(builder));\n    }\n\n    private TxnRequestHandler addPartitionsToTransactionHandler() {\n        pendingPartitionsInTransaction.addAll(newPartitionsInTransaction);\n        newPartitionsInTransaction.clear();\n        AddPartitionsToTxnRequest.Builder builder =\n            AddPartitionsToTxnRequest.Builder.forClient(transactionalId,\n                producerIdAndEpoch.producerId,\n                producerIdAndEpoch.epoch,\n                new ArrayList<>(pendingPartitionsInTransaction));\n        return new AddPartitionsToTxnHandler(builder);\n    }\n\n    private TxnOffsetCommitHandler txnOffsetCommitHandler(TransactionalRequestResult result,\n                                                          Map<TopicPartition, OffsetAndMetadata> offsets,\n                                                          ConsumerGroupMetadata groupMetadata) {\n        for (Map.Entry<TopicPartition, OffsetAndMetadata> entry : offsets.entrySet()) {\n            OffsetAndMetadata offsetAndMetadata = entry.getValue();\n            CommittedOffset committedOffset = new CommittedOffset(offsetAndMetadata.offset(),\n                    offsetAndMetadata.metadata(), offsetAndMetadata.leaderEpoch());\n            pendingTxnOffsetCommits.put(entry.getKey(), committedOffset);\n        }\n\n        final TxnOffsetCommitRequest.Builder builder =\n            new TxnOffsetCommitRequest.Builder(transactionalId,\n                groupMetadata.groupId(),\n                producerIdAndEpoch.producerId,\n                producerIdAndEpoch.epoch,\n                pendingTxnOffsetCommits,\n                groupMetadata.memberId(),\n                groupMetadata.generationId(),\n                groupMetadata.groupInstanceId(),\n                isTransactionV2Enabled()\n            );\n        if (result == null) {\n            // In this case, transaction V2 is in use.\n            return new TxnOffsetCommitHandler(builder);\n        }\n        return new TxnOffsetCommitHandler(result, builder);\n    }\n\n    private void throwIfPendingState(TransactionOperation operation) {\n        if (pendingTransition != null) {\n            if (pendingTransition.result.isAcked()) {\n                pendingTransition = null;\n            } else {\n                throw new IllegalStateException(\"Cannot attempt operation `\" + operation + \"` \"\n                    + \"because the previous call to `\" + pendingTransition.operation + \"` \"\n                    + \"timed out and must be retried\");\n            }\n        }\n    }\n\n    private TransactionalRequestResult handleCachedTransactionRequestResult(\n        Supplier<TransactionalRequestResult> transactionalRequestResultSupplier,\n        State nextState,\n        String operation\n    ) {\n        ensureTransactional();\n\n        if (pendingTransition != null) {\n            if (pendingTransition.result.isAcked()) {\n                pendingTransition = null;\n            } else if (nextState != pendingTransition.state) {\n                throw new IllegalStateException(\"Cannot attempt operation `\" + operation + \"` \"\n                    + \"because the previous call to `\" + pendingTransition.operation + \"` \"\n                    + \"timed out and must be retried\");\n            } else {\n                return pendingTransition.result;\n            }\n        }\n\n        TransactionalRequestResult result = transactionalRequestResultSupplier.get();\n        pendingTransition = new PendingStateTransition(result, nextState, operation);\n        return result;\n    }\n\n    /**\n     * Determines if an epoch bump can be triggered manually based on the api versions.\n     *\n     * <b>NOTE:</b>\n     * This method should only be used for transactional producers.\n     * For non-transactional producers epoch bumping is always allowed.\n     *\n     * <ol>\n     *   <li><b>Client-Triggered Epoch Bump</b>:\n     *          If the coordinator supports epoch bumping (initProducerIdVersion.maxVersion() >= 3),\n     *          client-triggered epoch bumping is allowed, returns true.\n     *          <code>clientSideEpochBumpTriggerRequired</code> must be set to true in this case.</li>\n     *\n     *   <li><b>No Epoch Bump Allowed</b>:\n     *          If the coordinator does not support epoch bumping, returns false.</li>\n     *",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1171-L1320",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1171,
  "end_line": 1320,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}