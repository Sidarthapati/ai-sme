{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.ApiVersions;\nimport org.apache.kafka.clients.ClientResponse;\nimport org.apache.kafka.clients.NodeApiVersions;\nimport org.apache.kafka.clients.RequestCompletionHandler;\nimport org.apache.kafka.clients.consumer.CommitFailedException;\nimport org.apache.kafka.clients.consumer.ConsumerGroupMetadata;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.clients.producer.Producer;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.Node;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.AuthenticationException;\nimport org.apache.kafka.common.errors.ClusterAuthorizationException;\nimport org.apache.kafka.common.errors.GroupAuthorizationException;\nimport org.apache.kafka.common.errors.InvalidPidMappingException;\nimport org.apache.kafka.common.errors.InvalidProducerEpochException;\nimport org.apache.kafka.common.errors.InvalidTxnStateException;\nimport org.apache.kafka.common.errors.OutOfOrderSequenceException;\nimport org.apache.kafka.common.errors.ProducerFencedException;\nimport org.apache.kafka.common.errors.RetriableException;\nimport org.apache.kafka.common.errors.TopicAuthorizationException;\nimport org.apache.kafka.common.errors.TransactionAbortableException;\nimport org.apache.kafka.common.errors.TransactionalIdAuthorizationException;\nimport org.apache.kafka.common.errors.UnknownProducerIdException;\nimport org.apache.kafka.common.errors.UnsupportedVersionException;\nimport org.apache.kafka.common.message.AddOffsetsToTxnRequestData;\nimport org.apache.kafka.common.message.ApiVersionsResponseData.ApiVersion;\nimport org.apache.kafka.common.message.EndTxnRequestData;\nimport org.apache.kafka.common.message.FindCoordinatorRequestData;\nimport org.apache.kafka.common.message.FindCoordinatorResponseData.Coordinator;\nimport org.apache.kafka.common.message.InitProducerIdRequestData;\nimport org.apache.kafka.common.protocol.ApiKeys;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.record.RecordBatch;\nimport org.apache.kafka.common.requests.AbstractRequest;\nimport org.apache.kafka.common.requests.AbstractResponse;\nimport org.apache.kafka.common.requests.AddOffsetsToTxnRequest;\nimport org.apache.kafka.common.requests.AddOffsetsToTxnResponse;\nimport org.apache.kafka.common.requests.AddPartitionsToTxnRequest;\nimport org.apache.kafka.common.requests.AddPartitionsToTxnResponse;\nimport org.apache.kafka.common.requests.EndTxnRequest;\nimport org.apache.kafka.common.requests.EndTxnResponse;\nimport org.apache.kafka.common.requests.FindCoordinatorRequest;\nimport org.apache.kafka.common.requests.FindCoordinatorRequest.CoordinatorType;\nimport org.apache.kafka.common.requests.FindCoordinatorResponse;\nimport org.apache.kafka.common.requests.InitProducerIdRequest;\nimport org.apache.kafka.common.requests.InitProducerIdResponse;\nimport org.apache.kafka.common.requests.ProduceResponse;\nimport org.apache.kafka.common.requests.TransactionResult;\nimport org.apache.kafka.common.requests.TxnOffsetCommitRequest;\nimport org.apache.kafka.common.requests.TxnOffsetCommitRequest.CommittedOffset;\nimport org.apache.kafka.common.requests.TxnOffsetCommitResponse;\nimport org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.ProducerIdAndEpoch;\n\nimport org.slf4j.Logger;\n\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.OptionalInt;\nimport java.util.OptionalLong;\nimport java.util.PriorityQueue;\nimport java.util.Set;\nimport java.util.function.Supplier;\n\n/**\n * A class which maintains state for transactions. Also keeps the state necessary to ensure idempotent production.\n */\npublic class TransactionManager {\n    private static final int NO_INFLIGHT_REQUEST_CORRELATION_ID = -1;\n\n    private final Logger log;\n    private final String transactionalId;\n    private final int transactionTimeoutMs;\n    private final ApiVersions apiVersions;\n\n    private final TxnPartitionMap txnPartitionMap;\n\n    private final Map<TopicPartition, CommittedOffset> pendingTxnOffsetCommits;\n\n    // If a batch bound for a partition expired locally after being sent at least once, the partition is considered\n    // to have an unresolved state. We keep track of such partitions here, and cannot assign any more sequence numbers\n    // for this partition until the unresolved state gets cleared. This may happen if other inflight batches returned\n    // successfully (indicating that the expired batch actually made it to the broker). If we don't get any successful\n    // responses for the partition once the inflight request count falls to zero, we reset the producer id and\n    // consequently clear this data structure as well.\n    // The value of the map is the sequence number of the batch following the expired one, computed by adding its\n    // record count to its sequence number. This is used to tell if a subsequent batch is the one immediately following\n    // the expired one.\n    private final Map<TopicPartition, Integer> partitionsWithUnresolvedSequences;\n\n    // The partitions that have received an error that triggers an epoch bump. When the epoch is bumped, these\n    // partitions will have the sequences of their in-flight batches rewritten\n    private final Set<TopicPartition> partitionsToRewriteSequences;\n\n    private final PriorityQueue<TxnRequestHandler> pendingRequests;\n    private final Set<TopicPartition> newPartitionsInTransaction;\n    private final Set<TopicPartition> pendingPartitionsInTransaction;\n    private final Set<TopicPartition> partitionsInTransaction;\n    private PendingStateTransition pendingTransition;\n\n    // This is used by the TxnRequestHandlers to control how long to back off before a given request is retried.\n    // For instance, this value is lowered by the AddPartitionsToTxnHandler when it receives a CONCURRENT_TRANSACTIONS\n    // error for the first AddPartitionsRequest in a transaction.\n    private final long retryBackoffMs;\n\n    // The retryBackoff is overridden to the following value if the first AddPartitions receives a\n    // CONCURRENT_TRANSACTIONS error.\n    private static final long ADD_PARTITIONS_RETRY_BACKOFF_MS = 20L;\n\n    private int inFlightRequestCorrelationId = NO_INFLIGHT_REQUEST_CORRELATION_ID;\n    private Node transactionCoordinator;\n    private Node consumerGroupCoordinator;\n    private boolean coordinatorSupportsBumpingEpoch;\n\n    private volatile State currentState = State.UNINITIALIZED;\n    private volatile RuntimeException lastError = null;\n    private volatile ProducerIdAndEpoch producerIdAndEpoch;\n    private volatile boolean transactionStarted = false;\n    private volatile boolean clientSideEpochBumpRequired = false;\n    private volatile long latestFinalizedFeaturesEpoch = -1;\n    private volatile boolean isTransactionV2Enabled = false;\n    private final boolean enable2PC;\n    private volatile ProducerIdAndEpoch preparedTxnState = ProducerIdAndEpoch.NONE;\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}