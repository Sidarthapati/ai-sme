{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClientUtils.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClientUtils.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kafka.clients;\n\nimport org.apache.kafka.common.Node;\nimport org.apache.kafka.common.errors.AuthenticationException;\nimport org.apache.kafka.common.errors.DisconnectException;\nimport org.apache.kafka.common.utils.Time;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Provides additional utilities for {@link NetworkClient} (e.g. to implement blocking behaviour).\n */\npublic final class NetworkClientUtils {\n\n    private NetworkClientUtils() {}\n\n    /**\n     * Checks whether the node is currently connected, first calling `client.poll` to ensure that any pending\n     * disconnects have been processed.\n     *\n     * This method can be used to check the status of a connection prior to calling the blocking version to be able\n     * to tell whether the latter completed a new connection.\n     */\n    public static boolean isReady(KafkaClient client, Node node, long currentTime) {\n        client.poll(0, currentTime);\n        return client.isReady(node, currentTime);\n    }\n\n    /**\n     * Invokes `client.poll` to discard pending disconnects, followed by `client.ready` and 0 or more `client.poll`\n     * invocations until the connection to `node` is ready, the timeoutMs expires or the connection fails.\n     *\n     * It returns `true` if the call completes normally or `false` if the timeoutMs expires. If the connection fails,\n     * an `IOException` is thrown instead. Note that if the `NetworkClient` has been configured with a positive\n     * connection timeoutMs, it is possible for this method to raise an `IOException` for a previous connection which\n     * has recently disconnected. If authentication to the node fails, an `AuthenticationException` is thrown.\n     *\n     * This method is useful for implementing blocking behaviour on top of the non-blocking `NetworkClient`, use it with\n     * care.\n     */\n    public static boolean awaitReady(KafkaClient client, Node node, Time time, long timeoutMs) throws IOException {\n        if (timeoutMs < 0) {\n            throw new IllegalArgumentException(\"Timeout needs to be greater than 0\");\n        }\n        long startTime = time.milliseconds();\n\n        if (isReady(client, node, startTime) ||  client.ready(node, startTime))\n            return true;\n\n        long attemptStartTime = time.milliseconds();\n        while (!client.isReady(node, attemptStartTime) && attemptStartTime - startTime < timeoutMs) {\n            if (client.connectionFailed(node)) {\n                throw new IOException(\"Connection to \" + node + \" failed.\");\n            }\n            long pollTimeout = timeoutMs - (attemptStartTime - startTime); // initialize in this order to avoid overflow\n\n            // If the network client is waiting to send data for some reason (eg. throttling or retry backoff),\n            // polling longer than that is potentially dangerous as the producer will not attempt to send\n            // any pending requests.\n            long waitingTime = client.pollDelayMs(node, startTime);\n            if (waitingTime > 0 && pollTimeout > waitingTime) {\n                // Block only until the next-scheduled time that it's okay to send data to the producer,\n                // wake up, and try again. This is the way.\n                pollTimeout = waitingTime;\n            }\n\n            client.poll(pollTimeout, attemptStartTime);\n            if (client.authenticationException(node) != null)\n                throw client.authenticationException(node);\n            attemptStartTime = time.milliseconds();\n        }\n        return client.isReady(node, attemptStartTime);\n    }\n\n    /**\n     * Invokes `client.send` followed by 1 or more `client.poll` invocations until a response is received or a\n     * disconnection happens (which can happen for a number of reasons including a request timeout).\n     *\n     * In case of a disconnection, an `IOException` is thrown.\n     * If shutdown is initiated on the client during this method, an IOException is thrown.\n     *\n     * This method is useful for implementing blocking behaviour on top of the non-blocking `NetworkClient`, use it with\n     * care.\n     */\n    public static ClientResponse sendAndReceive(KafkaClient client, ClientRequest request, Time time) throws IOException {\n        try {\n            client.send(request, time.milliseconds());\n            while (client.active()) {\n                List<ClientResponse> responses = client.poll(Long.MAX_VALUE, time.milliseconds());\n                for (ClientResponse response : responses) {\n                    if (response.requestHeader().correlationId() == request.correlationId()) {\n                        if (response.wasDisconnected()) {\n                            throw new IOException(\"Connection to \" + response.destination() + \" was disconnected before the response was read\");\n                        }\n                        if (response.versionMismatch() != null) {\n                            throw response.versionMismatch();\n                        }\n                        return response;\n                    }\n                }\n            }\n            throw new IOException(\"Client was shutdown before response was read\");\n        } catch (DisconnectException e) {\n            if (client.active())\n                throw e;\n            else\n                throw new IOException(\"Client was shutdown before response was read\");\n\n        }\n    }\n\n    /**\n     * Check if the code is disconnected and unavailable for immediate reconnection (i.e. if it is in\n     * reconnect backoff window following the disconnect).\n     */\n    public static boolean isUnavailable(KafkaClient client, Node node, Time time) {\n        return client.connectionFailed(node) && client.connectionDelay(node, time.milliseconds()) > 0;\n    }\n\n    /**\n     * Check for an authentication error on a given node and raise the exception if there is one.\n     */\n    public static void maybeThrowAuthFailure(KafkaClient client, Node node) {\n        AuthenticationException exception = client.authenticationException(node);\n        if (exception != null)\n            throw exception;\n    }\n\n    /**\n     * Initiate a connection if currently possible. This is only really useful for resetting the\n     * failed status of a socket.\n     */",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClientUtils.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClientUtils.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.578920",
  "source_type": "github"
}