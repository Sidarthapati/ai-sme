{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_4421",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                            } else {\n                                userInsertions.putIfAbsent(user, new HashMap<>());\n                                userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n                            }\n                        }\n                    } catch (NoSuchAlgorithmException e) {\n                        // we might overwrite an exception from a previous alteration, but we don't really care\n                        // since we just need to mark this user as having at least one illegal alteration\n                        // and make an exception instance available for completing the corresponding future exceptionally\n                        userIllegalAlterationExceptions.put(user, new UnsupportedSaslMechanismException(unknownScramMechanismMsg));\n                    } catch (InvalidKeyException e) {\n                        // generally shouldn't happen since we deal with the empty password case above,\n                        // but we still need to catch/handle it\n                        userIllegalAlterationExceptions.put(user, new UnacceptableCredentialException(e.getMessage(), e));\n                    }\n                }\n            });\n\n        // submit alterations only for users that do not have an illegal alteration as identified above\n        Call call = new Call(\"alterUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n            new ControllerNodeProvider()) {\n            @Override\n            public AlterUserScramCredentialsRequest.Builder createRequest(int timeoutMs) {\n                return new AlterUserScramCredentialsRequest.Builder(\n                    new AlterUserScramCredentialsRequestData().setUpsertions(alterations.stream()\n                            .filter(a -> a instanceof UserScramCredentialUpsertion)\n                            .filter(a -> !userIllegalAlterationExceptions.containsKey(a.user()))\n                            .map(a -> userInsertions.get(a.user()).get(((UserScramCredentialUpsertion) a).credentialInfo().mechanism()))\n                            .collect(Collectors.toList()))\n                        .setDeletions(alterations.stream()\n                            .filter(a -> a instanceof UserScramCredentialDeletion)\n                            .filter(a -> !userIllegalAlterationExceptions.containsKey(a.user()))\n                            .map(d -> getScramCredentialDeletion((UserScramCredentialDeletion) d))\n                            .collect(Collectors.toList())));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                AlterUserScramCredentialsResponse response = (AlterUserScramCredentialsResponse) abstractResponse;\n                // Check for controller change\n                for (Errors error : response.errorCounts().keySet()) {\n                    if (error == Errors.NOT_CONTROLLER) {\n                        handleNotControllerError(error);\n                    }\n                }\n                /* Now that we have the results for the ones we sent,\n                 * fail any users that have an illegal alteration as identified above.\n                 * Be sure to do this after the NOT_CONTROLLER error check above\n                 * so that all errors are consistent in that case.\n                 */\n                userIllegalAlterationExceptions.forEach((key, value) ->\n                    futures.get(key).completeExceptionally(value)\n                );\n                response.data().results().forEach(result -> {\n                    KafkaFutureImpl<Void> future = futures.get(result.user());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown user {}\", result.user());\n                    } else {\n                        Errors error = Errors.forCode(result.errorCode());\n                        if (error != Errors.NONE) {\n                            future.completeExceptionally(error.exception(result.errorMessage()));\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                });\n                completeUnrealizedFutures(\n                    futures.entrySet().stream(),\n                    user -> \"The broker response did not contain a result for user \" + user);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n        runnable.call(call, now);\n        return new AlterUserScramCredentialsResult(new HashMap<>(futures));\n    }\n\n    private static AlterUserScramCredentialsRequestData.ScramCredentialUpsertion getScramCredentialUpsertion(UserScramCredentialUpsertion u) throws InvalidKeyException, NoSuchAlgorithmException {\n        AlterUserScramCredentialsRequestData.ScramCredentialUpsertion retval = new AlterUserScramCredentialsRequestData.ScramCredentialUpsertion();\n        return retval.setName(u.user())\n            .setMechanism(u.credentialInfo().mechanism().type())\n            .setIterations(u.credentialInfo().iterations())\n            .setSalt(u.salt())\n            .setSaltedPassword(getSaltedPassword(u.credentialInfo().mechanism(), u.password(), u.salt(), u.credentialInfo().iterations()));\n    }\n\n    private static AlterUserScramCredentialsRequestData.ScramCredentialDeletion getScramCredentialDeletion(UserScramCredentialDeletion d) {\n        return new AlterUserScramCredentialsRequestData.ScramCredentialDeletion().setName(d.user()).setMechanism(d.mechanism().type());\n    }\n\n    private static byte[] getSaltedPassword(ScramMechanism publicScramMechanism, byte[] password, byte[] salt, int iterations) throws NoSuchAlgorithmException, InvalidKeyException {\n        return new ScramFormatter(org.apache.kafka.common.security.scram.internals.ScramMechanism.forMechanismName(publicScramMechanism.mechanismName()))\n            .hi(password, salt, iterations);\n    }\n\n    @Override\n    public DescribeFeaturesResult describeFeatures(final DescribeFeaturesOptions options) {\n        final KafkaFutureImpl<FeatureMetadata> future = new KafkaFutureImpl<>();\n        final long now = time.milliseconds();\n        final NodeProvider nodeProvider = options.nodeId().isPresent() ?\n            new ConstantNodeIdProvider(options.nodeId().getAsInt(), true) : new LeastLoadedBrokerOrActiveKController();\n        final Call call = new Call(\n            \"describeFeatures\", calcDeadlineMs(now, options.timeoutMs()), nodeProvider) {\n\n            private FeatureMetadata createFeatureMetadata(final ApiVersionsResponse response) {\n                final Map<String, FinalizedVersionRange> finalizedFeatures = new HashMap<>();\n                for (final FinalizedFeatureKey key : response.data().finalizedFeatures().valuesSet()) {\n                    finalizedFeatures.put(key.name(), new FinalizedVersionRange(key.minVersionLevel(), key.maxVersionLevel()));\n                }\n\n                Optional<Long> finalizedFeaturesEpoch;\n                if (response.data().finalizedFeaturesEpoch() >= 0L) {\n                    finalizedFeaturesEpoch = Optional.of(response.data().finalizedFeaturesEpoch());\n                } else {\n                    finalizedFeaturesEpoch = Optional.empty();\n                }\n\n                final Map<String, SupportedVersionRange> supportedFeatures = new HashMap<>();\n                for (final SupportedFeatureKey key : response.data().supportedFeatures().valuesSet()) {\n                    supportedFeatures.put(key.name(), new SupportedVersionRange(key.minVersion(), key.maxVersion()));\n                }\n\n                return new FeatureMetadata(finalizedFeatures, finalizedFeaturesEpoch, supportedFeatures);\n            }\n\n            @Override\n            ApiVersionsRequest.Builder createRequest(int timeoutMs) {\n                return new ApiVersionsRequest.Builder();\n            }\n\n            @Override\n            void handleResponse(AbstractResponse response) {\n                final ApiVersionsResponse apiVersionsResponse = (ApiVersionsResponse) response;\n                if (apiVersionsResponse.data().errorCode() == Errors.NONE.code()) {\n                    future.complete(createFeatureMetadata(apiVersionsResponse));\n                } else {\n                    future.completeExceptionally(Errors.forCode(apiVersionsResponse.data().errorCode()).exception());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(Collections.singletonList(future), throwable);\n            }\n        };\n\n        runnable.call(call, now);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L4421-L4570",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 4421,
  "end_line": 4570,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}