{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_2731",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "            final Integer node = entry.getKey();\n            Map<ConfigResource, KafkaFutureImpl<Config>> unified = entry.getValue();\n\n            runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n                node != null ? new ConstantNodeIdProvider(node, true) : new LeastLoadedBrokerOrActiveKController()) {\n\n                @Override\n                DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n                    return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData()\n                        .setResources(unified.keySet().stream()\n                            .map(config ->\n                                new DescribeConfigsRequestData.DescribeConfigsResource()\n                                    .setResourceName(config.name())\n                                    .setResourceType(config.type().id())\n                                    .setConfigurationKeys(null))\n                            .collect(Collectors.toList()))\n                        .setIncludeSynonyms(options.includeSynonyms())\n                        .setIncludeDocumentation(options.includeDocumentation()));\n                }\n\n                @Override\n                void handleResponse(AbstractResponse abstractResponse) {\n                    DescribeConfigsResponse response = (DescribeConfigsResponse) abstractResponse;\n                    for (Map.Entry<ConfigResource, DescribeConfigsResponseData.DescribeConfigsResult> entry : response.resultMap().entrySet()) {\n                        ConfigResource configResource = entry.getKey();\n                        DescribeConfigsResponseData.DescribeConfigsResult describeConfigsResult = entry.getValue();\n                        KafkaFutureImpl<Config> future = unified.get(configResource);\n                        if (future == null) {\n                            if (node != null) {\n                                log.warn(\"The config {} in the response from node {} is not in the request\",\n                                    configResource, node);\n                            } else {\n                                log.warn(\"The config {} in the response from the least loaded broker is not in the request\",\n                                    configResource);\n                            }\n                        } else {\n                            if (describeConfigsResult.errorCode() != Errors.NONE.code()) {\n                                future.completeExceptionally(Errors.forCode(describeConfigsResult.errorCode())\n                                    .exception(describeConfigsResult.errorMessage()));\n                            } else {\n                                future.complete(describeConfigResult(describeConfigsResult));\n                            }\n                        }\n                    }\n                    completeUnrealizedFutures(\n                        unified.entrySet().stream(),\n                        configResource -> \"The node response did not contain a result for config resource \" + configResource);\n                }\n\n                @Override\n                void handleFailure(Throwable throwable) {\n                    completeAllExceptionally(unified.values(), throwable);\n                }\n            }, now);\n        }\n\n        return new DescribeConfigsResult(\n            nodeFutures.entrySet()\n                .stream()\n                .flatMap(x -> x.getValue().entrySet().stream())\n                .collect(Collectors.toMap(\n                    Map.Entry::getKey,\n                    Map.Entry::getValue,\n                    (oldValue, newValue) -> {\n                        // Duplicate keys should not occur, throw an exception to signal this issue\n                        throw new IllegalStateException(String.format(\"Duplicate key for values: %s and %s\", oldValue, newValue));\n                    },\n                    HashMap::new\n                ))\n        );\n    }\n\n    private Config describeConfigResult(DescribeConfigsResponseData.DescribeConfigsResult describeConfigsResult) {\n        return new Config(describeConfigsResult.configs().stream().map(config -> new ConfigEntry(\n            config.name(),\n            config.value(),\n            DescribeConfigsResponse.ConfigSource.forId(config.configSource()).source(),\n            config.isSensitive(),\n            config.readOnly(),\n            (config.synonyms().stream().map(synonym -> new ConfigEntry.ConfigSynonym(synonym.name(), synonym.value(),\n                DescribeConfigsResponse.ConfigSource.forId(synonym.source()).source()))).collect(Collectors.toList()),\n            DescribeConfigsResponse.ConfigType.forId(config.configType()).type(),\n            config.documentation()\n        )).collect(Collectors.toList()));\n    }\n\n    private ConfigEntry.ConfigSource configSource(DescribeConfigsResponse.ConfigSource source) {\n        ConfigEntry.ConfigSource configSource;\n        switch (source) {\n            case TOPIC_CONFIG:\n                configSource = ConfigEntry.ConfigSource.DYNAMIC_TOPIC_CONFIG;\n                break;\n            case DYNAMIC_BROKER_CONFIG:\n                configSource = ConfigEntry.ConfigSource.DYNAMIC_BROKER_CONFIG;\n                break;\n            case DYNAMIC_DEFAULT_BROKER_CONFIG:\n                configSource = ConfigEntry.ConfigSource.DYNAMIC_DEFAULT_BROKER_CONFIG;\n                break;\n            case STATIC_BROKER_CONFIG:\n                configSource = ConfigEntry.ConfigSource.STATIC_BROKER_CONFIG;\n                break;\n            case DYNAMIC_BROKER_LOGGER_CONFIG:\n                configSource = ConfigEntry.ConfigSource.DYNAMIC_BROKER_LOGGER_CONFIG;\n                break;\n            case DEFAULT_CONFIG:\n                configSource = ConfigEntry.ConfigSource.DEFAULT_CONFIG;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unexpected config source \" + source);\n        }\n        return configSource;\n    }\n\n    @Override\n    public AlterConfigsResult incrementalAlterConfigs(Map<ConfigResource, Collection<AlterConfigOp>> configs,\n                                                      final AlterConfigsOptions options) {\n        final Map<ConfigResource, KafkaFutureImpl<Void>> allFutures = new HashMap<>();\n        // BROKER_LOGGER requests always go to a specific, constant broker or controller node.\n        //\n        // BROKER resource changes for a specific (non-default) resource go to either that specific\n        // node (if using bootstrap.servers), or directly to the active controller (if using\n        // bootstrap.controllers)\n        //\n        // All other requests go to the least loaded broker (if using bootstrap.servers) or the\n        // active controller (if using bootstrap.controllers)\n        final Collection<ConfigResource> unifiedRequestResources = new ArrayList<>();\n\n        for (ConfigResource resource : configs.keySet()) {\n            Integer node = nodeFor(resource);\n            if (metadataManager.usingBootstrapControllers()) {\n                if (!resource.type().equals(ConfigResource.Type.BROKER_LOGGER)) {\n                    node = null;\n                }\n            }\n            if (node != null) {\n                NodeProvider nodeProvider = new ConstantNodeIdProvider(node, true);\n                allFutures.putAll(incrementalAlterConfigs(configs, options, Collections.singleton(resource), nodeProvider));\n            } else\n                unifiedRequestResources.add(resource);\n        }\n        if (!unifiedRequestResources.isEmpty())\n            allFutures.putAll(incrementalAlterConfigs(configs, options, unifiedRequestResources, new LeastLoadedBrokerOrActiveKController()));\n\n        return new AlterConfigsResult(new HashMap<>(allFutures));\n    }\n\n    private Map<ConfigResource, KafkaFutureImpl<Void>> incrementalAlterConfigs(Map<ConfigResource, Collection<AlterConfigOp>> configs,\n                                                                               final AlterConfigsOptions options,\n                                                                               Collection<ConfigResource> resources,\n                                                                               NodeProvider nodeProvider) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2731-L2880",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 2731,
  "end_line": 2880,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}