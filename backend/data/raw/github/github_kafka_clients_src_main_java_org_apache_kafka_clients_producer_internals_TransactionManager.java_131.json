{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "\n    // The retryBackoff is overridden to the following value if the first AddPartitions receives a\n    // CONCURRENT_TRANSACTIONS error.\n    private static final long ADD_PARTITIONS_RETRY_BACKOFF_MS = 20L;\n\n    private int inFlightRequestCorrelationId = NO_INFLIGHT_REQUEST_CORRELATION_ID;\n    private Node transactionCoordinator;\n    private Node consumerGroupCoordinator;\n    private boolean coordinatorSupportsBumpingEpoch;\n\n    private volatile State currentState = State.UNINITIALIZED;\n    private volatile RuntimeException lastError = null;\n    private volatile ProducerIdAndEpoch producerIdAndEpoch;\n    private volatile boolean transactionStarted = false;\n    private volatile boolean clientSideEpochBumpRequired = false;\n    private volatile long latestFinalizedFeaturesEpoch = -1;\n    private volatile boolean isTransactionV2Enabled = false;\n    private final boolean enable2PC;\n    private volatile ProducerIdAndEpoch preparedTxnState = ProducerIdAndEpoch.NONE;\n\n    private enum State {\n        UNINITIALIZED,\n        INITIALIZING,\n        READY,\n        IN_TRANSACTION,\n        PREPARED_TRANSACTION,\n        COMMITTING_TRANSACTION,\n        ABORTING_TRANSACTION,\n        ABORTABLE_ERROR,\n        FATAL_ERROR;\n\n        private boolean isTransitionValid(State source, State target) {\n            switch (target) {\n                case UNINITIALIZED:\n                    return source == READY || source == ABORTABLE_ERROR;\n                case INITIALIZING:\n                    return source == UNINITIALIZED || source == COMMITTING_TRANSACTION || source == ABORTING_TRANSACTION;\n                case READY:\n                    return source == INITIALIZING || source == COMMITTING_TRANSACTION || source == ABORTING_TRANSACTION;\n                case IN_TRANSACTION:\n                    return source == READY;\n                case PREPARED_TRANSACTION:\n                    return source == IN_TRANSACTION || source == INITIALIZING;\n                case COMMITTING_TRANSACTION:\n                    return source == IN_TRANSACTION || source == PREPARED_TRANSACTION;\n                case ABORTING_TRANSACTION:\n                    return source == IN_TRANSACTION || source == PREPARED_TRANSACTION || source == ABORTABLE_ERROR;\n                case ABORTABLE_ERROR:\n                    return source == IN_TRANSACTION || source == COMMITTING_TRANSACTION || source == ABORTABLE_ERROR\n                            || source == INITIALIZING;\n                case FATAL_ERROR:\n                default:\n                    // We can transition to FATAL_ERROR unconditionally.\n                    // FATAL_ERROR is never a valid starting state for any transition. So the only option is to close the\n                    // producer or do purely non transactional requests.\n                    return true;\n            }\n        }\n    }\n\n    // We use the priority to determine the order in which requests need to be sent out. For instance, if we have\n    // a pending FindCoordinator request, that must always go first. Next, If we need a producer id, that must go second.\n    // The endTxn request must always go last, unless we are bumping the epoch (a special case of InitProducerId) as\n    // part of ending the transaction.\n    private enum Priority {\n        FIND_COORDINATOR(0),\n        INIT_PRODUCER_ID(1),\n        ADD_PARTITIONS_OR_OFFSETS(2),\n        END_TXN(3),\n        EPOCH_BUMP(4);\n\n        final int priority;\n\n        Priority(int priority) {\n            this.priority = priority;\n        }\n    }\n    \n    private enum TransactionOperation {\n        SEND(\"send\"),\n        BEGIN_TRANSACTION(\"beginTransaction\"),\n        PREPARE_TRANSACTION(\"prepareTransaction\"),\n        SEND_OFFSETS_TO_TRANSACTION(\"sendOffsetsToTransaction\");\n        \n        final String displayName;\n\n        TransactionOperation(String displayName) {\n            this.displayName = displayName;\n        }\n\n        @Override\n        public String toString() {\n            return displayName;\n        }\n    }\n\n    public TransactionManager(final LogContext logContext,\n                              final String transactionalId,\n                              final int transactionTimeoutMs,\n                              final long retryBackoffMs,\n                              final ApiVersions apiVersions,\n                              final boolean enable2PC) {\n        this.producerIdAndEpoch = ProducerIdAndEpoch.NONE;\n        this.transactionalId = transactionalId;\n        this.log = logContext.logger(TransactionManager.class);\n        this.transactionTimeoutMs = transactionTimeoutMs;\n        this.transactionCoordinator = null;\n        this.consumerGroupCoordinator = null;\n        this.newPartitionsInTransaction = new HashSet<>();\n        this.pendingPartitionsInTransaction = new HashSet<>();\n        this.partitionsInTransaction = new HashSet<>();\n        this.pendingRequests = new PriorityQueue<>(10, Comparator.comparingInt(o -> o.priority().priority));\n        this.pendingTxnOffsetCommits = new HashMap<>();\n        this.partitionsWithUnresolvedSequences = new HashMap<>();\n        this.partitionsToRewriteSequences = new HashSet<>();\n        this.retryBackoffMs = retryBackoffMs;\n        this.txnPartitionMap = new TxnPartitionMap(logContext);\n        this.apiVersions = apiVersions;\n        this.enable2PC = enable2PC;\n    }\n\n    /**\n     * During its normal course of operations, the transaction manager transitions through different internal\n     * states (i.e. by updating {@link #currentState}) to one of those defined in {@link State}. These state transitions\n     * result from actions on one of the following classes of threads:\n     *\n     * <ul>\n     *     <li><em>Application</em> threads that invokes {@link Producer} API calls</li>\n     *     <li><em>{@link Sender}</em> thread operations</li>\n     * </ul>\n     *\n     * When an invalid state transition is detected during execution on an <em>application</em> thread, the\n     * {@link #currentState} is <em>not updated</em> and an {@link IllegalStateException} is thrown. This gives the\n     * application the opportunity to fix the issue without permanently poisoning the state of the\n     * transaction manager. The {@link Producer} API calls that perform a state transition include:\n     *\n     * <ul>\n     *     <li>{@link Producer#initTransactions()} calls {@link #initializeTransactions(boolean)}</li>\n     *     <li>{@link Producer#beginTransaction()} calls {@link #beginTransaction()}</li>\n     *     <li>{@link Producer#commitTransaction()}} calls {@link #beginCommit()}</li>\n     *     <li>{@link Producer#abortTransaction()} calls {@link #beginAbort()}\n     *     </li>\n     *     <li>{@link Producer#sendOffsetsToTransaction(Map, ConsumerGroupMetadata)} calls\n     *         {@link #sendOffsetsToTransaction(Map, ConsumerGroupMetadata)}\n     *     </li>\n     *     <li>{@link Producer#send(ProducerRecord)} (and its variants) calls\n     *         {@link #maybeAddPartition(TopicPartition)} and\n     *         {@link #maybeTransitionToErrorState(RuntimeException)}\n     *     </li>\n     * </ul>",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}