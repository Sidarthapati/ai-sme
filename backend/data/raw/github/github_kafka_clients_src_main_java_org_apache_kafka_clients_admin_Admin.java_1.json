{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_Admin.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/Admin.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kafka.clients.admin;\n\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.common.ElectionType;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.KafkaFuture;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.TopicCollection;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.TopicPartitionReplica;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.acl.AclBinding;\nimport org.apache.kafka.common.acl.AclBindingFilter;\nimport org.apache.kafka.common.annotation.InterfaceStability;\nimport org.apache.kafka.common.config.ConfigResource;\nimport org.apache.kafka.common.errors.FeatureUpdateFailedException;\nimport org.apache.kafka.common.errors.InconsistentClusterIdException;\nimport org.apache.kafka.common.errors.InterruptException;\nimport org.apache.kafka.common.metrics.KafkaMetric;\nimport org.apache.kafka.common.quota.ClientQuotaAlteration;\nimport org.apache.kafka.common.quota.ClientQuotaFilter;\nimport org.apache.kafka.common.requests.LeaveGroupResponse;\n\nimport java.time.Duration;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.Properties;\nimport java.util.Set;\n\n/**\n * The administrative client for Kafka, which supports managing and inspecting topics, brokers, configurations and ACLs.\n * <p>\n * Instances returned from the {@code create} methods of this interface are guaranteed to be thread safe.\n * However, the {@link KafkaFuture KafkaFutures} returned from request methods are executed\n * by a single thread so it is important that any code which executes on that thread when they complete\n * (using {@link KafkaFuture#thenApply(KafkaFuture.BaseFunction)}, for example) doesn't block\n * for too long. If necessary, processing of results should be passed to another thread.\n * <p>\n * The operations exposed by Admin follow a consistent pattern:\n * <ul>\n *     <li>Admin instances should be created using {@link Admin#create(Properties)} or {@link Admin#create(Map)}</li>\n *     <li>Each operation typically has two overloaded methods, one which uses a default set of options and an\n *     overloaded method where the last parameter is an explicit options object.\n *     <li>The operation method's first parameter is a {@code Collection} of items to perform\n *     the operation on. Batching multiple requests into a single call is more efficient and should be\n *     preferred over multiple calls to the same method.\n *     <li>The operation methods execute asynchronously.\n *     <li>Each {@code xxx} operation method returns an {@code XxxResult} class with methods which expose\n *     {@link KafkaFuture} for accessing the result(s) of the operation.\n *     <li>Typically an {@code all()} method is provided for getting the overall success/failure of the batch and a\n *     {@code values()} method provided access to each item in a request batch.\n *     Other methods may also be provided.\n *     <li>For synchronous behavior, use {@link KafkaFuture#get()}.\n * </ul>\n * <p>\n * Here is a simple example of using an Admin client instance to create a new topic:\n * <pre>\n * {@code\n * Properties props = new Properties();\n * props.put(AdminClientConfig.BOOTSTRAP_SERVERS_CONFIG, \"localhost:9092\");\n *\n * try (Admin admin = Admin.create(props)) {\n *   String topicName = \"my-topic\";\n *   int partitions = 12;\n *   short replicationFactor = 3;\n *   // Create a compacted topic\n *   CreateTopicsResult result = admin.createTopics(Collections.singleton(\n *     new NewTopic(topicName, partitions, replicationFactor)\n *       .configs(Collections.singletonMap(TopicConfig.CLEANUP_POLICY_CONFIG, TopicConfig.CLEANUP_POLICY_COMPACT))));\n *\n *   // Call values() to get the result for a specific topic\n *   KafkaFuture<Void> future = result.values().get(topicName);\n *\n *   // Call get() to block until the topic creation is complete or has failed\n *   // if creation failed the ExecutionException wraps the underlying cause.\n *   future.get();\n * }\n * }\n * </pre>\n *\n * <h3>Bootstrap and balancing</h3>\n * <p>\n * The {@code bootstrap.servers} config in the {@code Map} or {@code Properties} passed\n * to {@link Admin#create(Properties)} is only used for discovering the brokers in the cluster,\n * which the client will then connect to as needed.\n * As such, it is sufficient to include only two or three broker addresses to cope with the possibility of brokers\n * being unavailable.\n * <p>\n * Different operations necessitate requests being sent to different nodes in the cluster. For example\n * {@link #createTopics(Collection)} communicates with the controller, but {@link #describeTopics(Collection)}\n * can talk to any broker. When the recipient does not matter the instance will try to use the broker with the\n * fewest outstanding requests.\n * <p>\n * The client will transparently retry certain errors which are usually transient.\n * For example if the request for {@code createTopics()} get sent to a node which was not the controller\n * the metadata would be refreshed and the request re-sent to the controller.\n *\n * <h3>Broker Compatibility</h3>\n * <p>\n * The minimum broker version required is 0.10.0.0. Methods with stricter requirements will specify the minimum broker\n * version required.\n * <p>\n */\npublic interface Admin extends AutoCloseable {\n\n    /**\n     * Create a new Admin with the given configuration.\n     *\n     * @param props The configuration.\n     * @return The new KafkaAdminClient.\n     */\n    static Admin create(Properties props) {\n        return KafkaAdminClient.createInternal(new AdminClientConfig(props, true), null);\n    }\n\n    /**\n     * Create a new Admin with the given configuration.\n     *\n     * @param conf The configuration.\n     * @return The new KafkaAdminClient.\n     */\n    static Admin create(Map<String, Object> conf) {\n        return KafkaAdminClient.createInternal(new AdminClientConfig(conf, true), null, null);\n    }\n\n    /**\n     * Close the Admin and release all associated resources.\n     * <p>\n     * See {@link #close(Duration)}",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/Admin.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/Admin.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.579602",
  "source_type": "github"
}