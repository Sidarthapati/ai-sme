{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_ClusterConnectionStates.java_391",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "content": "        connectingNodes.remove(id);\n    }\n\n    /**\n     * Get the state of a given connection.\n     * @param id the id of the connection\n     * @return the state of our connection\n     */\n    public ConnectionState connectionState(String id) {\n        return nodeState(id).state;\n    }\n\n    /**\n     * Get the state of a given node.\n     * @param id the connection to fetch the state for\n     */\n    private NodeConnectionState nodeState(String id) {\n        NodeConnectionState state = this.nodeState.get(id);\n        if (state == null)\n            throw new IllegalStateException(\"No entry found for connection \" + id);\n        return state;\n    }\n\n    /**\n     * Get the id set of nodes which are in CONNECTING state\n     */\n    // package private for testing only\n    Set<String> connectingNodes() {\n        return this.connectingNodes;\n    }\n\n    /**\n     * Get the timestamp of the latest connection attempt of a given node\n     * @param id the connection to fetch the state for\n     */\n    public long lastConnectAttemptMs(String id) {\n        NodeConnectionState nodeState = this.nodeState.get(id);\n        return nodeState == null ? 0 : nodeState.lastConnectAttemptMs;\n    }\n\n    /**\n     * Get the current socket connection setup timeout of the given node.\n     * The base value is defined via socket.connection.setup.timeout.\n     * @param id the connection to fetch the state for\n     */\n    public long connectionSetupTimeoutMs(String id) {\n        NodeConnectionState nodeState = this.nodeState(id);\n        return nodeState.connectionSetupTimeoutMs;\n    }\n\n    /**\n     * Test if the connection to the given node has reached its timeout\n     * @param id the connection to fetch the state for\n     * @param now the current time in ms\n     */\n    public boolean isConnectionSetupTimeout(String id, long now) {\n        NodeConnectionState nodeState = this.nodeState(id);\n        if (nodeState.state != ConnectionState.CONNECTING)\n            throw new IllegalStateException(\"Node \" + id + \" is not in connecting state\");\n        return now - lastConnectAttemptMs(id) > connectionSetupTimeoutMs(id);\n    }\n\n    /**\n     * Return the List of nodes whose connection setup has timed out.\n     * @param now the current time in ms\n     */\n    public List<String> nodesWithConnectionSetupTimeout(long now) {\n        return connectingNodes.stream()\n            .filter(id -> isConnectionSetupTimeout(id, now))\n            .collect(Collectors.toList());\n    }\n\n    /**\n     * The state of our connection to a node.\n     */\n    private static class NodeConnectionState {\n        private final String host;\n        private final HostResolver hostResolver;\n        private final Logger log;\n\n        ConnectionState state;\n        AuthenticationException authenticationException;\n        long lastConnectAttemptMs;\n        long failedAttempts;\n        long failedConnectAttempts;\n        long reconnectBackoffMs;\n        long connectionSetupTimeoutMs;\n        // Connection is being throttled if current time < throttleUntilTimeMs.\n        long throttleUntilTimeMs;\n        private List<InetAddress> addresses;\n        private int addressIndex;\n        private InetAddress lastAttemptedAddress;\n\n        private NodeConnectionState(ConnectionState state, long lastConnectAttemptMs, long reconnectBackoffMs,\n                long connectionSetupTimeoutMs, String host, HostResolver hostResolver, Logger log) {\n            this.state = state;\n            this.addresses = Collections.emptyList();\n            this.addressIndex = -1;\n            this.authenticationException = null;\n            this.lastConnectAttemptMs = lastConnectAttemptMs;\n            this.failedAttempts = 0;\n            this.reconnectBackoffMs = reconnectBackoffMs;\n            this.connectionSetupTimeoutMs = connectionSetupTimeoutMs;\n            this.throttleUntilTimeMs = 0;\n            this.host = host;\n            this.hostResolver = hostResolver;\n            this.log = log;\n        }\n\n        public String host() {\n            return host;\n        }\n\n        /**\n         * Fetches the current selected IP address for this node, resolving {@link #host()} if necessary.\n         * @return the selected address\n         * @throws UnknownHostException if resolving {@link #host()} fails\n         */\n        private InetAddress currentAddress() throws UnknownHostException {\n            if (addresses.isEmpty()) {\n                resolveAddresses();\n            }\n\n            // Save the address that we return so that we don't try it twice in a row when we re-resolve due to\n            // disconnecting or exhausting the addresses\n            InetAddress currentAddress = addresses.get(addressIndex);\n            lastAttemptedAddress = currentAddress;\n            return currentAddress;\n        }\n\n        /**\n         * Jumps to the next available resolved address for this node. If no other addresses are available, marks the\n         * list to be refreshed on the next {@link #currentAddress()} call.\n         */\n        private void moveToNextAddress() {\n            if (addresses.isEmpty())\n                return; // Avoid div0. List will initialize on next currentAddress() call\n\n            addressIndex = (addressIndex + 1) % addresses.size();\n            if (addressIndex == 0)\n                clearAddresses(); // Exhausted list. Re-resolve on next currentAddress() call\n        }\n\n        private void resolveAddresses() throws UnknownHostException {\n            // (Re-)initialize list\n            addresses = ClientUtils.resolve(host, hostResolver);\n            if (log.isDebugEnabled()) {\n                log.debug(\"Resolved host {} to addresses {}\", host, addresses);\n            }\n            addressIndex = 0;",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java#L391-L540",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 391,
  "end_line": 540,
  "last_modified": "2026-02-06T01:16:27.577459",
  "source_type": "github"
}