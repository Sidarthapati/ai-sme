{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1301",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                    log.debug(\"Sending {} to {}. correlationId={}, timeoutMs={}\",\n                        requestBuilder, node, clientRequest.correlationId(), timeoutMs);\n                    client.send(clientRequest, now);\n                    callsInFlight.put(node.idString(), call);\n                    correlationIdToCalls.put(clientRequest.correlationId(), call);\n                    break;\n                }\n            }\n            return pollTimeout;\n        }\n\n        /**\n         * Time out expired calls that are in flight.\n         * <p>\n         * Calls that are in flight may have been partially or completely sent over the wire. They may\n         * even be in the process of being processed by the remote server. At the moment, our only option\n         * to time them out is to close the entire connection.\n         *\n         * @param processor The timeout processor.\n         */\n        private void timeoutCallsInFlight(TimeoutProcessor processor) {\n            int numTimedOut = 0;\n            for (Map.Entry<String, Call> entry : callsInFlight.entrySet()) {\n                Call call = entry.getValue();\n                String nodeId = entry.getKey();\n                if (processor.callHasExpired(call)) {\n                    log.info(\"Disconnecting from {} due to timeout while awaiting {}\", nodeId, call);\n                    client.disconnect(nodeId);\n                    numTimedOut++;\n                    // We don't remove anything from the callsInFlight data structure. Because the connection\n                    // has been closed, the calls should be returned by the next client#poll(),\n                    // and handled at that point.\n                }\n            }\n            if (numTimedOut > 0)\n                log.debug(\"Timed out {} call(s) in flight.\", numTimedOut);\n        }\n\n        /**\n         * Handle responses from the server.\n         *\n         * @param now       The current time in milliseconds.\n         * @param responses The latest responses from KafkaClient.\n         */\n        private void handleResponses(long now, List<ClientResponse> responses) {\n            for (ClientResponse response : responses) {\n                int correlationId = response.requestHeader().correlationId();\n\n                Call call = correlationIdToCalls.get(correlationId);\n                if (call == null) {\n                    // If the server returns information about a correlation ID we didn't use yet,\n                    // an internal server error has occurred. Close the connection and log an error message.\n                    log.error(\"Internal server error on {}: server returned information about unknown \" +\n                            \"correlation ID {}, requestHeader = {}\", response.destination(), correlationId,\n                        response.requestHeader());\n                    client.disconnect(response.destination());\n                    continue;\n                }\n\n                // Stop tracking this call.\n                correlationIdToCalls.remove(correlationId);\n                if (!callsInFlight.remove(response.destination(), call)) {\n                    log.error(\"Internal server error on {}: ignoring call {} in correlationIdToCall \" +\n                        \"that did not exist in callsInFlight\", response.destination(), call);\n                    continue;\n                }\n\n                // Handle the result of the call. This may involve retrying the call, if we got a\n                // retriable exception.\n                if (response.versionMismatch() != null) {\n                    call.fail(now, response.versionMismatch());\n                } else if (response.wasDisconnected()) {\n                    AuthenticationException authException = client.authenticationException(call.curNode());\n                    if (authException != null) {\n                        call.fail(now, authException);\n                    } else {\n                        call.fail(now, new DisconnectException(String.format(\n                            \"Cancelled %s request with correlation id %d due to node %s being disconnected\",\n                            call.callName, correlationId, response.destination())));\n                    }\n                } else {\n                    try {\n                        call.handleResponse(response.responseBody());\n                        adminFetchMetricsManager.recordLatency(response.destination(), response.requestLatencyMs());\n                        if (log.isTraceEnabled())\n                            log.trace(\"{} got response {}\", call, response.responseBody());\n                    } catch (Throwable t) {\n                        if (log.isTraceEnabled())\n                            log.trace(\"{} handleResponse failed with {}\", call, prettyPrintException(t));\n                        call.fail(now, t);\n                    }\n                }\n            }\n        }\n\n        /**\n         * Unassign calls that have not yet been sent based on some predicate. For example, this\n         * is used to reassign the calls that have been assigned to a disconnected node.\n         *\n         * @param shouldUnassign Condition for reassignment. If the predicate is true, then the calls will\n         *                       be put back in the pendingCalls collection and they will be reassigned\n         */\n        private void unassignUnsentCalls(Predicate<Node> shouldUnassign) {\n            for (Iterator<Map.Entry<Node, List<Call>>> iter = callsToSend.entrySet().iterator(); iter.hasNext(); ) {\n                Map.Entry<Node, List<Call>> entry = iter.next();\n                Node node = entry.getKey();\n                List<Call> awaitingCalls = entry.getValue();\n\n                if (awaitingCalls.isEmpty()) {\n                    iter.remove();\n                } else if (shouldUnassign.test(node)) {\n                    nodeReadyDeadlines.remove(node);\n                    transitionToPendingAndClearList(awaitingCalls);\n                    iter.remove();\n                }\n            }\n        }\n\n        private boolean hasActiveExternalCalls(Collection<Call> calls) {\n            for (Call call : calls) {\n                if (!call.isInternal()) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /**\n         * Return true if there are currently active external calls.\n         */\n        private boolean hasActiveExternalCalls() {\n            if (hasActiveExternalCalls(pendingCalls)) {\n                return true;\n            }\n            for (List<Call> callList : callsToSend.values()) {\n                if (hasActiveExternalCalls(callList)) {\n                    return true;\n                }\n            }\n            return hasActiveExternalCalls(correlationIdToCalls.values());\n        }\n\n        private boolean threadShouldExit(long now, long curHardShutdownTimeMs) {\n            if (!hasActiveExternalCalls()) {\n                log.trace(\"All work has been completed, and the I/O thread is now exiting.\");\n                return true;\n            }\n            if (now >= curHardShutdownTimeMs) {\n                log.info(\"Forcing a hard I/O thread shutdown. Requests in progress will be aborted.\");\n                return true;",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1301-L1450",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1301,
  "end_line": 1450,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}