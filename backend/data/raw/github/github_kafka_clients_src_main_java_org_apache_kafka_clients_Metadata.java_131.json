{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_Metadata.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "content": "    }\n\n    /**\n     * Get the current metadata cache.\n     */\n    public MetadataSnapshot fetchMetadataSnapshot() {\n        return metadataSnapshot;\n    }\n\n    /**\n     * Return the next time when the current cluster info can be updated (i.e., backoff time has elapsed).\n     * There are two calculations for backing off based on how many attempts to retrieve metadata have been made\n     * since the last successful response, and how many equivalent metadata responses have been received.\n     * The second of these allows backing off when there are errors to do with stale metadata, even though the\n     * metadata responses are clean.\n     * <p>\n     * This can be used to check whether it's worth requesting an update in the knowledge that it will\n     * not be delayed if this method returns 0.\n     *\n     * @param nowMs current time in ms\n     * @return remaining time in ms till the cluster info can be updated again\n     */\n    public synchronized long timeToAllowUpdate(long nowMs) {\n        // Calculate the backoff for attempts which acts when metadata responses fail\n        long backoffForAttempts = Math.max(this.lastRefreshMs +\n                this.refreshBackoff.backoff(this.attempts > 0 ? this.attempts - 1 : 0) - nowMs, 0);\n\n        // Periodic updates based on expiration resets the equivalent response count so exponential backoff is not used\n        if (Math.max(this.lastSuccessfulRefreshMs + this.metadataExpireMs - nowMs, 0) == 0) {\n            this.equivalentResponseCount = 0;\n        }\n\n        // Calculate the backoff for equivalent responses which acts when metadata responses are not making progress\n        long backoffForEquivalentResponseCount = Math.max(this.lastRefreshMs +\n                (this.equivalentResponseCount > 0 ? this.refreshBackoff.backoff(this.equivalentResponseCount - 1) : 0) - nowMs, 0);\n\n        return Math.max(backoffForAttempts, backoffForEquivalentResponseCount);\n    }\n\n    /**\n     * The next time to update the cluster info is the maximum of the time the current info will expire and the time the\n     * current info can be updated (i.e. backoff time has elapsed). If an update has been requested, the metadata\n     * expiry time is now.\n     *\n     * @param nowMs current time in ms\n     * @return remaining time in ms till updating the cluster info\n     */\n    public synchronized long timeToNextUpdate(long nowMs) {\n        long timeToExpire = updateRequested() ? 0 : Math.max(this.lastSuccessfulRefreshMs + this.metadataExpireMs - nowMs, 0);\n        return Math.max(timeToExpire, timeToAllowUpdate(nowMs));\n    }\n\n    public long metadataExpireMs() {\n        return this.metadataExpireMs;\n    }\n\n    /**\n     * Request an update of the current cluster metadata info, permitting backoff based on the number of\n     * equivalent metadata responses, which indicates that responses did not make progress and may be stale.\n     * \n     * @param resetEquivalentResponseBackoff Whether to reset backing off based on consecutive equivalent responses.\n     *                                       This should be set to <i>false</i> in situations where the update is\n     *                                       being requested to retry an operation, such as when the leader has\n     *                                       changed. It should be set to <i>true</i> in situations where new\n     *                                       metadata is being requested, such as adding a topic to a subscription.\n     *                                       In situations where it's not clear, it's best to use <i>true</i>.\n     * \n     * @return The current updateVersion before the update\n     */\n    public synchronized int requestUpdate(final boolean resetEquivalentResponseBackoff) {\n        this.needFullUpdate = true;\n        if (resetEquivalentResponseBackoff) {\n            this.equivalentResponseCount = 0;\n        }\n        return this.updateVersion;\n    }\n\n    /**\n     * Request an immediate update of the current cluster metadata info, because the caller is interested in\n     * metadata that is being newly requested.\n     * @return The current updateVersion before the update\n     */\n    public synchronized int requestUpdateForNewTopics() {\n        // Override the timestamp of last refresh to let immediate update.\n        this.lastRefreshMs = 0;\n        this.needPartialUpdate = true;\n        this.equivalentResponseCount = 0;\n        this.requestVersion++;\n        return this.updateVersion;\n    }\n\n    /**\n     * Request an update for the partition metadata iff we have seen a newer leader epoch. This is called by the client\n     * any time it handles a response from the broker that includes leader epoch, except for update via Metadata RPC which\n     * follows a different code path ({@link #update}).\n     *\n     * @param topicPartition\n     * @param leaderEpoch\n     * @return true if we updated the last seen epoch, false otherwise\n     */\n    public synchronized boolean updateLastSeenEpochIfNewer(TopicPartition topicPartition, int leaderEpoch) {\n        Objects.requireNonNull(topicPartition, \"TopicPartition cannot be null\");\n        if (leaderEpoch < 0)\n            throw new IllegalArgumentException(\"Invalid leader epoch \" + leaderEpoch + \" (must be non-negative)\");\n\n        Integer oldEpoch = lastSeenLeaderEpochs.get(topicPartition);\n        log.trace(\"Determining if we should replace existing epoch {} with new epoch {} for partition {}\", oldEpoch, leaderEpoch, topicPartition);\n\n        final boolean updated;\n        if (oldEpoch == null) {\n            log.debug(\"Not replacing null epoch with new epoch {} for partition {}\", leaderEpoch, topicPartition);\n            updated = false;\n        } else if (leaderEpoch > oldEpoch) {\n            log.debug(\"Updating last seen epoch from {} to {} for partition {}\", oldEpoch, leaderEpoch, topicPartition);\n            lastSeenLeaderEpochs.put(topicPartition, leaderEpoch);\n            updated = true;\n        } else {\n            log.debug(\"Not replacing existing epoch {} with new epoch {} for partition {}\", oldEpoch, leaderEpoch, topicPartition);\n            updated = false;\n        }\n\n        this.needFullUpdate = this.needFullUpdate || updated;\n        return updated;\n    }\n\n    public Optional<Integer> lastSeenLeaderEpoch(TopicPartition topicPartition) {\n        return Optional.ofNullable(lastSeenLeaderEpochs.get(topicPartition));\n    }\n\n    /**\n     * Check whether an update has been explicitly requested.\n     *\n     * @return true if an update was requested, false otherwise\n     */\n    public synchronized boolean updateRequested() {\n        return this.needFullUpdate || this.needPartialUpdate;\n    }\n\n    public synchronized void addClusterUpdateListener(ClusterResourceListener listener) {\n        this.clusterResourceListeners.maybeAdd(listener);\n    }\n\n    /**\n     * Return the cached partition info if it exists and a newer leader epoch isn't known about.\n     */\n    public synchronized Optional<MetadataResponse.PartitionMetadata> partitionMetadataIfCurrent(TopicPartition topicPartition) {\n        Integer epoch = lastSeenLeaderEpochs.get(topicPartition);\n        Optional<MetadataResponse.PartitionMetadata> partitionMetadata = metadataSnapshot.partitionMetadata(topicPartition);\n        if (epoch == null) {\n            // old cluster format (no epochs)",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/Metadata.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/Metadata.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.578514",
  "source_type": "github"
}