{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_3641",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                MetadataResponse metadataResponse = (MetadataResponse) abstractResponse;\n                Collection<Node> nodes = metadataResponse.brokers();\n                if (nodes.isEmpty())\n                    throw new StaleMetadataException(\"Metadata fetch failed due to missing broker list\");\n\n                HashSet<Node> allNodes = new HashSet<>(nodes);\n                final ListConsumerGroupsResults results = new ListConsumerGroupsResults(allNodes, all);\n\n                for (final Node node : allNodes) {\n                    final long nowList = time.milliseconds();\n                    runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                        @Override\n                        ListGroupsRequest.Builder createRequest(int timeoutMs) {\n                            List<String> states = options.groupStates()\n                                .stream()\n                                .map(GroupState::toString)\n                                .collect(Collectors.toList());\n                            List<String> groupTypes = options.types()\n                                .stream()\n                                .map(GroupType::toString)\n                                .collect(Collectors.toList());\n                            return new ListGroupsRequest.Builder(new ListGroupsRequestData()\n                                .setStatesFilter(states)\n                                .setTypesFilter(groupTypes)\n                            );\n                        }\n\n                        private void maybeAddConsumerGroup(ListGroupsResponseData.ListedGroup group) {\n                            String protocolType = group.protocolType();\n                            if (protocolType.equals(ConsumerProtocol.PROTOCOL_TYPE) || protocolType.isEmpty()) {\n                                final String groupId = group.groupId();\n                                final Optional<GroupState> groupState = group.groupState().isEmpty()\n                                    ? Optional.empty()\n                                    : Optional.of(GroupState.parse(group.groupState()));\n                                final Optional<GroupType> type = group.groupType().isEmpty()\n                                    ? Optional.empty()\n                                    : Optional.of(GroupType.parse(group.groupType()));\n                                final ConsumerGroupListing groupListing = new ConsumerGroupListing(\n                                    groupId,\n                                    groupState,\n                                    type,\n                                    protocolType.isEmpty()\n                                );\n                                results.addListing(groupListing);\n                            }\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final ListGroupsResponse response = (ListGroupsResponse) abstractResponse;\n                            synchronized (results) {\n                                Errors error = Errors.forCode(response.data().errorCode());\n                                if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.COORDINATOR_NOT_AVAILABLE) {\n                                    throw error.exception();\n                                } else if (error != Errors.NONE) {\n                                    results.addError(error.exception(), node);\n                                } else {\n                                    for (ListGroupsResponseData.ListedGroup group : response.data().groups()) {\n                                        maybeAddConsumerGroup(group);\n                                    }\n                                }\n                                results.tryComplete(node);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            synchronized (results) {\n                                results.addError(throwable, node);\n                                results.tryComplete(node);\n                            }\n                        }\n                    }, nowList);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                KafkaException exception = new KafkaException(\"Failed to find brokers to send ListGroups\", throwable);\n                all.complete(Collections.singletonList(exception));\n            }\n        }, nowMetadata);\n\n        return new ListConsumerGroupsResult(all);\n    }\n\n    @Override\n    public ListConsumerGroupOffsetsResult listConsumerGroupOffsets(Map<String, ListConsumerGroupOffsetsSpec> groupSpecs,\n                                                                   ListConsumerGroupOffsetsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, Map<TopicPartition, OffsetAndMetadata>> future =\n            ListConsumerGroupOffsetsHandler.newFuture(groupSpecs.keySet());\n        ListConsumerGroupOffsetsHandler handler =\n            new ListConsumerGroupOffsetsHandler(groupSpecs, options.requireStable(), logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new ListConsumerGroupOffsetsResult(future.all());\n    }\n\n    @Override\n    public ListStreamsGroupOffsetsResult listStreamsGroupOffsets(Map<String, ListStreamsGroupOffsetsSpec> groupSpecs,\n                                                                 ListStreamsGroupOffsetsOptions options) {\n        Map<String, ListConsumerGroupOffsetsSpec> consumerGroupSpecs = groupSpecs.entrySet().stream()\n            .collect(Collectors.toMap(\n                Map.Entry::getKey,\n                entry -> new ListConsumerGroupOffsetsSpec().topicPartitions(entry.getValue().topicPartitions())\n            ));\n        ListConsumerGroupOffsetsOptions consumerGroupOptions = new ListConsumerGroupOffsetsOptions()\n            .requireStable(options.requireStable())\n            .timeoutMs(options.timeoutMs());\n        return new ListStreamsGroupOffsetsResult(listConsumerGroupOffsets(consumerGroupSpecs, consumerGroupOptions));\n    }\n\n    @Override\n    public DeleteConsumerGroupsResult deleteConsumerGroups(Collection<String> groupIds, DeleteConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, Void> future =\n            DeleteConsumerGroupsHandler.newFuture(groupIds);\n        DeleteConsumerGroupsHandler handler = new DeleteConsumerGroupsHandler(logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DeleteConsumerGroupsResult(future.all().entrySet().stream()\n            .collect(Collectors.toMap(entry -> entry.getKey().idValue, Map.Entry::getValue)));\n    }\n\n    @Override\n    public DeleteStreamsGroupsResult deleteStreamsGroups(Collection<String> groupIds, DeleteStreamsGroupsOptions options) {\n        DeleteConsumerGroupsOptions consumerGroupOptions = new DeleteConsumerGroupsOptions()\n            .timeoutMs(options.timeoutMs());\n        return new DeleteStreamsGroupsResult(deleteConsumerGroups(groupIds, consumerGroupOptions));\n    }\n\n    @Override\n    public DeleteConsumerGroupOffsetsResult deleteConsumerGroupOffsets(\n        String groupId,\n        Set<TopicPartition> partitions,\n        DeleteConsumerGroupOffsetsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, Map<TopicPartition, Errors>> future =\n            DeleteConsumerGroupOffsetsHandler.newFuture(groupId);\n        DeleteConsumerGroupOffsetsHandler handler = new DeleteConsumerGroupOffsetsHandler(groupId, partitions, logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DeleteConsumerGroupOffsetsResult(future.get(CoordinatorKey.byGroupId(groupId)), partitions);\n    }\n\n    @Override\n    public DeleteStreamsGroupOffsetsResult deleteStreamsGroupOffsets(\n        String groupId,\n        Set<TopicPartition> partitions,\n        DeleteStreamsGroupOffsetsOptions options) {\n        DeleteConsumerGroupOffsetsOptions consumerGroupOptions = new DeleteConsumerGroupOffsetsOptions()",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3641-L3790",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 3641,
  "end_line": 3790,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}