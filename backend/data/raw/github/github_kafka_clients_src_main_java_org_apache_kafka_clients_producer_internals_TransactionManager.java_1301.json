{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1301",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "        pendingTransition = new PendingStateTransition(result, nextState, operation);\n        return result;\n    }\n\n    /**\n     * Determines if an epoch bump can be triggered manually based on the api versions.\n     *\n     * <b>NOTE:</b>\n     * This method should only be used for transactional producers.\n     * For non-transactional producers epoch bumping is always allowed.\n     *\n     * <ol>\n     *   <li><b>Client-Triggered Epoch Bump</b>:\n     *          If the coordinator supports epoch bumping (initProducerIdVersion.maxVersion() >= 3),\n     *          client-triggered epoch bumping is allowed, returns true.\n     *          <code>clientSideEpochBumpTriggerRequired</code> must be set to true in this case.</li>\n     *\n     *   <li><b>No Epoch Bump Allowed</b>:\n     *          If the coordinator does not support epoch bumping, returns false.</li>\n     *\n     *   <li><b>Server-Triggered Only</b>:\n     *          When TransactionV2 is enabled, epoch bumping is handled automatically\n     *          by the server in EndTxn, so manual epoch bumping is not required, returns false.</li>\n     * </ol>\n     *\n     * @return true if a client-triggered epoch bump is allowed, otherwise false.\n     */\n    // package-private for testing\n    boolean needToTriggerEpochBumpFromClient() {\n        return coordinatorSupportsBumpingEpoch && !isTransactionV2Enabled;\n    }\n\n    /**\n     * Determines if the coordinator can handle an abortable error.\n     * Recovering from an abortable error requires an epoch bump which can be triggered by the client\n     * or automatically taken care of at the end of every transaction (Transaction V2).\n     * Use <code>needToTriggerEpochBumpFromClient</code> to check whether the epoch bump needs to be triggered\n     * manually.\n     *\n     * <b>NOTE:</b>\n     * This method should only be used for transactional producers.\n     * There is no concept of abortable errors for idempotent producers.\n     *\n     * @return true if an abortable error can be handled, otherwise false.\n     */\n    boolean canHandleAbortableError() {\n        return coordinatorSupportsBumpingEpoch || isTransactionV2Enabled;\n    }\n\n    private void resetTransactionState() {\n        if (clientSideEpochBumpRequired) {\n            transitionTo(State.INITIALIZING);\n        } else {\n            transitionTo(State.READY);\n        }\n        lastError = null;\n        clientSideEpochBumpRequired = false;\n        transactionStarted = false;\n        newPartitionsInTransaction.clear();\n        pendingPartitionsInTransaction.clear();\n        partitionsInTransaction.clear();\n        preparedTxnState = ProducerIdAndEpoch.NONE;\n    }\n\n    abstract class TxnRequestHandler implements RequestCompletionHandler {\n        protected final TransactionalRequestResult result;\n        private boolean isRetry = false;\n\n        TxnRequestHandler(TransactionalRequestResult result) {\n            this.result = result;\n        }\n\n        TxnRequestHandler(String operation) {\n            this(new TransactionalRequestResult(operation));\n        }\n\n        void fatalError(RuntimeException e) {\n            result.fail(e);\n            transitionToFatalError(e);\n        }\n\n        void abortableError(RuntimeException e) {\n            result.fail(e);\n            transitionToAbortableError(e);\n        }\n\n        /**\n         * Determines if an error should be treated as abortable or fatal, based on transaction state and configuration.\n         * <ol><l> NOTE: Only use this method for transactional producers </l></ol>\n         *\n         * - <b>Abortable Error</b>:\n         *     An abortable error can be handled effectively, if epoch bumping is supported.\n         *     1) If transactionV2 is enabled, automatic epoch bumping happens at the end of every transaction.\n         *     2) If the client can trigger an epoch bump, the abortable error can be handled.\n         *\n         *- <b>Fatal Error</b>:\n         *      If epoch bumping is not supported, the system cannot recover and the error must be treated as fatal.\n         * @param e the error to determine as either abortable or fatal.\n         */\n        void abortableErrorIfPossible(RuntimeException e) {\n            if (canHandleAbortableError()) {\n                if (needToTriggerEpochBumpFromClient())\n                    clientSideEpochBumpRequired = true;\n                abortableError(e);\n            } else {\n                fatalError(e);\n            }\n        }\n\n        void fail(RuntimeException e) {\n            result.fail(e);\n        }\n\n        void reenqueue() {\n            synchronized (TransactionManager.this) {\n                this.isRetry = true;\n                enqueueRequest(this);\n            }\n        }\n\n        long retryBackoffMs() {\n            return retryBackoffMs;\n        }\n\n        @Override\n        public void onComplete(ClientResponse response) {\n            if (response.requestHeader().correlationId() != inFlightRequestCorrelationId) {\n                fatalError(new RuntimeException(\"Detected more than one in-flight transactional request.\"));\n            } else {\n                clearInFlightCorrelationId();\n                if (response.wasDisconnected()) {\n                    log.debug(\"Disconnected from {}. Will retry.\", response.destination());\n                    if (this.needsCoordinator())\n                        lookupCoordinator(this.coordinatorType(), this.coordinatorKey());\n                    reenqueue();\n                } else if (response.versionMismatch() != null) {\n                    fatalError(response.versionMismatch());\n                } else if (response.hasResponse()) {\n                    log.trace(\"Received transactional response {} for request {}\", response.responseBody(),\n                            requestBuilder());\n                    synchronized (TransactionManager.this) {\n                        handleResponse(response.responseBody());\n                    }\n                } else {\n                    fatalError(new KafkaException(\"Could not execute transactional request for unknown reasons\"));\n                }\n            }\n        }\n\n        boolean needsCoordinator() {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1301-L1450",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1301,
  "end_line": 1450,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}