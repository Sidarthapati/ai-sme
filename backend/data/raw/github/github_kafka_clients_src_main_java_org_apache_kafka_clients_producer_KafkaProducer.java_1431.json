{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_KafkaProducer.java_1431",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "content": "    }\n\n    /**\n     * Determines the client's unique client instance ID used for telemetry. This ID is unique to\n     * this specific client instance and will not change after it is initially generated.\n     * The ID is useful for correlating client operations with telemetry sent to the broker and\n     * to its eventual monitoring destinations.\n     * <p>\n     * If telemetry is enabled, this will first require a connection to the cluster to generate\n     * the unique client instance ID. This method waits up to {@code timeout} for the producer\n     * client to complete the request.\n     * <p>\n     * Client telemetry is controlled by the {@link ProducerConfig#ENABLE_METRICS_PUSH_CONFIG}\n     * configuration option.\n     *\n     * @param timeout The maximum time to wait for producer client to determine its client instance ID.\n     *                The value must be non-negative. Specifying a timeout of zero means do not\n     *                wait for the initial request to complete if it hasn't already.\n     * @throws InterruptException If the thread is interrupted while blocked.\n     * @throws KafkaException If an unexpected error occurs while trying to determine the client\n     *                        instance ID, though this error does not necessarily imply the\n     *                        producer client is otherwise unusable.\n     * @throws IllegalArgumentException If the {@code timeout} is negative.\n     * @throws IllegalStateException If telemetry is not enabled ie, config `{@code enable.metrics.push}`\n     *                               is set to `{@code false}`.\n     * @return The client's assigned instance id used for metrics collection.\n     */\n    @Override\n    public Uuid clientInstanceId(Duration timeout) {\n        if (clientTelemetryReporter.isEmpty()) {\n            throw new IllegalStateException(\"Telemetry is not enabled. Set config `\" + ProducerConfig.ENABLE_METRICS_PUSH_CONFIG + \"` to `true`.\");\n        }\n\n        return ClientTelemetryUtils.fetchClientInstanceId(clientTelemetryReporter.get(), timeout);\n    }\n\n    /**\n     * Close this producer. This method blocks until all previously sent requests complete.\n     * This method is equivalent to <code>close(Long.MAX_VALUE, TimeUnit.MILLISECONDS)</code>.\n     * <p>\n     * <strong>If close() is called from {@link Callback}, a warning message will be logged and close(0, TimeUnit.MILLISECONDS)\n     * will be called instead. We do this because the sender thread would otherwise try to join itself and\n     * block forever.</strong>\n     * <p>\n     *\n     * @throws InterruptException If the thread is interrupted while blocked.\n     * @throws KafkaException If an unexpected error occurs while trying to close the client, this error should be treated\n     *                        as fatal and indicate the client is no longer usable.\n     */\n    @Override\n    public void close() {\n        close(Duration.ofMillis(Long.MAX_VALUE));\n    }\n\n    /**\n     * This method waits up to <code>timeout</code> for the producer to complete the sending of all incomplete requests.\n     * <p>\n     * If the producer is unable to complete all requests before the timeout expires, this method will fail\n     * any unsent and unacknowledged records immediately. It will also abort the ongoing transaction if it's not\n     * already completing.\n     * <p>\n     * If invoked from within a {@link Callback} this method will not block and will be equivalent to\n     * <code>close(Duration.ofMillis(0))</code>. This is done since no further sending will happen while\n     * blocking the I/O thread of the producer.\n     *\n     * @param timeout The maximum time to wait for producer to complete any pending requests. The value should be\n     *                non-negative. Specifying a timeout of zero means do not wait for pending send requests to complete.\n     * @throws InterruptException If the thread is interrupted while blocked.\n     * @throws KafkaException If an unexpected error occurs while trying to close the client, this error should be treated\n     *                        as fatal and indicate the client is no longer usable.\n     * @throws IllegalArgumentException If the <code>timeout</code> is negative.\n     *\n     */\n    @Override\n    public void close(Duration timeout) {\n        close(timeout, false);\n    }\n\n    private void close(Duration timeout, boolean swallowException) {\n        long timeoutMs = timeout.toMillis();\n        if (timeoutMs < 0)\n            throw new IllegalArgumentException(\"The timeout cannot be negative.\");\n        log.info(\"Closing the Kafka producer with timeoutMillis = {} ms.\", timeoutMs);\n\n        // this will keep track of the first encountered exception\n        AtomicReference<Throwable> firstException = new AtomicReference<>();\n        boolean invokedFromCallback = Thread.currentThread() == this.ioThread;\n        if (timeoutMs > 0) {\n            if (invokedFromCallback) {\n                log.warn(\"Overriding close timeout {} ms to 0 ms in order to prevent useless blocking due to self-join. \" +\n                        \"This means you have incorrectly invoked close with a non-zero timeout from the producer call-back.\",\n                        timeoutMs);\n            } else {\n                // Try to close gracefully.\n                final Timer closeTimer = time.timer(timeout);\n                clientTelemetryReporter.ifPresent(ClientTelemetryReporter::initiateClose);\n                closeTimer.update();\n\n                if (this.sender != null) {\n                    this.sender.initiateClose();\n                    closeTimer.update();\n                }\n                if (this.ioThread != null) {\n                    try {\n                        this.ioThread.join(closeTimer.remainingMs());\n                    } catch (InterruptedException t) {\n                        firstException.compareAndSet(null, new InterruptException(t));\n                        log.error(\"Interrupted while joining ioThread\", t);\n                    } finally {\n                        closeTimer.update();\n                    }\n                }\n            }\n        }\n\n        if (this.sender != null && this.ioThread != null && this.ioThread.isAlive()) {\n            log.info(\"Proceeding to force close the producer since pending requests could not be completed \" +\n                    \"within timeout {} ms.\", timeoutMs);\n            this.sender.forceClose();\n            // Only join the sender thread when not calling from callback.\n            if (!invokedFromCallback) {\n                try {\n                    this.ioThread.join();\n                } catch (InterruptedException e) {\n                    firstException.compareAndSet(null, new InterruptException(e));\n                }\n            }\n        }\n\n        Utils.closeQuietly(interceptors, \"producer interceptors\", firstException);\n        Utils.closeQuietly(producerMetrics, \"producer metrics wrapper\", firstException);\n        Utils.closeQuietly(metrics, \"producer metrics\", firstException);\n        Utils.closeQuietly(keySerializerPlugin, \"producer keySerializer\", firstException);\n        Utils.closeQuietly(valueSerializerPlugin, \"producer valueSerializer\", firstException);\n        Utils.closeQuietly(partitionerPlugin, \"producer partitioner\", firstException);\n        clientTelemetryReporter.ifPresent(reporter -> Utils.closeQuietly(reporter, \"producer telemetry reporter\", firstException));\n        AppInfoParser.unregisterAppInfo(JMX_PREFIX, clientId, metrics);\n        Throwable exception = firstException.get();\n        if (exception != null && !swallowException) {\n            if (exception instanceof InterruptException) {\n                throw (InterruptException) exception;\n            }\n            throw new KafkaException(\"Failed to close kafka producer\", exception);\n        }\n        log.debug(\"Kafka producer has been closed\");\n    }\n\n    /**\n     * computes partition for given record.\n     * if the record has partition returns the value otherwise",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java#L1431-L1580",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/KafkaProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1431,
  "end_line": 1580,
  "last_modified": "2026-02-06T01:16:27.608270",
  "source_type": "github"
}