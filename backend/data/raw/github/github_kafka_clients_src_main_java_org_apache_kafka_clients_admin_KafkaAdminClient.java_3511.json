{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_3511",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                                final String groupId = group.groupId();\n                                final Optional<GroupType> type;\n                                if (group.groupType() == null || group.groupType().isEmpty()) {\n                                    type = Optional.empty();\n                                } else {\n                                    type = Optional.of(GroupType.parse(group.groupType()));\n                                }\n                                final Optional<GroupState> groupState;\n                                if (group.groupState() == null || group.groupState().isEmpty()) {\n                                    groupState = Optional.empty();\n                                } else {\n                                    groupState = Optional.of(GroupState.parse(group.groupState()));\n                                }\n                                final GroupListing groupListing = new GroupListing(\n                                    groupId,\n                                    type,\n                                    protocolType,\n                                    groupState\n                                );\n                                results.addListing(groupListing);\n                            }\n                        }\n\n                        @Override\n                        void handleResponse(AbstractResponse abstractResponse) {\n                            final ListGroupsResponse response = (ListGroupsResponse) abstractResponse;\n                            synchronized (results) {\n                                Errors error = Errors.forCode(response.data().errorCode());\n                                if (error == Errors.COORDINATOR_LOAD_IN_PROGRESS || error == Errors.COORDINATOR_NOT_AVAILABLE) {\n                                    throw error.exception();\n                                } else if (error != Errors.NONE) {\n                                    results.addError(error.exception(), node);\n                                } else {\n                                    for (ListGroupsResponseData.ListedGroup group : response.data().groups()) {\n                                        maybeAddGroup(group);\n                                    }\n                                }\n                                results.tryComplete(node);\n                            }\n                        }\n\n                        @Override\n                        void handleFailure(Throwable throwable) {\n                            synchronized (results) {\n                                results.addError(throwable, node);\n                                results.tryComplete(node);\n                            }\n                        }\n                    }, nowList);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                KafkaException exception = new KafkaException(\"Failed to find brokers to send ListGroups\", throwable);\n                all.complete(Collections.singletonList(exception));\n            }\n        }, nowMetadata);\n\n        return new ListGroupsResult(all);\n    }\n\n    @Override\n    public DescribeConsumerGroupsResult describeConsumerGroups(final Collection<String> groupIds,\n                                                               final DescribeConsumerGroupsOptions options) {\n        SimpleAdminApiFuture<CoordinatorKey, ConsumerGroupDescription> future =\n            DescribeConsumerGroupsHandler.newFuture(groupIds);\n        DescribeConsumerGroupsHandler handler = new DescribeConsumerGroupsHandler(options.includeAuthorizedOperations(), logContext);\n        invokeDriver(handler, future, options.timeoutMs);\n        return new DescribeConsumerGroupsResult(future.all().entrySet().stream()\n            .collect(Collectors.toMap(entry -> entry.getKey().idValue, Map.Entry::getValue)));\n    }\n\n    @SuppressWarnings(\"removal\")\n    @Deprecated\n    private static final class ListConsumerGroupsResults {\n        private final List<Throwable> errors;\n        private final HashMap<String, ConsumerGroupListing> listings;\n        private final HashSet<Node> remaining;\n        private final KafkaFutureImpl<Collection<Object>> future;\n\n        ListConsumerGroupsResults(Collection<Node> leaders,\n                                  KafkaFutureImpl<Collection<Object>> future) {\n            this.errors = new ArrayList<>();\n            this.listings = new HashMap<>();\n            this.remaining = new HashSet<>(leaders);\n            this.future = future;\n            tryComplete();\n        }\n\n        synchronized void addError(Throwable throwable, Node node) {\n            ApiError error = ApiError.fromThrowable(throwable);\n            if (error.message() == null || error.message().isEmpty()) {\n                errors.add(error.error().exception(\"Error listing groups on \" + node));\n            } else {\n                errors.add(error.error().exception(\"Error listing groups on \" + node + \": \" + error.message()));\n            }\n        }\n\n        synchronized void addListing(ConsumerGroupListing listing) {\n            listings.put(listing.groupId(), listing);\n        }\n\n        synchronized void tryComplete(Node leader) {\n            remaining.remove(leader);\n            tryComplete();\n        }\n\n        private synchronized void tryComplete() {\n            if (remaining.isEmpty()) {\n                ArrayList<Object> results = new ArrayList<>(listings.values());\n                results.addAll(errors);\n                future.complete(results);\n            }\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"removal\")\n    @Deprecated(since = \"4.1\", forRemoval = true)\n    public ListConsumerGroupsResult listConsumerGroups(ListConsumerGroupsOptions options) {\n        final KafkaFutureImpl<Collection<Object>> all = new KafkaFutureImpl<>();\n        final long nowMetadata = time.milliseconds();\n        final long deadline = calcDeadlineMs(nowMetadata, options.timeoutMs());\n        runnable.call(new Call(\"findAllBrokers\", deadline, new LeastLoadedNodeProvider()) {\n            @Override\n            MetadataRequest.Builder createRequest(int timeoutMs) {\n                return new MetadataRequest.Builder(new MetadataRequestData()\n                    .setTopics(Collections.emptyList())\n                    .setAllowAutoTopicCreation(true));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                MetadataResponse metadataResponse = (MetadataResponse) abstractResponse;\n                Collection<Node> nodes = metadataResponse.brokers();\n                if (nodes.isEmpty())\n                    throw new StaleMetadataException(\"Metadata fetch failed due to missing broker list\");\n\n                HashSet<Node> allNodes = new HashSet<>(nodes);\n                final ListConsumerGroupsResults results = new ListConsumerGroupsResults(allNodes, all);\n\n                for (final Node node : allNodes) {\n                    final long nowList = time.milliseconds();\n                    runnable.call(new Call(\"listConsumerGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                        @Override\n                        ListGroupsRequest.Builder createRequest(int timeoutMs) {\n                            List<String> states = options.groupStates()\n                                .stream()\n                                .map(GroupState::toString)",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3511-L3660",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 3511,
  "end_line": 3660,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}