{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_ClusterConnectionStates.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients;\n\nimport org.apache.kafka.common.errors.AuthenticationException;\nimport org.apache.kafka.common.utils.ExponentialBackoff;\nimport org.apache.kafka.common.utils.LogContext;\n\nimport org.slf4j.Logger;\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * The state of our connection to each node in the cluster.\n *\n */\nfinal class ClusterConnectionStates {\n    static final int RECONNECT_BACKOFF_EXP_BASE = 2;\n    static final double RECONNECT_BACKOFF_JITTER = 0.2;\n    static final int CONNECTION_SETUP_TIMEOUT_EXP_BASE = 2;\n    static final double CONNECTION_SETUP_TIMEOUT_JITTER = 0.2;\n    private final Map<String, NodeConnectionState> nodeState;\n    private final Logger log;\n    private final HostResolver hostResolver;\n    private final Set<String> connectingNodes;\n    private final ExponentialBackoff reconnectBackoff;\n    private final ExponentialBackoff connectionSetupTimeout;\n\n    public ClusterConnectionStates(long reconnectBackoffMs, long reconnectBackoffMaxMs,\n                                   long connectionSetupTimeoutMs, long connectionSetupTimeoutMaxMs,\n                                   LogContext logContext, HostResolver hostResolver) {\n        this.log = logContext.logger(ClusterConnectionStates.class);\n        this.reconnectBackoff = new ExponentialBackoff(\n                reconnectBackoffMs,\n                RECONNECT_BACKOFF_EXP_BASE,\n                reconnectBackoffMaxMs,\n                RECONNECT_BACKOFF_JITTER);\n        this.connectionSetupTimeout = new ExponentialBackoff(\n                connectionSetupTimeoutMs,\n                CONNECTION_SETUP_TIMEOUT_EXP_BASE,\n                connectionSetupTimeoutMaxMs,\n                CONNECTION_SETUP_TIMEOUT_JITTER);\n        this.nodeState = new HashMap<>();\n        this.connectingNodes = new HashSet<>();\n        this.hostResolver = hostResolver;\n    }\n\n    /**\n     * Return true iff we can currently initiate a new connection. This will be the case if we are not\n     * connected and haven't been connected for at least the minimum reconnection backoff period.\n     * @param id the connection id to check\n     * @param now the current time in ms\n     * @return true if we can initiate a new connection\n     */\n    public boolean canConnect(String id, long now) {\n        NodeConnectionState state = nodeState.get(id);\n        if (state == null)\n            return true;\n        else\n            return state.state.isDisconnected() &&\n                   now - state.lastConnectAttemptMs >= state.reconnectBackoffMs;\n    }\n\n    /**\n     * Return true if we are disconnected from the given node and can't re-establish a connection yet.\n     * @param id the connection to check\n     * @param now the current time in ms\n     */\n    public boolean isBlackedOut(String id, long now) {\n        NodeConnectionState state = nodeState.get(id);\n        return state != null\n                && state.state.isDisconnected()\n                && now - state.lastConnectAttemptMs < state.reconnectBackoffMs;\n    }\n\n    /**\n     * Returns the number of milliseconds to wait, based on the connection state, before attempting to send data. When\n     * disconnected, this respects the reconnect backoff time. When connecting, return a delay based on the connection timeout.\n     * When connected, wait indefinitely (i.e. until a wakeup).\n     * @param id the connection to check\n     * @param now the current time in ms\n     */\n    public long connectionDelay(String id, long now) {\n        NodeConnectionState state = nodeState.get(id);\n        if (state == null) return 0;\n\n        if (state.state == ConnectionState.CONNECTING) {\n            return connectionSetupTimeoutMs(id);\n        } else if (state.state.isDisconnected()) {\n            long timeWaited = now - state.lastConnectAttemptMs;\n            return Math.max(state.reconnectBackoffMs - timeWaited, 0);\n        } else {\n            // When connected, we should be able to delay indefinitely since other events (connection or\n            // data acked) will cause a wakeup once data can be sent.\n            return Long.MAX_VALUE;\n        }\n    }\n\n    /**\n     * Return true if a specific connection establishment is currently underway\n     * @param id The id of the node to check\n     */\n    public boolean isConnecting(String id) {\n        NodeConnectionState state = nodeState.get(id);\n        return state != null && state.state == ConnectionState.CONNECTING;\n    }\n\n    /**\n     * Check whether a connection is either being established or awaiting API version information.\n     * @param id The id of the node to check\n     * @return true if the node is either connecting or has connected and is awaiting API versions, false otherwise\n     */\n    public boolean isPreparingConnection(String id) {\n        NodeConnectionState state = nodeState.get(id);\n        return state != null &&\n                (state.state == ConnectionState.CONNECTING || state.state == ConnectionState.CHECKING_API_VERSIONS);\n    }\n\n    /**\n     * Enter the connecting state for the given connection, moving to a new resolved address if necessary.\n     * @param id the id of the connection\n     * @param now the current time in ms\n     * @param host the host of the connection, to be resolved internally if needed\n     */\n    public void connecting(String id, long now, String host) {\n        NodeConnectionState connectionState = nodeState.get(id);\n        if (connectionState != null && connectionState.host().equals(host)) {\n            connectionState.lastConnectAttemptMs = now;",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.577459",
  "source_type": "github"
}