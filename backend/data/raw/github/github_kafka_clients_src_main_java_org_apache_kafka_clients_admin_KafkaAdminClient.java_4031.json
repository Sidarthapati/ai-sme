{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_4031",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                    for (ReassignablePartitionResponse partResponse : topicResponse.partitions()) {\n                        Errors partitionError = Errors.forCode(partResponse.errorCode());\n\n                        TopicPartition tp = new TopicPartition(topicName, partResponse.partitionIndex());\n                        if (partitionError == Errors.NONE) {\n                            errors.put(tp, null);\n                        } else {\n                            errors.put(tp, partitionError.exception(partResponse.errorMessage()));\n                        }\n                        receivedResponsesCount += 1;\n                    }\n                }\n\n                return receivedResponsesCount;\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                for (KafkaFutureImpl<Void> future : futures.values()) {\n                    future.completeExceptionally(throwable);\n                }\n            }\n        };\n        if (!topicsToReassignments.isEmpty()) {\n            runnable.call(call, now);\n        }\n        return new AlterPartitionReassignmentsResult(new HashMap<>(futures));\n    }\n\n    @Override\n    public ListPartitionReassignmentsResult listPartitionReassignments(Optional<Set<TopicPartition>> partitions,\n                                                                       ListPartitionReassignmentsOptions options) {\n        final KafkaFutureImpl<Map<TopicPartition, PartitionReassignment>> partitionReassignmentsFuture = new KafkaFutureImpl<>();\n        if (partitions.isPresent()) {\n            for (TopicPartition tp : partitions.get()) {\n                String topic = tp.topic();\n                int partition = tp.partition();\n                if (topicNameIsUnrepresentable(topic)) {\n                    partitionReassignmentsFuture.completeExceptionally(new InvalidTopicException(\"The given topic name '\"\n                        + topic + \"' cannot be represented in a request.\"));\n                } else if (partition < 0) {\n                    partitionReassignmentsFuture.completeExceptionally(new InvalidTopicException(\"The given partition index \" +\n                        partition + \" is not valid.\"));\n                }\n                if (partitionReassignmentsFuture.isCompletedExceptionally())\n                    return new ListPartitionReassignmentsResult(partitionReassignmentsFuture);\n            }\n        }\n        final long now = time.milliseconds();\n        runnable.call(new Call(\"listPartitionReassignments\", calcDeadlineMs(now, options.timeoutMs()),\n            new ControllerNodeProvider(true)) {\n\n            @Override\n            ListPartitionReassignmentsRequest.Builder createRequest(int timeoutMs) {\n                ListPartitionReassignmentsRequestData listData = new ListPartitionReassignmentsRequestData();\n                listData.setTimeoutMs(timeoutMs);\n\n                if (partitions.isPresent()) {\n                    Map<String, ListPartitionReassignmentsTopics> reassignmentTopicByTopicName = new HashMap<>();\n\n                    for (TopicPartition tp : partitions.get()) {\n                        if (!reassignmentTopicByTopicName.containsKey(tp.topic()))\n                            reassignmentTopicByTopicName.put(tp.topic(), new ListPartitionReassignmentsTopics().setName(tp.topic()));\n\n                        reassignmentTopicByTopicName.get(tp.topic()).partitionIndexes().add(tp.partition());\n                    }\n\n                    listData.setTopics(new ArrayList<>(reassignmentTopicByTopicName.values()));\n                }\n                return new ListPartitionReassignmentsRequest.Builder(listData);\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                ListPartitionReassignmentsResponse response = (ListPartitionReassignmentsResponse) abstractResponse;\n                Errors error = Errors.forCode(response.data().errorCode());\n                switch (error) {\n                    case NONE:\n                        break;\n                    case NOT_CONTROLLER:\n                        handleNotControllerError(error);\n                        break;\n                    default:\n                        partitionReassignmentsFuture.completeExceptionally(error.exception(response.data().errorMessage()));\n                        break;\n                }\n                Map<TopicPartition, PartitionReassignment> reassignmentMap = new HashMap<>();\n\n                for (OngoingTopicReassignment topicReassignment : response.data().topics()) {\n                    String topicName = topicReassignment.name();\n                    for (OngoingPartitionReassignment partitionReassignment : topicReassignment.partitions()) {\n                        reassignmentMap.put(\n                            new TopicPartition(topicName, partitionReassignment.partitionIndex()),\n                            new PartitionReassignment(partitionReassignment.replicas(), partitionReassignment.addingReplicas(), partitionReassignment.removingReplicas())\n                        );\n                    }\n                }\n\n                partitionReassignmentsFuture.complete(reassignmentMap);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                partitionReassignmentsFuture.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new ListPartitionReassignmentsResult(partitionReassignmentsFuture);\n    }\n\n    private void handleNotControllerError(AbstractResponse response) throws ApiException {\n        // When sending requests directly to the follower controller, it might return NOT_LEADER_OR_FOLLOWER error.\n        if (response.errorCounts().containsKey(Errors.NOT_CONTROLLER)) {\n            handleNotControllerError(Errors.NOT_CONTROLLER);\n        } else if (metadataManager.usingBootstrapControllers() && response.errorCounts().containsKey(Errors.NOT_LEADER_OR_FOLLOWER)) {\n            handleNotControllerError(Errors.NOT_LEADER_OR_FOLLOWER);\n        }\n    }\n\n    private void handleNotControllerError(Errors error) throws ApiException {\n        metadataManager.clearController();\n        metadataManager.requestUpdate();\n        throw error.exception();\n    }\n\n    /**\n     * Returns the broker id pertaining to the given resource, or null if the resource is not associated\n     * with a particular broker.\n     */\n    private Integer nodeFor(ConfigResource resource) {\n        if ((resource.type() == ConfigResource.Type.BROKER && !resource.isDefault())\n            || resource.type() == ConfigResource.Type.BROKER_LOGGER) {\n            return Integer.valueOf(resource.name());\n        } else {\n            return null;\n        }\n    }\n\n    private KafkaFutureImpl<List<MemberIdentity>> getMembersFromGroup(String groupId, String reason) {\n        KafkaFutureImpl<List<MemberIdentity>> future = new KafkaFutureImpl<>();\n\n        describeConsumerGroups(Collections.singleton(groupId)).describedGroups().get(groupId).whenComplete((res, ex) -> {\n            if (ex != null) {\n                future.completeExceptionally(new KafkaException(\"Encounter exception when trying to get members from group: \" + groupId, ex));\n            } else {\n                List<MemberIdentity> membersToRemove = res.members().stream().map(member ->\n                    member.groupInstanceId().map(id -> new MemberIdentity().setGroupInstanceId(id))\n                        .orElseGet(() -> new MemberIdentity().setMemberId(member.consumerId()))\n                        .setReason(reason)\n                ).collect(Collectors.toList());",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L4031-L4180",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 4031,
  "end_line": 4180,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}