{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_ProduceRequestResult.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProduceRequestResult.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.record.RecordBatch;\n\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.TimeUnit;\nimport java.util.function.Function;\n\n/**\n * A class that models the future completion of a produce request for a single partition. There is one of these per\n * partition in a produce request and it is shared by all the {@link RecordMetadata} instances that are batched together\n * for the same partition in the request.\n */\npublic class ProduceRequestResult {\n\n    private final CountDownLatch latch = new CountDownLatch(1);\n    private final TopicPartition topicPartition;\n\n    /**\n     * List of dependent ProduceRequestResults created when this batch is split.\n     * When a batch is too large to send, it's split into multiple smaller batches.\n     * The original batch's ProduceRequestResult tracks all the split batches here\n     * so that flush() can wait for all splits to complete via awaitAllDependents().\n     */\n    private final List<ProduceRequestResult> dependentResults = new ArrayList<>();\n\n    private volatile Long baseOffset = null;\n    private volatile long logAppendTime = RecordBatch.NO_TIMESTAMP;\n    private volatile Function<Integer, RuntimeException> errorsByIndex;\n\n    /**\n     * Create an instance of this class.\n     *\n     * @param topicPartition The topic and partition to which this record set was sent\n     */\n    public ProduceRequestResult(TopicPartition topicPartition) {\n        this.topicPartition = topicPartition;\n    }\n\n    /**\n     * Set the result of the produce request.\n     *\n     * @param baseOffset The base offset assigned to the record\n     * @param logAppendTime The log append time or -1 if CreateTime is being used\n     * @param errorsByIndex Function mapping the batch index to the exception, or null if the response was successful\n     */\n    public void set(long baseOffset, long logAppendTime, Function<Integer, RuntimeException> errorsByIndex) {\n        this.baseOffset = baseOffset;\n        this.logAppendTime = logAppendTime;\n        this.errorsByIndex = errorsByIndex;\n    }\n\n    /**\n     * Mark this request as complete and unblock any threads waiting on its completion.\n     */\n    public void done() {\n        if (baseOffset == null)\n            throw new IllegalStateException(\"The method `set` must be invoked before this method.\");\n        this.latch.countDown();\n    }\n\n    /**\n     * Add a dependent ProduceRequestResult.\n     * This is used when a batch is split into multiple batches - in some cases like flush(), the original\n     * batch's result should not complete until all split batches have completed.\n     *\n     * @param dependentResult The dependent result to wait for\n     */\n    public void addDependent(ProduceRequestResult dependentResult) {\n        synchronized (dependentResults) {\n            dependentResults.add(dependentResult);\n        }\n    }\n\n    /**\n     * Await the completion of this request.\n     *\n     * This only waits for THIS request's latch and not dependent results.\n     * When a batch is split into multiple batches, dependent results are created and tracked\n     * separately, but this method does not wait for them. Individual record futures automatically\n     * handle waiting for their respective split batch via {@link FutureRecordMetadata#chain(FutureRecordMetadata)},\n     * which redirects the future to point to the correct split batch's result.\n     *\n     * For flush() semantics that require waiting for all dependent results, use\n     * {@link #awaitAllDependents()}.\n     */\n    public void await() throws InterruptedException {\n        latch.await();\n    }\n\n    /**\n     * Await the completion of this request (up to the given time interval)\n     * @param timeout The maximum time to wait\n     * @param unit The unit for the max time\n     * @return true if the request completed, false if we timed out\n     */\n    public boolean await(long timeout, TimeUnit unit) throws InterruptedException {\n        return latch.await(timeout, unit);\n    }\n\n    /**\n     * Await the completion of this request and all the dependent requests.\n     *\n     * This method is used by flush() to ensure all split batches have completed before\n     * returning. This method waits for all dependent {@link ProduceRequestResult}s that\n     * were created when the batch was split.\n     *\n     * @throws InterruptedException if the thread is interrupted while waiting\n     */\n    public void awaitAllDependents() throws InterruptedException {\n        Queue<ProduceRequestResult> toWait = new ArrayDeque<>();\n        toWait.add(this);\n\n        while (!toWait.isEmpty()) {\n            ProduceRequestResult current = toWait.poll();\n\n            // first wait for THIS result's latch to be released\n            current.latch.await();\n\n            // add all dependent split batches to the queue.\n            // we synchronize to get a consistent snapshot, then release the lock\n            // before continuing but the actual waiting happens outside the lock.\n            synchronized (current.dependentResults) {\n                toWait.addAll(current.dependentResults);\n            }\n        }\n    }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProduceRequestResult.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/ProduceRequestResult.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.609602",
  "source_type": "github"
}