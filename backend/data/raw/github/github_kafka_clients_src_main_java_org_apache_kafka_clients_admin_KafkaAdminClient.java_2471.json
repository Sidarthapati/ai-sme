{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_2471",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "            AbstractRequest.Builder<?> createRequest(int timeoutMs) {\n                if (!useMetadataRequest) {\n                    if (metadataManager.usingBootstrapControllers() && options.includeFencedBrokers()) {\n                        throw new IllegalArgumentException(\"Cannot request fenced brokers from controller endpoint\");\n                    }\n                    return new DescribeClusterRequest.Builder(new DescribeClusterRequestData()\n                        .setIncludeClusterAuthorizedOperations(options.includeAuthorizedOperations())\n                        .setEndpointType(metadataManager.usingBootstrapControllers() ?\n                            EndpointType.CONTROLLER.id() : EndpointType.BROKER.id())\n                        .setIncludeFencedBrokers(options.includeFencedBrokers()));\n                } else {\n                    // Since this only requests node information, it's safe to pass true for allowAutoTopicCreation (and it\n                    // simplifies communication with older brokers)\n                    return new MetadataRequest.Builder(new MetadataRequestData()\n                        .setTopics(Collections.emptyList())\n                        .setAllowAutoTopicCreation(true)\n                        .setIncludeClusterAuthorizedOperations(\n                            options.includeAuthorizedOperations()));\n                }\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                if (!useMetadataRequest) {\n                    DescribeClusterResponse response = (DescribeClusterResponse) abstractResponse;\n                    Errors error = Errors.forCode(response.data().errorCode());\n                    if (error != Errors.NONE) {\n                        handleFailure(error.exception(response.data().errorMessage()));\n                        return;\n                    }\n\n                    Map<Integer, Node> nodes = response.nodes();\n                    describeClusterFuture.complete(nodes.values());\n                    // Controller is null if controller id is equal to NO_CONTROLLER_ID\n                    controllerFuture.complete(nodes.get(response.data().controllerId()));\n                    clusterIdFuture.complete(response.data().clusterId());\n                    authorizedOperationsFuture.complete(\n                        validAclOperations(response.data().clusterAuthorizedOperations()));\n                } else {\n                    MetadataResponse response = (MetadataResponse) abstractResponse;\n                    describeClusterFuture.complete(response.brokers());\n                    controllerFuture.complete(controller(response));\n                    clusterIdFuture.complete(response.clusterId());\n                    authorizedOperationsFuture.complete(\n                        validAclOperations(response.clusterAuthorizedOperations()));\n                }\n            }\n\n            private Node controller(MetadataResponse response) {\n                if (response.controller() == null || response.controller().id() == MetadataResponse.NO_CONTROLLER_ID)\n                    return null;\n                return response.controller();\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                describeClusterFuture.completeExceptionally(throwable);\n                controllerFuture.completeExceptionally(throwable);\n                clusterIdFuture.completeExceptionally(throwable);\n                authorizedOperationsFuture.completeExceptionally(throwable);\n            }\n\n            @Override\n            boolean handleUnsupportedVersionException(final UnsupportedVersionException exception) {\n                if (metadataManager.usingBootstrapControllers()) {\n                    return false;\n                }\n                if (useMetadataRequest) {\n                    return false;\n                }\n\n                // If unsupportedVersion exception was caused by the option to include fenced brokers (only supported for version 2+)\n                // then we should not fall back to the metadataRequest.\n                if (options.includeFencedBrokers()) {\n                    return false;\n                }\n\n                useMetadataRequest = true;\n                return true;\n            }\n        }, now);\n\n        return new DescribeClusterResult(describeClusterFuture, controllerFuture, clusterIdFuture,\n            authorizedOperationsFuture);\n    }\n\n    @Override\n    public DescribeAclsResult describeAcls(final AclBindingFilter filter, DescribeAclsOptions options) {\n        if (filter.isUnknown()) {\n            KafkaFutureImpl<Collection<AclBinding>> future = new KafkaFutureImpl<>();\n            future.completeExceptionally(new InvalidRequestException(\"The AclBindingFilter \" +\n                \"must not contain UNKNOWN elements.\"));\n            return new DescribeAclsResult(future);\n        }\n        final long now = time.milliseconds();\n        final KafkaFutureImpl<Collection<AclBinding>> future = new KafkaFutureImpl<>();\n        runnable.call(new Call(\"describeAcls\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedBrokerOrActiveKController()) {\n\n            @Override\n            DescribeAclsRequest.Builder createRequest(int timeoutMs) {\n                return new DescribeAclsRequest.Builder(filter);\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                DescribeAclsResponse response = (DescribeAclsResponse) abstractResponse;\n                if (response.error().isFailure()) {\n                    future.completeExceptionally(response.error().exception());\n                } else {\n                    future.complete(DescribeAclsResponse.aclBindings(response.acls()));\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        }, now);\n        return new DescribeAclsResult(future);\n    }\n\n    @Override\n    public CreateAclsResult createAcls(Collection<AclBinding> acls, CreateAclsOptions options) {\n        final long now = time.milliseconds();\n        final Map<AclBinding, KafkaFutureImpl<Void>> futures = new HashMap<>();\n        final List<AclCreation> aclCreations = new ArrayList<>();\n        final List<AclBinding> aclBindingsSent = new ArrayList<>();\n        for (AclBinding acl : acls) {\n            if (futures.get(acl) == null) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                futures.put(acl, future);\n                String indefinite = acl.toFilter().findIndefiniteField();\n                if (indefinite == null) {\n                    aclCreations.add(CreateAclsRequest.aclCreation(acl));\n                    aclBindingsSent.add(acl);\n                } else {\n                    future.completeExceptionally(new InvalidRequestException(\"Invalid ACL creation: \" +\n                        indefinite));\n                }\n            }\n        }\n        final CreateAclsRequestData data = new CreateAclsRequestData().setCreations(aclCreations);\n        runnable.call(new Call(\"createAcls\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedBrokerOrActiveKController()) {\n\n            @Override\n            CreateAclsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateAclsRequest.Builder(data);\n            }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2471-L2620",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 2471,
  "end_line": 2620,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}