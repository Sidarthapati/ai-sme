{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_781",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "\n            if (canSendRequest(node.idString(), now)) {\n                int currInflight = this.inFlightRequests.count(node.idString());\n                if (currInflight == 0) {\n                    // if we find an established connection with no in-flight requests we can stop right away\n                    log.trace(\"Found least loaded node {} connected with no in-flight requests\", node);\n                    return new LeastLoadedNode(node, true);\n                } else if (currInflight < inflight) {\n                    // otherwise if this is the best we have found so far, record that\n                    inflight = currInflight;\n                    foundReady = node;\n                }\n            } else if (connectionStates.isPreparingConnection(node.idString())) {\n                foundConnecting = node;\n            } else if (canConnect(node, now)) {\n                if (foundCanConnect == null ||\n                        this.connectionStates.lastConnectAttemptMs(foundCanConnect.idString()) >\n                                this.connectionStates.lastConnectAttemptMs(node.idString())) {\n                    foundCanConnect = node;\n                }\n            } else {\n                log.trace(\"Removing node {} from least loaded node selection since it is neither ready \" +\n                        \"for sending or connecting\", node);\n            }\n        }\n\n        // We prefer established connections if possible. Otherwise, we will wait for connections\n        // which are being established before connecting to new nodes.\n        if (foundReady != null) {\n            log.trace(\"Found least loaded node {} with {} inflight requests\", foundReady, inflight);\n            return new LeastLoadedNode(foundReady, atLeastOneConnectionReady);\n        } else if (foundConnecting != null) {\n            log.trace(\"Found least loaded connecting node {}\", foundConnecting);\n            return new LeastLoadedNode(foundConnecting, atLeastOneConnectionReady);\n        } else if (foundCanConnect != null) {\n            log.trace(\"Found least loaded node {} with no active connection\", foundCanConnect);\n            return new LeastLoadedNode(foundCanConnect, atLeastOneConnectionReady);\n        } else {\n            log.trace(\"Least loaded node selection failed to find an available node\");\n            return new LeastLoadedNode(null, atLeastOneConnectionReady);\n        }\n    }\n\n    public static AbstractResponse parseResponse(ByteBuffer responseBuffer, RequestHeader requestHeader) {\n        try {\n            return AbstractResponse.parseResponse(responseBuffer, requestHeader);\n        } catch (BufferUnderflowException e) {\n            throw new SchemaException(\"Buffer underflow while parsing response for request with header \" + requestHeader, e);\n        } catch (CorrelationIdMismatchException e) {\n            if (SaslClientAuthenticator.isReserved(requestHeader.correlationId())\n                && !SaslClientAuthenticator.isReserved(e.responseCorrelationId()))\n                throw new SchemaException(\"The response is unrelated to Sasl request since its correlation id is \"\n                    + e.responseCorrelationId() + \" and the reserved range for Sasl request is [ \"\n                    + SaslClientAuthenticator.MIN_RESERVED_CORRELATION_ID + \",\"\n                    + SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + \"]\");\n            else {\n                throw e;\n            }\n        }\n    }\n\n    /**\n     * Post process disconnection of a node\n     *\n     * @param responses The list of responses to update\n     * @param nodeId Id of the node to be disconnected\n     * @param now The current time\n     * @param disconnectState The state of the disconnected channel\n     */\n    private void processDisconnection(List<ClientResponse> responses,\n                                      String nodeId,\n                                      long now,\n                                      ChannelState disconnectState) {\n        processDisconnection(responses, nodeId, now, disconnectState, false);\n    }\n\n    /**\n     * Post process disconnection of a node\n     *\n     * @param responses The list of responses to update\n     * @param nodeId Id of the node to be disconnected\n     * @param now The current time\n     */\n    private void processTimeoutDisconnection(List<ClientResponse> responses, String nodeId, long now) {\n        processDisconnection(responses, nodeId, now, ChannelState.LOCAL_CLOSE, true);\n    }\n\n    /**\n     * Post process disconnection of a node\n     *\n     * @param responses The list of responses to update\n     * @param nodeId Id of the node to be disconnected\n     * @param now The current time\n     * @param disconnectState The state of the disconnected channel\n     * @param timedOut {@code true} if the connection is disconnected because of a timeout (request or connection)\n     */\n    private void processDisconnection(List<ClientResponse> responses,\n                                      String nodeId,\n                                      long now,\n                                      ChannelState disconnectState,\n                                      boolean timedOut) {\n        connectionStates.disconnected(nodeId, now);\n        apiVersions.remove(nodeId);\n        nodesNeedingApiVersionsFetch.remove(nodeId);\n        switch (disconnectState.state()) {\n            case AUTHENTICATION_FAILED:\n                AuthenticationException exception = disconnectState.exception();\n                connectionStates.authenticationFailed(nodeId, now, exception);\n                log.error(\"Connection to node {} ({}) failed authentication due to: {}\", nodeId,\n                    disconnectState.remoteAddress(), exception.getMessage());\n                break;\n            case AUTHENTICATE:\n                log.warn(\"Connection to node {} ({}) terminated during authentication. This may happen \" +\n                    \"due to any of the following reasons: (1) Firewall blocking Kafka TLS \" +\n                    \"traffic (eg it may only allow HTTPS traffic), (2) Transient network issue.\",\n                    nodeId, disconnectState.remoteAddress());\n                break;\n            case NOT_CONNECTED:\n                log.warn(\"Connection to node {} ({}) could not be established. Node may not be available.\", nodeId, disconnectState.remoteAddress());\n                break;\n            default:\n                break; // Disconnections in other states are logged at debug level in Selector\n        }\n\n        cancelInFlightRequests(nodeId, now, responses, timedOut);\n        metadataUpdater.handleServerDisconnect(now, nodeId, Optional.ofNullable(disconnectState.exception()));\n    }\n\n    /**\n     * Iterate over all the inflight requests and expire any requests that have exceeded the configured requestTimeout.\n     * The connection to the node associated with the request will be terminated and will be treated as a disconnection.\n     *\n     * @param responses The list of responses to update\n     * @param now The current time\n     */\n    private void handleTimedOutRequests(List<ClientResponse> responses, long now) {\n        List<String> nodeIds = this.inFlightRequests.nodesWithTimedOutRequests(now);\n        for (String nodeId : nodeIds) {\n            // close connection to the node\n            this.selector.close(nodeId);\n            log.info(\"Disconnecting from node {} due to request timeout.\", nodeId);\n            processTimeoutDisconnection(responses, nodeId, now);\n        }\n    }\n\n    private void handleAbortedSends(List<ClientResponse> responses) {\n        responses.addAll(abortedSends);\n        abortedSends.clear();\n    }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L781-L930",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 781,
  "end_line": 930,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}