{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_FetchSessionHandler.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "content": "\n        /**\n         * Mark that we want data from this partition in the upcoming fetch.\n         */\n        public void add(TopicPartition topicPartition, PartitionData data) {\n            next.put(topicPartition, data);\n            // topicIds should not change between adding partitions and building, so we can use putIfAbsent\n            if (data.topicId.equals(Uuid.ZERO_UUID)) {\n                partitionsWithoutTopicIds++;\n            } else {\n                topicNames.putIfAbsent(data.topicId, topicPartition.topic());\n            }\n        }\n\n        public FetchRequestData build() {\n            boolean canUseTopicIds = partitionsWithoutTopicIds == 0;\n\n            if (nextMetadata.isFull()) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Built full fetch {} for node {} with {}.\",\n                            nextMetadata, node, topicPartitionsToLogString(next.keySet()));\n                }\n                sessionPartitions = next;\n                next = null;\n                // Only add topic IDs to the session if we are using topic IDs.\n                if (canUseTopicIds) {\n                    sessionTopicNames = topicNames;\n                } else {\n                    sessionTopicNames = Collections.emptyMap();\n                }\n                Map<TopicPartition, PartitionData> toSend =\n                        Collections.unmodifiableMap(new LinkedHashMap<>(sessionPartitions));\n                return new FetchRequestData(toSend, Collections.emptyList(), Collections.emptyList(), toSend, nextMetadata, canUseTopicIds);\n            }\n\n            List<TopicIdPartition> added = new ArrayList<>();\n            List<TopicIdPartition> removed = new ArrayList<>();\n            List<TopicIdPartition> altered = new ArrayList<>();\n            List<TopicIdPartition> replaced = new ArrayList<>();\n            for (Iterator<Entry<TopicPartition, PartitionData>> iter =\n                 sessionPartitions.entrySet().iterator(); iter.hasNext(); ) {\n                Entry<TopicPartition, PartitionData> entry = iter.next();\n                TopicPartition topicPartition = entry.getKey();\n                PartitionData prevData = entry.getValue();\n                PartitionData nextData = next.remove(topicPartition);\n                if (nextData != null) {\n                    // We basically check if the new partition had the same topic ID. If not,\n                    // we add it to the \"replaced\" set. If the request is version 13 or higher, the replaced\n                    // partition will be forgotten. In any case, we will send the new partition in the request.\n                    if (!prevData.topicId.equals(nextData.topicId)\n                            && !prevData.topicId.equals(Uuid.ZERO_UUID)\n                            && !nextData.topicId.equals(Uuid.ZERO_UUID)) {\n                        // Re-add the replaced partition to the end of 'next'\n                        next.put(topicPartition, nextData);\n                        entry.setValue(nextData);\n                        replaced.add(new TopicIdPartition(prevData.topicId, topicPartition));\n                    } else if (!prevData.equals(nextData)) {\n                        // Re-add the altered partition to the end of 'next'\n                        next.put(topicPartition, nextData);\n                        entry.setValue(nextData);\n                        altered.add(new TopicIdPartition(nextData.topicId, topicPartition));\n                    }\n                } else {\n                    // Remove this partition from the session.\n                    iter.remove();\n                    // Indicate that we no longer want to listen to this partition.\n                    removed.add(new TopicIdPartition(prevData.topicId, topicPartition));\n                    // If we do not have this topic ID in the builder or the session, we can not use topic IDs.\n                    if (canUseTopicIds && prevData.topicId.equals(Uuid.ZERO_UUID))\n                        canUseTopicIds = false;\n                }\n            }\n            // Add any new partitions to the session.\n            for (Entry<TopicPartition, PartitionData> entry : next.entrySet()) {\n                TopicPartition topicPartition = entry.getKey();\n                PartitionData nextData = entry.getValue();\n                if (sessionPartitions.containsKey(topicPartition)) {\n                    // In the previous loop, all the partitions which existed in both sessionPartitions\n                    // and next were moved to the end of next, or removed from next.  Therefore,\n                    // once we hit one of them, we know there are no more unseen entries to look\n                    // at in next.\n                    break;\n                }\n                sessionPartitions.put(topicPartition, nextData);\n                added.add(new TopicIdPartition(nextData.topicId, topicPartition));\n            }\n\n            // Add topic IDs to session if we can use them. If an ID is inconsistent, we will handle in the receiving broker.\n            // If we switched from using topic IDs to not using them (or vice versa), that error will also be handled in the receiving broker.\n            if (canUseTopicIds) {\n                sessionTopicNames = topicNames;\n            } else {\n                sessionTopicNames = Collections.emptyMap();\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"Built incremental fetch {} for node {}. Added {}, altered {}, removed {}, \" +\n                          \"replaced {} out of {}\", nextMetadata, node, topicIdPartitionsToLogString(added),\n                          topicIdPartitionsToLogString(altered), topicIdPartitionsToLogString(removed),\n                          topicIdPartitionsToLogString(replaced), topicPartitionsToLogString(sessionPartitions.keySet()));\n            }\n            Map<TopicPartition, PartitionData> toSend = Collections.unmodifiableMap(next);\n            Map<TopicPartition, PartitionData> curSessionPartitions = copySessionPartitions\n                    ? Collections.unmodifiableMap(new LinkedHashMap<>(sessionPartitions))\n                    : Collections.unmodifiableMap(sessionPartitions);\n            next = null;\n            return new FetchRequestData(toSend,\n                    Collections.unmodifiableList(removed),\n                    Collections.unmodifiableList(replaced),\n                    curSessionPartitions,\n                    nextMetadata,\n                    canUseTopicIds);\n        }\n    }\n\n    public Builder newBuilder() {\n        return new Builder();\n    }\n\n\n    /** A builder that allows for presizing the PartitionData hashmap, and avoiding making a\n     *  secondary copy of the sessionPartitions, in cases where this is not necessarily.\n     *  This builder is primarily for use by the Replica Fetcher\n     * @param size the initial size of the PartitionData hashmap\n     * @param copySessionPartitions boolean denoting whether the builder should make a deep copy of\n     *                              session partitions\n     */\n    public Builder newBuilder(int size, boolean copySessionPartitions) {\n        return new Builder(size, copySessionPartitions);\n    }\n\n    private String topicPartitionsToLogString(Collection<TopicPartition> partitions) {\n        if (!log.isTraceEnabled()) {\n            return String.format(\"%d partition(s)\", partitions.size());\n        }\n        return \"(\" + partitions.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \")) + \")\";\n    }\n\n    private String topicIdPartitionsToLogString(Collection<TopicIdPartition> partitions) {\n        if (!log.isTraceEnabled()) {\n            return String.format(\"%d partition(s)\", partitions.size());\n        }\n        return \"(\" + partitions.stream().map(TopicIdPartition::toString).collect(Collectors.joining(\", \")) + \")\";\n    }\n\n    /**\n     * Return missing items which are expected to be in a particular set, but which are not.\n     *\n     * @param toFind    The items to look for.\n     * @param toSearch  The set of items to search.",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.577970",
  "source_type": "github"
}