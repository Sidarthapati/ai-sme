{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_3381",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                expiryTimeFuture.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new ExpireDelegationTokenResult(expiryTimeFuture);\n    }\n\n    @Override\n    public DescribeDelegationTokenResult describeDelegationToken(final DescribeDelegationTokenOptions options) {\n        final KafkaFutureImpl<List<DelegationToken>> tokensFuture = new KafkaFutureImpl<>();\n        final long now = time.milliseconds();\n        runnable.call(new Call(\"describeDelegationToken\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedNodeProvider()) {\n\n            @Override\n            DescribeDelegationTokenRequest.Builder createRequest(int timeoutMs) {\n                return new DescribeDelegationTokenRequest.Builder(options.owners());\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                DescribeDelegationTokenResponse response = (DescribeDelegationTokenResponse) abstractResponse;\n                if (response.hasError()) {\n                    tokensFuture.completeExceptionally(response.error().exception());\n                } else {\n                    tokensFuture.complete(response.tokens());\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                tokensFuture.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new DescribeDelegationTokenResult(tokensFuture);\n    }\n\n    private static final class ListGroupsResults {\n        private final List<Throwable> errors;\n        private final HashMap<String, GroupListing> listings;\n        private final HashSet<Node> remaining;\n        private final KafkaFutureImpl<Collection<Object>> future;\n\n        ListGroupsResults(Collection<Node> leaders,\n                          KafkaFutureImpl<Collection<Object>> future) {\n            this.errors = new ArrayList<>();\n            this.listings = new HashMap<>();\n            this.remaining = new HashSet<>(leaders);\n            this.future = future;\n            tryComplete();\n        }\n\n        synchronized void addError(Throwable throwable, Node node) {\n            ApiError error = ApiError.fromThrowable(throwable);\n            if (error.message() == null || error.message().isEmpty()) {\n                errors.add(error.error().exception(\"Error listing groups on \" + node));\n            } else {\n                errors.add(error.error().exception(\"Error listing groups on \" + node + \": \" + error.message()));\n            }\n        }\n\n        synchronized void addListing(GroupListing listing) {\n            listings.put(listing.groupId(), listing);\n        }\n\n        synchronized void tryComplete(Node leader) {\n            remaining.remove(leader);\n            tryComplete();\n        }\n\n        private synchronized void tryComplete() {\n            if (remaining.isEmpty()) {\n                ArrayList<Object> results = new ArrayList<>(listings.values());\n                results.addAll(errors);\n                future.complete(results);\n            }\n        }\n    }\n\n    @Override\n    public ListGroupsResult listGroups(ListGroupsOptions options) {\n        final KafkaFutureImpl<Collection<Object>> all = new KafkaFutureImpl<>();\n        final long nowMetadata = time.milliseconds();\n        final long deadline = calcDeadlineMs(nowMetadata, options.timeoutMs());\n        runnable.call(new Call(\"findAllBrokers\", deadline, new LeastLoadedNodeProvider()) {\n            @Override\n            MetadataRequest.Builder createRequest(int timeoutMs) {\n                return new MetadataRequest.Builder(new MetadataRequestData()\n                    .setTopics(Collections.emptyList())\n                    .setAllowAutoTopicCreation(true));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                MetadataResponse metadataResponse = (MetadataResponse) abstractResponse;\n                Collection<Node> nodes = metadataResponse.brokers();\n                if (nodes.isEmpty())\n                    throw new StaleMetadataException(\"Metadata fetch failed due to missing broker list\");\n\n                HashSet<Node> allNodes = new HashSet<>(nodes);\n                final ListGroupsResults results = new ListGroupsResults(allNodes, all);\n\n                for (final Node node : allNodes) {\n                    final long nowList = time.milliseconds();\n                    runnable.call(new Call(\"listGroups\", deadline, new ConstantNodeIdProvider(node.id())) {\n                        @Override\n                        ListGroupsRequest.Builder createRequest(int timeoutMs) {\n                            List<String> groupTypes = options.types()\n                                .stream()\n                                .map(GroupType::toString)\n                                .collect(Collectors.toList());\n                            List<String> groupStates = options.groupStates()\n                                .stream()\n                                .map(GroupState::toString)\n                                .collect(Collectors.toList());\n                            return new ListGroupsRequest.Builder(new ListGroupsRequestData()\n                                .setTypesFilter(groupTypes)\n                                .setStatesFilter(groupStates)\n                            );\n                        }\n\n                        private void maybeAddGroup(ListGroupsResponseData.ListedGroup group) {\n                            String protocolType = group.protocolType();\n                            if (options.protocolTypes().isEmpty() || options.protocolTypes().contains(protocolType)) {\n                                final String groupId = group.groupId();\n                                final Optional<GroupType> type;\n                                if (group.groupType() == null || group.groupType().isEmpty()) {\n                                    type = Optional.empty();\n                                } else {\n                                    type = Optional.of(GroupType.parse(group.groupType()));\n                                }\n                                final Optional<GroupState> groupState;\n                                if (group.groupState() == null || group.groupState().isEmpty()) {\n                                    groupState = Optional.empty();\n                                } else {\n                                    groupState = Optional.of(GroupState.parse(group.groupState()));\n                                }\n                                final GroupListing groupListing = new GroupListing(\n                                    groupId,\n                                    type,\n                                    protocolType,\n                                    groupState\n                                );\n                                results.addListing(groupListing);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3381-L3530",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 3381,
  "end_line": 3530,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}