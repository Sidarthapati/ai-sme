{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TxnPartitionEntry.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TxnPartitionEntry.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.record.DefaultRecordBatch;\nimport org.apache.kafka.common.requests.ProduceResponse;\nimport org.apache.kafka.common.utils.PrimitiveRef;\nimport org.apache.kafka.common.utils.ProducerIdAndEpoch;\n\nimport java.util.Comparator;\nimport java.util.OptionalInt;\nimport java.util.OptionalLong;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.function.Consumer;\n\nclass TxnPartitionEntry {\n    static final int NO_LAST_ACKED_SEQUENCE_NUMBER = -1;\n\n    private final TopicPartition topicPartition;\n\n    // The producer id/epoch being used for a given partition.\n    private ProducerIdAndEpoch producerIdAndEpoch;\n\n    // The base sequence of the next batch bound for a given partition.\n    private int nextSequence;\n\n    // The sequence number of the last record of the last ack'd batch from the given partition. When there are no\n    // in flight requests for a partition, the lastAckedSequence(topicPartition) == nextSequence(topicPartition) - 1.\n    private int lastAckedSequence;\n\n    // Keep track of the in flight batches bound for a partition, ordered by sequence. This helps us to ensure that\n    // we continue to order batches by the sequence numbers even when the responses come back out of order during\n    // leader failover. We add a batch to the queue when it is drained, and remove it when the batch completes\n    // (either successfully or through a fatal failure).\n    private SortedSet<ProducerBatch> inflightBatchesBySequence;\n\n    // We keep track of the last acknowledged offset on a per partition basis in order to disambiguate UnknownProducer\n    // responses which are due to the retention period elapsing, and those which are due to actual lost data.\n    private long lastAckedOffset;\n\n    // `inflightBatchesBySequence` should only have batches with the same producer id and producer\n    // epoch, but there is an edge case where we may remove the wrong batch if the comparator\n    // only takes `baseSequence` into account.\n    // See https://github.com/apache/kafka/pull/12096#pullrequestreview-955554191 for details.\n    private static final Comparator<ProducerBatch> PRODUCER_BATCH_COMPARATOR =\n        Comparator.comparingLong(ProducerBatch::producerId)\n            .thenComparingInt(ProducerBatch::producerEpoch)\n            .thenComparingInt(ProducerBatch::baseSequence);\n\n    TxnPartitionEntry(TopicPartition topicPartition) {\n        this.topicPartition = topicPartition;\n        this.producerIdAndEpoch = ProducerIdAndEpoch.NONE;\n        this.nextSequence = 0;\n        this.lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER;\n        this.lastAckedOffset = ProduceResponse.INVALID_OFFSET;\n        this.inflightBatchesBySequence = new TreeSet<>(PRODUCER_BATCH_COMPARATOR);\n    }\n\n    ProducerIdAndEpoch producerIdAndEpoch() {\n        return producerIdAndEpoch;\n    }\n\n    int nextSequence() {\n        return nextSequence;\n    }\n\n    OptionalLong lastAckedOffset() {\n        if (lastAckedOffset != ProduceResponse.INVALID_OFFSET)\n            return OptionalLong.of(lastAckedOffset);\n        return OptionalLong.empty();\n    }\n\n    OptionalInt lastAckedSequence() {\n        if (lastAckedSequence != TxnPartitionEntry.NO_LAST_ACKED_SEQUENCE_NUMBER)\n            return OptionalInt.of(lastAckedSequence);\n        return OptionalInt.empty();\n    }\n\n    boolean hasInflightBatches() {\n        return !inflightBatchesBySequence.isEmpty();\n    }\n\n    ProducerBatch nextBatchBySequence() {\n        return inflightBatchesBySequence.isEmpty() ? null : inflightBatchesBySequence.first();\n    }\n\n    void incrementSequence(int increment) {\n        this.nextSequence = DefaultRecordBatch.incrementSequence(this.nextSequence, increment);\n    }\n\n    void addInflightBatch(ProducerBatch batch) {\n        inflightBatchesBySequence.add(batch);\n    }\n\n    void setLastAckedOffset(long lastAckedOffset) {\n        this.lastAckedOffset = lastAckedOffset;\n    }\n\n    void startSequencesAtBeginning(ProducerIdAndEpoch newProducerIdAndEpoch) {\n        final PrimitiveRef.IntRef sequence = PrimitiveRef.ofInt(0);\n        resetSequenceNumbers(inFlightBatch -> {\n            inFlightBatch.resetProducerState(newProducerIdAndEpoch, sequence.value);\n            sequence.value += inFlightBatch.recordCount;\n        });\n        producerIdAndEpoch = newProducerIdAndEpoch;\n        nextSequence = sequence.value;\n        lastAckedSequence = NO_LAST_ACKED_SEQUENCE_NUMBER;\n    }\n\n    int maybeUpdateLastAckedSequence(int sequence) {\n        if (sequence > lastAckedSequence) {\n            lastAckedSequence = sequence;\n            return sequence;\n        }\n        return lastAckedSequence;\n    }\n\n    void removeInFlightBatch(ProducerBatch batch) {\n        inflightBatchesBySequence.remove(batch);\n    }\n\n    void adjustSequencesDueToFailedBatch(long baseSequence, int recordCount) {\n        decrementSequence(recordCount);\n        resetSequenceNumbers(inFlightBatch -> {\n            if (inFlightBatch.baseSequence() < baseSequence)\n                return;\n\n            int newSequence = inFlightBatch.baseSequence() - recordCount;\n            if (newSequence < 0)\n                throw new IllegalStateException(\"Sequence number for batch with sequence \" + inFlightBatch.baseSequence()\n                        + \" for partition \" + topicPartition + \" is going to become negative: \" + newSequence);\n\n            inFlightBatch.resetProducerState(new ProducerIdAndEpoch(inFlightBatch.producerId(), inFlightBatch.producerEpoch()), newSequence);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TxnPartitionEntry.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TxnPartitionEntry.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.610643",
  "source_type": "github"
}