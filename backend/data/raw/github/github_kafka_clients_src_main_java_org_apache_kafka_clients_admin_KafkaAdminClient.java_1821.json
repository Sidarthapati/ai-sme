{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1821",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(\n                                    Errors.forCode(result.topicConfigErrorCode()).exception());\n                            } else if (result.numPartitions() == CreateTopicsResult.UNKNOWN) {\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(new UnsupportedVersionException(\n                                    \"Topic metadata and configs in CreateTopics response not supported\"));\n                            } else {\n                                List<CreatableTopicConfigs> configs = result.configs();\n                                Config topicConfig = new Config(configs.stream()\n                                    .map(this::configEntry)\n                                    .collect(Collectors.toSet()));\n                                topicMetadataAndConfig = new TopicMetadataAndConfig(result.topicId(), result.numPartitions(),\n                                    result.replicationFactor(),\n                                    topicConfig);\n                            }\n                            future.complete(topicMetadataAndConfig);\n                        }\n                    }\n                }\n                // If there are topics to retry, retry them; complete unrealized futures otherwise.\n                if (retryTopics.isEmpty()) {\n                    // The server should send back a response for every topic. But do a sanity check anyway.\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getCreateTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            private ConfigEntry configEntry(CreatableTopicConfigs config) {\n                return new ConfigEntry(\n                    config.name(),\n                    config.value(),\n                    configSource(DescribeConfigsResponse.ConfigSource.forId(config.configSource())),\n                    config.isSensitive(),\n                    config.readOnly(),\n                    Collections.emptyList(),\n                    null,\n                    null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                // If there were any topics retries due to a quota exceeded exception, we propagate\n                // the initial error back to the caller if the request timed out.\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                // Fail all the other remaining futures\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n\n    @Override\n    public DeleteTopicsResult deleteTopics(final TopicCollection topics,\n                                           final DeleteTopicsOptions options) {\n        if (topics instanceof TopicIdCollection)\n            return DeleteTopicsResult.ofTopicIds(handleDeleteTopicsUsingIds(((TopicIdCollection) topics).topicIds(), options));\n        else if (topics instanceof TopicNameCollection)\n            return DeleteTopicsResult.ofTopicNames(handleDeleteTopicsUsingNames(((TopicNameCollection) topics).topicNames(), options));\n        else\n            throw new IllegalArgumentException(\"The TopicCollection: \" + topics + \" provided did not match any supported classes for deleteTopics.\");\n    }\n\n    private Map<String, KafkaFuture<Void>> handleDeleteTopicsUsingNames(final Collection<String> topicNames,\n                                                                        final DeleteTopicsOptions options) {\n        final Map<String, KafkaFutureImpl<Void>> topicFutures = new HashMap<>(topicNames.size());\n        final List<String> validTopicNames = new ArrayList<>(topicNames.size());\n        for (String topicName : topicNames) {\n            if (topicNameIsUnrepresentable(topicName)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidTopicException(\"The given topic name '\" +\n                    topicName + \"' cannot be represented in a request.\"));\n                topicFutures.put(topicName, future);\n            } else if (!topicFutures.containsKey(topicName)) {\n                topicFutures.put(topicName, new KafkaFutureImpl<>());\n                validTopicNames.add(topicName);\n            }\n        }\n        if (!validTopicNames.isEmpty()) {\n            final long now = time.milliseconds();\n            final long deadline = calcDeadlineMs(now, options.timeoutMs());\n            final Call call = getDeleteTopicsCall(options, topicFutures, validTopicNames,\n                Collections.emptyMap(), now, deadline);\n            runnable.call(call, now);\n        }\n        return new HashMap<>(topicFutures);\n    }\n\n    private Map<Uuid, KafkaFuture<Void>> handleDeleteTopicsUsingIds(final Collection<Uuid> topicIds,\n                                                                    final DeleteTopicsOptions options) {\n        final Map<Uuid, KafkaFutureImpl<Void>> topicFutures = new HashMap<>(topicIds.size());\n        final List<Uuid> validTopicIds = new ArrayList<>(topicIds.size());\n        for (Uuid topicId : topicIds) {\n            if (topicId.equals(Uuid.ZERO_UUID)) {\n                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidTopicException(\"The given topic ID '\" +\n                    topicId + \"' cannot be represented in a request.\"));\n                topicFutures.put(topicId, future);\n            } else if (!topicFutures.containsKey(topicId)) {\n                topicFutures.put(topicId, new KafkaFutureImpl<>());\n                validTopicIds.add(topicId);\n            }\n        }\n        if (!validTopicIds.isEmpty()) {\n            final long now = time.milliseconds();\n            final long deadline = calcDeadlineMs(now, options.timeoutMs());\n            final Call call = getDeleteTopicsWithIdsCall(options, topicFutures, validTopicIds,\n                Collections.emptyMap(), now, deadline);\n            runnable.call(call, now);\n        }\n        return new HashMap<>(topicFutures);\n    }\n\n    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1821-L1970",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1821,
  "end_line": 1970,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}