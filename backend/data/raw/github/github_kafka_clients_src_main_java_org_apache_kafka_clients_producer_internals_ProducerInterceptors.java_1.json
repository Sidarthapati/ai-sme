{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_ProducerInterceptors.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerInterceptors.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\n\nimport org.apache.kafka.clients.producer.ProducerConfig;\nimport org.apache.kafka.clients.producer.ProducerInterceptor;\nimport org.apache.kafka.clients.producer.ProducerRecord;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.header.Headers;\nimport org.apache.kafka.common.header.internals.RecordHeaders;\nimport org.apache.kafka.common.internals.Plugin;\nimport org.apache.kafka.common.metrics.Metrics;\nimport org.apache.kafka.common.record.RecordBatch;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.Closeable;\nimport java.util.List;\n\n/**\n * A container that holds the list {@link org.apache.kafka.clients.producer.ProducerInterceptor}\n * and wraps calls to the chain of custom interceptors.\n */\npublic class ProducerInterceptors<K, V> implements Closeable {\n    private static final Logger log = LoggerFactory.getLogger(ProducerInterceptors.class);\n    private final List<Plugin<ProducerInterceptor<K, V>>> interceptorPlugins;\n\n    public ProducerInterceptors(List<ProducerInterceptor<K, V>> interceptors, Metrics metrics) {\n        this.interceptorPlugins = Plugin.wrapInstances(interceptors, metrics, ProducerConfig.INTERCEPTOR_CLASSES_CONFIG);\n    }\n\n    /**\n     * This is called when client sends the record to KafkaProducer, before key and value gets serialized.\n     * The method calls {@link ProducerInterceptor#onSend(ProducerRecord)} method. ProducerRecord\n     * returned from the first interceptor's onSend() is passed to the second interceptor onSend(), and so on in the\n     * interceptor chain. The record returned from the last interceptor is returned from this method.\n     *\n     * This method does not throw exceptions. Exceptions thrown by any of interceptor methods are caught and ignored.\n     * If an interceptor in the middle of the chain, that normally modifies the record, throws an exception,\n     * the next interceptor in the chain will be called with a record returned by the previous interceptor that did not\n     * throw an exception.\n     *\n     * @param record the record from client\n     * @return producer record to send to topic/partition\n     */\n    public ProducerRecord<K, V> onSend(ProducerRecord<K, V> record) {\n        ProducerRecord<K, V> interceptRecord = record;\n        for (Plugin<ProducerInterceptor<K, V>> interceptorPlugin : this.interceptorPlugins) {\n            try {\n                interceptRecord = interceptorPlugin.get().onSend(interceptRecord);\n            } catch (Exception e) {\n                // do not propagate interceptor exception, log and continue calling other interceptors\n                // be careful not to throw exception from here\n                if (record != null)\n                    log.warn(\"Error executing interceptor onSend callback for topic: {}, partition: {}\", record.topic(), record.partition(), e);\n                else\n                    log.warn(\"Error executing interceptor onSend callback\", e);\n            }\n        }\n        return interceptRecord;\n    }\n\n    /**\n     * This method is called when the record sent to the server has been acknowledged, or when sending the record fails before\n     * it gets sent to the server. This method calls {@link ProducerInterceptor#onAcknowledgement(RecordMetadata, Exception, Headers)}\n     * method for each interceptor.\n     *\n     * This method does not throw exceptions. Exceptions thrown by any of interceptor methods are caught and ignored.\n     *\n     * @param metadata The metadata for the record that was sent (i.e. the partition and offset).\n     *                 If an error occurred, metadata will only contain valid topic and maybe partition.\n     * @param exception The exception thrown during processing of this record. Null if no error occurred.\n     * @param headers The headers for the record that was sent\n     */\n    public void onAcknowledgement(RecordMetadata metadata, Exception exception, Headers headers) {\n        for (Plugin<ProducerInterceptor<K, V>> interceptorPlugin : this.interceptorPlugins) {\n            try {\n                interceptorPlugin.get().onAcknowledgement(metadata, exception, headers);\n            } catch (Exception e) {\n                // do not propagate interceptor exceptions, just log\n                log.warn(\"Error executing interceptor onAcknowledgement callback\", e);\n            }\n        }\n    }\n\n    /**\n     * This method is called when sending the record fails in {@link ProducerInterceptor#onSend\n     * (ProducerRecord)} method. This method calls {@link ProducerInterceptor#onAcknowledgement(RecordMetadata, Exception, Headers)}\n     * method for each interceptor\n     *\n     * @param record The record from client\n     * @param interceptTopicPartition  The topic/partition for the record if an error occurred\n     *        after partition gets assigned; the topic part of interceptTopicPartition is the same as in record.\n     * @param exception The exception thrown during processing of this record.\n     */\n    public void onSendError(ProducerRecord<K, V> record, TopicPartition interceptTopicPartition, Exception exception) {\n        for (Plugin<ProducerInterceptor<K, V>> interceptorPlugin : this.interceptorPlugins) {\n            try {\n                Headers headers = record != null ? record.headers() : new RecordHeaders();\n                if (headers instanceof RecordHeaders && !((RecordHeaders) headers).isReadOnly()) {\n                    // make a copy of the headers to make sure we don't change the state of origin record's headers.\n                    // original headers are still writable because client might want to mutate them before retrying.\n                    RecordHeaders recordHeaders = (RecordHeaders) headers;\n                    headers = new RecordHeaders(recordHeaders);\n                    ((RecordHeaders) headers).setReadOnly();\n                }\n                if (record == null && interceptTopicPartition == null) {\n                    interceptorPlugin.get().onAcknowledgement(null, exception, headers);\n                } else {\n                    if (interceptTopicPartition == null) {\n                        interceptTopicPartition = extractTopicPartition(record);\n                    }\n                    interceptorPlugin.get().onAcknowledgement(new RecordMetadata(interceptTopicPartition, -1, -1,\n                                    RecordBatch.NO_TIMESTAMP, -1, -1), exception, headers);\n                }\n            } catch (Exception e) {\n                // do not propagate interceptor exceptions, just log\n                log.warn(\"Error executing interceptor onAcknowledgement callback\", e);\n            }\n        }\n    }\n\n    public static <K, V> TopicPartition extractTopicPartition(ProducerRecord<K, V> record) {\n        return new TopicPartition(record.topic(), record.partition() == null ? RecordMetadata.UNKNOWN_PARTITION : record.partition());\n    }\n\n    /**\n     * Closes every interceptor in a container.\n     */\n    @Override\n    public void close() {\n        for (Plugin<ProducerInterceptor<K, V>> interceptorPlugin : this.interceptorPlugins) {\n            try {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerInterceptors.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerInterceptors.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.609763",
  "source_type": "github"
}