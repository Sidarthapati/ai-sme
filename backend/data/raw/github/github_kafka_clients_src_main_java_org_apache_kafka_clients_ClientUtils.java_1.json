{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_ClientUtils.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/ClientUtils.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients;\n\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.config.AbstractConfig;\nimport org.apache.kafka.common.config.ConfigException;\nimport org.apache.kafka.common.config.SaslConfigs;\nimport org.apache.kafka.common.internals.ClusterResourceListeners;\nimport org.apache.kafka.common.metrics.Metrics;\nimport org.apache.kafka.common.metrics.Sensor;\nimport org.apache.kafka.common.network.ChannelBuilder;\nimport org.apache.kafka.common.network.ChannelBuilders;\nimport org.apache.kafka.common.network.Selector;\nimport org.apache.kafka.common.security.JaasContext;\nimport org.apache.kafka.common.security.auth.SecurityProtocol;\nimport org.apache.kafka.common.telemetry.internals.ClientTelemetrySender;\nimport org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.Time;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.apache.kafka.common.utils.Utils.closeQuietly;\nimport static org.apache.kafka.common.utils.Utils.getHost;\nimport static org.apache.kafka.common.utils.Utils.getPort;\n\npublic final class ClientUtils {\n    private static final Logger log = LoggerFactory.getLogger(ClientUtils.class);\n\n    private ClientUtils() {\n    }\n\n    public static List<InetSocketAddress> parseAndValidateAddresses(AbstractConfig config) {\n        List<String> urls = config.getList(CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG);\n        String clientDnsLookupConfig = config.getString(CommonClientConfigs.CLIENT_DNS_LOOKUP_CONFIG);\n        return parseAndValidateAddresses(urls, clientDnsLookupConfig);\n    }\n\n    public static List<InetSocketAddress> parseAndValidateAddresses(List<String> urls, String clientDnsLookupConfig) {\n        return parseAndValidateAddresses(urls, ClientDnsLookup.forConfig(clientDnsLookupConfig));\n    }\n\n    public static List<InetSocketAddress> parseAndValidateAddresses(List<String> urls, ClientDnsLookup clientDnsLookup) {\n        List<InetSocketAddress> addresses = new ArrayList<>();\n        for (String url : urls) {\n            if (url != null && !url.isEmpty()) {\n                try {\n                    String host = getHost(url);\n                    Integer port = getPort(url);\n                    if (host == null || port == null)\n                        throw new ConfigException(\"Invalid url in \" + CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG + \": \" + url);\n\n                    if (clientDnsLookup == ClientDnsLookup.RESOLVE_CANONICAL_BOOTSTRAP_SERVERS_ONLY) {\n                        InetAddress[] inetAddresses = InetAddress.getAllByName(host);\n                        for (InetAddress inetAddress : inetAddresses) {\n                            String resolvedCanonicalName = inetAddress.getCanonicalHostName();\n                            InetSocketAddress address = new InetSocketAddress(resolvedCanonicalName, port);\n                            if (address.isUnresolved()) {\n                                log.warn(\"Couldn't resolve server {} from {} as DNS resolution of the canonical hostname {} failed for {}\", url, CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, resolvedCanonicalName, host);\n                            } else {\n                                addresses.add(address);\n                            }\n                        }\n                    } else {\n                        InetSocketAddress address = new InetSocketAddress(host, port);\n                        if (address.isUnresolved()) {\n                            log.warn(\"Couldn't resolve server {} from {} as DNS resolution failed for {}\", url, CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG, host);\n                        } else {\n                            addresses.add(address);\n                        }\n                    }\n\n                } catch (IllegalArgumentException e) {\n                    throw new ConfigException(\"Invalid port in \" + CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG + \": \" + url);\n                } catch (UnknownHostException e) {\n                    throw new ConfigException(\"Unknown host in \" + CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG + \": \" + url);\n                }\n            }\n        }\n        if (addresses.isEmpty())\n            throw new ConfigException(\"No resolvable bootstrap urls given in \" + CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG);\n        return addresses;\n    }\n\n    /**\n     * Create a new channel builder from the provided configuration.\n     *\n     * @param config client configs\n     * @param time the time implementation\n     * @param logContext the logging context\n     *\n     * @return configured ChannelBuilder based on the configs.\n     */\n    public static ChannelBuilder createChannelBuilder(AbstractConfig config, Time time, LogContext logContext) {\n        SecurityProtocol securityProtocol = SecurityProtocol.forName(config.getString(CommonClientConfigs.SECURITY_PROTOCOL_CONFIG));\n        String clientSaslMechanism = config.getString(SaslConfigs.SASL_MECHANISM);\n        return ChannelBuilders.clientChannelBuilder(securityProtocol, JaasContext.Type.CLIENT, config, null,\n                clientSaslMechanism, time, logContext);\n    }\n\n    static List<InetAddress> resolve(String host, HostResolver hostResolver) throws UnknownHostException {\n        InetAddress[] addresses = hostResolver.resolve(host);\n        List<InetAddress> result = filterPreferredAddresses(addresses);\n        if (log.isDebugEnabled())\n            log.debug(\"Resolved host {} as {}\", host, result.stream().map(InetAddress::getHostAddress).collect(Collectors.joining(\",\")));\n        return result;\n    }\n\n    /**\n     * Return a list containing the first address in `allAddresses` and subsequent addresses\n     * that are a subtype of the first address.\n     *\n     * The outcome is that all returned addresses are either IPv4 or IPv6 (InetAddress has two\n     * subclasses: Inet4Address and Inet6Address).\n     */\n    static List<InetAddress> filterPreferredAddresses(InetAddress[] allAddresses) {\n        List<InetAddress> preferredAddresses = new ArrayList<>();\n        Class<? extends InetAddress> clazz = null;\n        for (InetAddress address : allAddresses) {\n            if (clazz == null) {\n                clazz = address.getClass();\n            }\n            if (clazz.isInstance(address)) {\n                preferredAddresses.add(address);\n            }\n        }\n        return preferredAddresses;",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/ClientUtils.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/ClientUtils.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.577378",
  "source_type": "github"
}