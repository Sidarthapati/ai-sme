{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_1301",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "                // When talking to the startup phase of a broker, it is possible to receive an empty metadata set, which\n                // we should retry later.\n                log.trace(\"Ignoring empty metadata response with correlation id {}.\", requestHeader.correlationId());\n                this.metadata.failedUpdate(now);\n            } else {\n                this.metadata.update(inProgress.requestVersion, response, inProgress.isPartialUpdate, now);\n                metadataAttemptStartMs = Optional.empty();\n            }\n\n            inProgress = null;\n        }\n\n        @Override\n        public boolean needsRebootstrap(long now, long rebootstrapTriggerMs) {\n            return metadataAttemptStartMs.filter(startMs -> now - startMs > rebootstrapTriggerMs).isPresent();\n        }\n\n        @Override\n        public void rebootstrap(long now) {\n            metadata.rebootstrap();\n            metadataAttemptStartMs = Optional.of(now);\n        }\n\n        @Override\n        public void close() {\n            this.metadata.close();\n        }\n\n        private void initiateRebootstrap() {\n            metadataAttemptStartMs = Optional.of(0L); // to force rebootstrap\n        }\n\n        /**\n         * Add a metadata request to the list of sends if we can make one\n         */\n        private long maybeUpdate(long now, Node node) {\n            String nodeConnectionId = node.idString();\n\n            if (canSendRequest(nodeConnectionId, now)) {\n                Metadata.MetadataRequestAndVersion requestAndVersion = metadata.newMetadataRequestAndVersion(now);\n                MetadataRequest.Builder metadataRequest = requestAndVersion.requestBuilder;\n                log.debug(\"Sending metadata request {} to node {}\", metadataRequest, node);\n                sendInternalMetadataRequest(metadataRequest, nodeConnectionId, now);\n                inProgress = new InProgressData(requestAndVersion.requestVersion, requestAndVersion.isPartialUpdate);\n                return defaultRequestTimeoutMs;\n            }\n\n            // If there's any connection establishment underway, wait until it completes. This prevents\n            // the client from unnecessarily connecting to additional nodes while a previous connection\n            // attempt has not been completed.\n            if (isAnyNodeConnecting()) {\n                // Strictly the timeout we should return here is \"connect timeout\", but as we don't\n                // have such application level configuration, using reconnect backoff instead.\n                return reconnectBackoffMs;\n            }\n\n            if (connectionStates.canConnect(nodeConnectionId, now)) {\n                // We don't have a connection to this node right now, make one\n                log.debug(\"Initialize connection to node {} for sending metadata request\", node);\n                initiateConnect(node, now);\n                return reconnectBackoffMs;\n            }\n\n            // connected, but can't send more OR connecting\n            // In either case, we just need to wait for a network event to let us know the selected\n            // connection might be usable again.\n            return Long.MAX_VALUE;\n        }\n\n        public class InProgressData {\n            public final int requestVersion;\n            public final boolean isPartialUpdate;\n\n            private InProgressData(int requestVersion, boolean isPartialUpdate) {\n                this.requestVersion = requestVersion;\n                this.isPartialUpdate = isPartialUpdate;\n            }\n        }\n\n    }\n\n    class TelemetrySender {\n\n        private final ClientTelemetrySender clientTelemetrySender;\n        private Node stickyNode;\n\n        public TelemetrySender(ClientTelemetrySender clientTelemetrySender) {\n            this.clientTelemetrySender = clientTelemetrySender;\n        }\n\n        public long maybeUpdate(long now) {\n            long timeToNextUpdate = clientTelemetrySender.timeToNextUpdate(defaultRequestTimeoutMs);\n            if (timeToNextUpdate > 0)\n                return timeToNextUpdate;\n\n            // Per KIP-714, let's continue to re-use the same broker for as long as possible.\n            if (stickyNode == null) {\n                stickyNode = leastLoadedNode(now).node();\n                if (stickyNode == null) {\n                    log.debug(\"Give up sending telemetry request since no node is available\");\n                    return reconnectBackoffMs;\n                }\n            }\n\n            return maybeUpdate(now, stickyNode);\n        }\n\n        private long maybeUpdate(long now, Node node) {\n            String nodeConnectionId = node.idString();\n\n            if (canSendRequest(nodeConnectionId, now)) {\n                Optional<AbstractRequest.Builder<?>> requestOpt = clientTelemetrySender.createRequest();\n\n                if (requestOpt.isEmpty())\n                    return Long.MAX_VALUE;\n\n                AbstractRequest.Builder<?> request = requestOpt.get();\n                ClientRequest clientRequest = newClientRequest(nodeConnectionId, request, now, true);\n                doSend(clientRequest, true, now);\n                return defaultRequestTimeoutMs;\n            } else {\n                // Per KIP-714, if we can't issue a request to this broker node, let's clear it out\n                // and try another broker on the next loop.\n                stickyNode = null;\n            }\n\n            // If there's any connection establishment underway, wait until it completes. This prevents\n            // the client from unnecessarily connecting to additional nodes while a previous connection\n            // attempt has not been completed.\n            if (isAnyNodeConnecting())\n                return reconnectBackoffMs;\n\n            if (connectionStates.canConnect(nodeConnectionId, now)) {\n                // We don't have a connection to this node right now, make one\n                log.debug(\"Initialize connection to node {} for sending telemetry request\", node);\n                initiateConnect(node, now);\n                return reconnectBackoffMs;\n            }\n\n            // In either case, we just need to wait for a network event to let us know the selected\n            // connection might be usable again.\n            return Long.MAX_VALUE;\n        }\n\n        public void handleResponse(GetTelemetrySubscriptionsResponse response) {\n            clientTelemetrySender.handleResponse(response);\n        }\n\n        public void handleResponse(PushTelemetryResponse response) {\n            clientTelemetrySender.handleResponse(response);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L1301-L1450",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1301,
  "end_line": 1450,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}