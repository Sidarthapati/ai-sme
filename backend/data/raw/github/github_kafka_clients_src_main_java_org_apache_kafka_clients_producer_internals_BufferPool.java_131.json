{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_BufferPool.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java",
  "content": "                // we have enough unallocated or pooled memory to immediately\n                // satisfy the request, but need to allocate the buffer\n                freeUp(size);\n                this.nonPooledAvailableMemory -= size;\n            } else {\n                // we are out of memory and will have to block\n                int accumulated = 0;\n                Condition moreMemory = this.lock.newCondition();\n                try {\n                    long remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);\n                    this.waiters.addLast(moreMemory);\n                    // loop over and over until we have a buffer or have reserved\n                    // enough memory to allocate one\n                    while (accumulated < size) {\n                        long startWaitNs = time.nanoseconds();\n                        long timeNs;\n                        boolean waitingTimeElapsed;\n                        try {\n                            waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);\n                        } finally {\n                            long endWaitNs = time.nanoseconds();\n                            timeNs = Math.max(0L, endWaitNs - startWaitNs);\n                            recordWaitTime(timeNs);\n                        }\n\n                        if (this.closed)\n                            throw new KafkaException(\"Producer closed while allocating memory\");\n\n                        if (waitingTimeElapsed) {\n                            this.metrics.sensor(\"buffer-exhausted-records\").record();\n                            throw new BufferExhaustedException(\"Failed to allocate \" + size + \" bytes within the configured max blocking time \"\n                                + maxTimeToBlockMs + \" ms. Total memory: \" + totalMemory() + \" bytes. Available memory: \" + availableMemory()\n                                + \" bytes. Poolable size: \" + poolableSize() + \" bytes\");\n                        }\n\n                        remainingTimeToBlockNs -= timeNs;\n\n                        // check if we can satisfy this request from the free list,\n                        // otherwise allocate memory\n                        if (accumulated == 0 && size == this.poolableSize && !this.free.isEmpty()) {\n                            // just grab a buffer from the free list\n                            buffer = this.free.pollFirst();\n                            accumulated = size;\n                        } else {\n                            // we'll need to allocate memory, but we may only get\n                            // part of what we need on this iteration\n                            freeUp(size - accumulated);\n                            int got = (int) Math.min(size - accumulated, this.nonPooledAvailableMemory);\n                            this.nonPooledAvailableMemory -= got;\n                            accumulated += got;\n                        }\n                    }\n                    // Don't reclaim memory on throwable since nothing was thrown\n                    accumulated = 0;\n                } finally {\n                    // When this loop was not able to successfully terminate don't loose available memory\n                    this.nonPooledAvailableMemory += accumulated;\n                    this.waiters.remove(moreMemory);\n                }\n            }\n        } finally {\n            // signal any additional waiters if there is more memory left\n            // over for them\n            try {\n                if (!(this.nonPooledAvailableMemory == 0 && this.free.isEmpty()) && !this.waiters.isEmpty())\n                    this.waiters.peekFirst().signal();\n            } finally {\n                // Another finally... otherwise find bugs complains\n                lock.unlock();\n            }\n        }\n\n        if (buffer == null)\n            return safeAllocateByteBuffer(size);\n        else\n            return buffer;\n    }\n\n    // Protected for testing\n    protected void recordWaitTime(long timeNs) {\n        this.waitTime.record(timeNs, time.milliseconds());\n    }\n\n    /**\n     * Allocate a buffer.  If buffer allocation fails (e.g. because of OOM) then return the size count back to\n     * available memory and signal the next waiter if it exists.\n     */\n    private ByteBuffer safeAllocateByteBuffer(int size) {\n        boolean error = true;\n        try {\n            ByteBuffer buffer = allocateByteBuffer(size);\n            error = false;\n            return buffer;\n        } finally {\n            if (error) {\n                this.lock.lock();\n                try {\n                    this.nonPooledAvailableMemory += size;\n                    if (!this.waiters.isEmpty())\n                        this.waiters.peekFirst().signal();\n                } finally {\n                    this.lock.unlock();\n                }\n            }\n        }\n    }\n\n    // Protected for testing.\n    protected ByteBuffer allocateByteBuffer(int size) {\n        return ByteBuffer.allocate(size);\n    }\n\n    /**\n     * Attempt to ensure we have at least the requested number of bytes of memory for allocation by deallocating pooled\n     * buffers (if needed)\n     */\n    private void freeUp(int size) {\n        while (!this.free.isEmpty() && this.nonPooledAvailableMemory < size)\n            this.nonPooledAvailableMemory += this.free.pollLast().capacity();\n    }\n\n    /**\n     * Return buffers to the pool. If they are of the poolable size add them to the free list, otherwise just mark the\n     * memory as free.\n     *\n     * @param buffer The buffer to return\n     * @param size The size of the buffer to mark as deallocated, note that this may be smaller than buffer.capacity\n     *             since the buffer may re-allocate itself during in-place compression\n     */\n    public void deallocate(ByteBuffer buffer, int size) {\n        lock.lock();\n        try {\n            if (size == this.poolableSize && size == buffer.capacity()) {\n                buffer.clear();\n                this.free.add(buffer);\n            } else {\n                this.nonPooledAvailableMemory += size;\n            }\n            Condition moreMem = this.waiters.peekFirst();\n            if (moreMem != null)\n                moreMem.signal();\n        } finally {\n            lock.unlock();\n        }\n    }\n\n    public void deallocate(ByteBuffer buffer) {\n        if (buffer != null)\n            deallocate(buffer, buffer.capacity());\n    }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.609128",
  "source_type": "github"
}