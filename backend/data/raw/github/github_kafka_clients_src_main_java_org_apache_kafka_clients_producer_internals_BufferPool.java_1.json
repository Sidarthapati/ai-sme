{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_BufferPool.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.producer.BufferExhaustedException;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.metrics.Metrics;\nimport org.apache.kafka.common.metrics.Sensor;\nimport org.apache.kafka.common.metrics.stats.Meter;\nimport org.apache.kafka.common.utils.Time;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.ReentrantLock;\n\n\n/**\n * A pool of ByteBuffers kept under a given memory limit. This class is fairly specific to the needs of the producer. In\n * particular it has the following properties:\n * <ol>\n * <li>There is a special \"poolable size\" and buffers of this size are kept in a free list and recycled\n * <li>It is fair. That is all memory is given to the longest waiting thread until it has sufficient memory. This\n * prevents starvation or deadlock when a thread asks for a large chunk of memory and needs to block until multiple\n * buffers are deallocated.\n * </ol>\n */\npublic class BufferPool {\n\n    static final String WAIT_TIME_SENSOR_NAME = \"bufferpool-wait-time\";\n\n    private final long totalMemory;\n    private final int poolableSize;\n    private final ReentrantLock lock;\n    private final Deque<ByteBuffer> free;\n    private final Deque<Condition> waiters;\n    /** Total available memory is the sum of nonPooledAvailableMemory and the number of byte buffers in free * poolableSize.  */\n    private long nonPooledAvailableMemory;\n    private final Metrics metrics;\n    private final Time time;\n    private final Sensor waitTime;\n    private boolean closed;\n\n    /**\n     * Create a new buffer pool\n     *\n     * @param memory The maximum amount of memory that this buffer pool can allocate\n     * @param poolableSize The buffer size to cache in the free list rather than deallocating\n     * @param metrics instance of Metrics\n     * @param time time instance\n     * @param metricGrpName logical group name for metrics\n     */\n    public BufferPool(long memory, int poolableSize, Metrics metrics, Time time, String metricGrpName) {\n        this.poolableSize = poolableSize;\n        this.lock = new ReentrantLock();\n        this.free = new ArrayDeque<>();\n        this.waiters = new ArrayDeque<>();\n        this.totalMemory = memory;\n        this.nonPooledAvailableMemory = memory;\n        this.metrics = metrics;\n        this.time = time;\n        this.waitTime = this.metrics.sensor(WAIT_TIME_SENSOR_NAME);\n        MetricName rateMetricName = metrics.metricName(\"bufferpool-wait-ratio\",\n                                                   metricGrpName,\n                                                   \"The fraction of time an appender waits for space allocation.\");\n        MetricName totalNsMetricName = metrics.metricName(\"bufferpool-wait-time-ns-total\",\n                                                    metricGrpName,\n                                                    \"The total time in nanoseconds an appender waits for space allocation.\");\n\n        Sensor bufferExhaustedRecordSensor = metrics.sensor(\"buffer-exhausted-records\");\n        MetricName bufferExhaustedRateMetricName = metrics.metricName(\"buffer-exhausted-rate\", metricGrpName, \"The average per-second number of record sends that are dropped due to buffer exhaustion\");\n        MetricName bufferExhaustedTotalMetricName = metrics.metricName(\"buffer-exhausted-total\", metricGrpName, \"The total number of record sends that are dropped due to buffer exhaustion\");\n        bufferExhaustedRecordSensor.add(new Meter(bufferExhaustedRateMetricName, bufferExhaustedTotalMetricName));\n\n        this.waitTime.add(new Meter(TimeUnit.NANOSECONDS, rateMetricName, totalNsMetricName));\n        this.closed = false;\n    }\n\n    /**\n     * Allocate a buffer of the given size. This method blocks if there is not enough memory and the buffer pool\n     * is configured with blocking mode.\n     *\n     * @param size The buffer size to allocate in bytes\n     * @param maxTimeToBlockMs The maximum time in milliseconds to block for buffer memory to be available\n     * @return The buffer\n     * @throws InterruptedException If the thread is interrupted while blocked\n     * @throws IllegalArgumentException if size is larger than the total memory controlled by the pool (and hence we would block\n     *         forever)\n     */\n    public ByteBuffer allocate(int size, long maxTimeToBlockMs) throws InterruptedException {\n        if (size > this.totalMemory)\n            throw new IllegalArgumentException(\"Attempt to allocate \" + size\n                                               + \" bytes, but there is a hard limit of \"\n                                               + this.totalMemory\n                                               + \" on memory allocations.\");\n\n        ByteBuffer buffer = null;\n        this.lock.lock();\n\n        if (this.closed) {\n            this.lock.unlock();\n            throw new KafkaException(\"Producer closed while allocating memory\");\n        }\n\n        try {\n            // check if we have a free buffer of the right size pooled\n            if (size == poolableSize && !this.free.isEmpty())\n                return this.free.pollFirst();\n\n            // now check if the request is immediately satisfiable with the\n            // memory on hand or if we need to block\n            int freeListSize = freeSize() * this.poolableSize;\n            if (this.nonPooledAvailableMemory + freeListSize >= size) {\n                // we have enough unallocated or pooled memory to immediately\n                // satisfy the request, but need to allocate the buffer\n                freeUp(size);\n                this.nonPooledAvailableMemory -= size;\n            } else {\n                // we are out of memory and will have to block\n                int accumulated = 0;\n                Condition moreMemory = this.lock.newCondition();\n                try {\n                    long remainingTimeToBlockNs = TimeUnit.MILLISECONDS.toNanos(maxTimeToBlockMs);\n                    this.waiters.addLast(moreMemory);\n                    // loop over and over until we have a buffer or have reserved\n                    // enough memory to allocate one\n                    while (accumulated < size) {\n                        long startWaitNs = time.nanoseconds();\n                        long timeNs;\n                        boolean waitingTimeElapsed;\n                        try {\n                            waitingTimeElapsed = !moreMemory.await(remainingTimeToBlockNs, TimeUnit.NANOSECONDS);\n                        } finally {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/BufferPool.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.609128",
  "source_type": "github"
}