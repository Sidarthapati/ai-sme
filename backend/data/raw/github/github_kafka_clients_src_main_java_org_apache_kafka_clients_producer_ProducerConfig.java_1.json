{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_ProducerConfig.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer;\n\nimport org.apache.kafka.clients.ClientDnsLookup;\nimport org.apache.kafka.clients.CommonClientConfigs;\nimport org.apache.kafka.clients.MetadataRecoveryStrategy;\nimport org.apache.kafka.common.config.AbstractConfig;\nimport org.apache.kafka.common.config.ConfigDef;\nimport org.apache.kafka.common.config.ConfigDef.Importance;\nimport org.apache.kafka.common.config.ConfigDef.Type;\nimport org.apache.kafka.common.config.ConfigException;\nimport org.apache.kafka.common.config.SecurityConfig;\nimport org.apache.kafka.common.metrics.JmxReporter;\nimport org.apache.kafka.common.metrics.Sensor;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.security.auth.SecurityProtocol;\nimport org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.common.utils.Utils;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.concurrent.atomic.AtomicInteger;\n\nimport static org.apache.kafka.common.config.ConfigDef.NO_DEFAULT_VALUE;\nimport static org.apache.kafka.common.config.ConfigDef.Range.atLeast;\nimport static org.apache.kafka.common.config.ConfigDef.Range.between;\nimport static org.apache.kafka.common.config.ConfigDef.ValidString.in;\n\n/**\n * Configuration for the Kafka Producer. Documentation for these configurations can be found in the <a\n * href=\"http://kafka.apache.org/documentation.html#producerconfigs\">Kafka documentation</a>\n */\npublic class ProducerConfig extends AbstractConfig {\n    private static final Logger log = LoggerFactory.getLogger(ProducerConfig.class);\n\n    /*\n     * NOTE: DO NOT CHANGE EITHER CONFIG STRINGS OR THEIR JAVA VARIABLE NAMES AS THESE ARE PART OF THE PUBLIC API AND\n     * CHANGE WILL BREAK USER CODE.\n     */\n\n    private static final ConfigDef CONFIG;\n\n    /** <code>bootstrap.servers</code> */\n    public static final String BOOTSTRAP_SERVERS_CONFIG = CommonClientConfigs.BOOTSTRAP_SERVERS_CONFIG;\n\n    /** <code>client.dns.lookup</code> */\n    public static final String CLIENT_DNS_LOOKUP_CONFIG = CommonClientConfigs.CLIENT_DNS_LOOKUP_CONFIG;\n\n    /** <code>metadata.max.age.ms</code> */\n    public static final String METADATA_MAX_AGE_CONFIG = CommonClientConfigs.METADATA_MAX_AGE_CONFIG;\n    private static final String METADATA_MAX_AGE_DOC = CommonClientConfigs.METADATA_MAX_AGE_DOC;\n\n    /** <code>metadata.max.idle.ms</code> */\n    public static final String METADATA_MAX_IDLE_CONFIG = \"metadata.max.idle.ms\";\n    private static final String METADATA_MAX_IDLE_DOC =\n            \"Controls how long the producer will cache metadata for a topic that's idle. If the elapsed \" +\n            \"time since a topic was last produced to exceeds the metadata idle duration, then the topic's \" +\n            \"metadata is forgotten and the next access to it will force a metadata fetch request.\";\n\n    /** <code>batch.size</code> */\n    public static final String BATCH_SIZE_CONFIG = \"batch.size\";\n    private static final String BATCH_SIZE_DOC = \"The producer will attempt to batch records together into fewer requests whenever multiple records are being sent\"\n                                                 + \" to the same partition. This helps performance on both the client and the server. This configuration controls the \"\n                                                 + \"default batch size in bytes. \"\n                                                 + \"<p>\"\n                                                 + \"No attempt will be made to batch records larger than this size. \"\n                                                 + \"<p>\"\n                                                 + \"Requests sent to brokers will contain multiple batches, one for each partition with data available to be sent. \"\n                                                 + \"<p>\"\n                                                 + \"A small batch size will make batching less common and may reduce throughput (a batch size of zero will disable \"\n                                                 + \"batching entirely). A very large batch size may use memory a bit more wastefully as we will always allocate a \"\n                                                 + \"buffer of the specified batch size in anticipation of additional records.\"\n                                                 + \"<p>\"\n                                                 + \"Note: This setting gives the upper bound of the batch size to be sent. If we have fewer than this many bytes accumulated \"\n                                                 + \"for this partition, we will 'linger' for the <code>linger.ms</code> time waiting for more records to show up. \"\n                                                 + \"This <code>linger.ms</code> setting defaults to 5, which means the producer will wait for 5ms or until the record batch is \"\n                                                 + \"of <code>batch.size</code> (whichever happens first) before sending the record batch. Note that broker backpressure can \"\n                                                 + \" result in a higher effective linger time than this setting. \"\n                                                 + \"The default changed from 0 to 5 in Apache Kafka 4.0 as the efficiency gains from larger batches typically result in \"\n                                                 + \"similar or lower producer latency despite the increased linger.\";\n\n    /** <code>partitioner.adaptive.partitioning.enable</code> */\n    public static final String PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_CONFIG = \"partitioner.adaptive.partitioning.enable\";\n    @Deprecated\n    public static final String PARTITIONER_ADPATIVE_PARTITIONING_ENABLE_CONFIG = PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_CONFIG;\n    private static final String PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_DOC =\n            \"When set to 'true', the producer will try to adapt to broker performance and produce more messages to partitions hosted on faster brokers. \"\n            + \"If 'false', the producer will try to distribute messages uniformly. Note: this setting has no effect if a custom partitioner is used.\";\n\n    /** <code>partitioner.availability.timeout.ms</code> */\n    public static final String PARTITIONER_AVAILABILITY_TIMEOUT_MS_CONFIG = \"partitioner.availability.timeout.ms\";\n    private static final String PARTITIONER_AVAILABILITY_TIMEOUT_MS_DOC =\n            \"If a broker cannot process produce requests from a partition for <code>\" + PARTITIONER_AVAILABILITY_TIMEOUT_MS_CONFIG + \"</code> time, \"\n            + \"the partitioner treats that partition as not available.  If the value is 0, this logic is disabled. \"\n            + \"Note: this setting has no effect if a custom partitioner is used or <code>\" + PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_CONFIG\n            + \"</code> is set to 'false'.\";\n\n    /** <code>partitioner.ignore.keys</code> */\n    public static final String PARTITIONER_IGNORE_KEYS_CONFIG = \"partitioner.ignore.keys\";\n    private static final String PARTITIONER_IGNORE_KEYS_DOC = \"When set to 'true' the producer won't use record keys to choose a partition. \"\n            + \"If 'false', producer would choose a partition based on a hash of the key when a key is present. \"\n            + \"Note: this setting has no effect if a custom partitioner is used.\";\n\n    /** <code>acks</code> */\n    public static final String ACKS_CONFIG = \"acks\";\n    private static final String ACKS_DOC = \"The number of acknowledgments the producer requires the leader to have received before considering a request complete. This controls the \"\n                                           + \" durability of records that are sent. The following settings are allowed: \"\n                                           + \" <ul>\"\n                                           + \" <li><code>acks=0</code> If set to zero then the producer will not wait for any acknowledgment from the\"\n                                           + \" server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be\"\n                                           + \" made that the server has received the record in this case, and the <code>retries</code> configuration will not\"\n                                           + \" take effect (as the client won't generally know of any failures). The offset given back for each record will\"\n                                           + \" always be set to <code>-1</code>.\"\n                                           + \" <li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond\"\n                                           + \" without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after\"\n                                           + \" acknowledging the record but before the followers have replicated it then the record will be lost.\"\n                                           + \" <li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to\"\n                                           + \" acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica\"\n                                           + \" remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.\"\n                                           + \"</ul>\"\n                                           + \"<p>\"\n                                           + \"Note that enabling idempotence requires this config value to be 'all'.\"\n                                           + \" If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled.\";\n\n    /** <code>linger.ms</code> */\n    public static final String LINGER_MS_CONFIG = \"linger.ms\";\n    private static final String LINGER_MS_DOC = \"The producer groups together any records that arrive in between request transmissions into a single batched request. \"\n                                                + \"Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to \"\n                                                + \"reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount \"",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.608681",
  "source_type": "github"
}