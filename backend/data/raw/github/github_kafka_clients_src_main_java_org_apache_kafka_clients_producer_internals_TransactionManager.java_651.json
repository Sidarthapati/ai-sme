{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_651",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "\n    private void resetSequenceNumbers() {\n        txnPartitionMap.reset();\n        this.partitionsWithUnresolvedSequences.clear();\n    }\n\n    /**\n     * This method is used to trigger an epoch bump for non-transactional idempotent producers.\n     */\n    synchronized void requestIdempotentEpochBumpForPartition(TopicPartition tp) {\n        clientSideEpochBumpRequired = true;\n        this.partitionsToRewriteSequences.add(tp);\n    }\n\n    private void bumpIdempotentProducerEpoch() {\n        if (this.producerIdAndEpoch.epoch == Short.MAX_VALUE) {\n            resetIdempotentProducerId();\n        } else {\n            setProducerIdAndEpoch(new ProducerIdAndEpoch(this.producerIdAndEpoch.producerId, (short) (this.producerIdAndEpoch.epoch + 1)));\n            log.debug(\"Incremented producer epoch, current producer ID and epoch are now {}\", this.producerIdAndEpoch);\n        }\n\n        // When the epoch is bumped, rewrite all in-flight sequences for the partition(s) that triggered the epoch bump\n        for (TopicPartition topicPartition : this.partitionsToRewriteSequences) {\n            this.txnPartitionMap.startSequencesAtBeginning(topicPartition, this.producerIdAndEpoch);\n            this.partitionsWithUnresolvedSequences.remove(topicPartition);\n        }\n        this.partitionsToRewriteSequences.clear();\n\n        clientSideEpochBumpRequired = false;\n    }\n\n    synchronized void bumpIdempotentEpochAndResetIdIfNeeded() {\n        if (!isTransactional()) {\n            if (clientSideEpochBumpRequired) {\n                bumpIdempotentProducerEpoch();\n            }\n            if (currentState != State.INITIALIZING && !hasProducerId()) {\n                transitionTo(State.INITIALIZING);\n                InitProducerIdRequestData requestData = new InitProducerIdRequestData()\n                        .setTransactionalId(null)\n                        .setTransactionTimeoutMs(Integer.MAX_VALUE);\n                InitProducerIdHandler handler = new InitProducerIdHandler(new InitProducerIdRequest.Builder(requestData), false);\n                enqueueRequest(handler);\n            }\n        }\n    }\n\n    /**\n     * Returns the next sequence number to be written to the given TopicPartition.\n     */\n    synchronized int sequenceNumber(TopicPartition topicPartition) {\n        return txnPartitionMap.getOrCreate(topicPartition).nextSequence();\n    }\n\n    /**\n     * Returns the current producer id/epoch of the given TopicPartition.\n     */\n    synchronized ProducerIdAndEpoch producerIdAndEpoch(TopicPartition topicPartition) {\n        return txnPartitionMap.getOrCreate(topicPartition).producerIdAndEpoch();\n    }\n\n    synchronized void incrementSequenceNumber(TopicPartition topicPartition, int increment) {\n        txnPartitionMap.get(topicPartition).incrementSequence(increment);\n    }\n\n    synchronized void addInFlightBatch(ProducerBatch batch) {\n        if (!batch.hasSequence())\n            throw new IllegalStateException(\"Can't track batch for partition \" + batch.topicPartition + \" when sequence is not set.\");\n        txnPartitionMap.get(batch.topicPartition).addInflightBatch(batch);\n    }\n\n    /**\n     * Returns the first inflight sequence for a given partition. This is the base sequence of an inflight batch with\n     * the lowest sequence number.\n     * @return the lowest inflight sequence if the transaction manager is tracking inflight requests for this partition.\n     *         If there are no inflight requests being tracked for this partition, this method will return\n     *         RecordBatch.NO_SEQUENCE.\n     */\n    synchronized int firstInFlightSequence(TopicPartition topicPartition) {\n        if (!hasInflightBatches(topicPartition))\n            return RecordBatch.NO_SEQUENCE;\n        ProducerBatch batch = nextBatchBySequence(topicPartition);\n        return batch == null ? RecordBatch.NO_SEQUENCE : batch.baseSequence();\n    }\n\n    synchronized ProducerBatch nextBatchBySequence(TopicPartition topicPartition) {\n        return txnPartitionMap.nextBatchBySequence(topicPartition);\n    }\n\n    synchronized void removeInFlightBatch(ProducerBatch batch) {\n        if (hasInflightBatches(batch.topicPartition))\n            txnPartitionMap.removeInFlightBatch(batch);\n    }\n\n    private int maybeUpdateLastAckedSequence(TopicPartition topicPartition, int sequence) {\n        return txnPartitionMap.maybeUpdateLastAckedSequence(topicPartition, sequence);\n    }\n\n    synchronized OptionalInt lastAckedSequence(TopicPartition topicPartition) {\n        return txnPartitionMap.lastAckedSequence(topicPartition);\n    }\n\n    synchronized OptionalLong lastAckedOffset(TopicPartition topicPartition) {\n        return txnPartitionMap.lastAckedOffset(topicPartition);\n    }\n\n    private void updateLastAckedOffset(ProduceResponse.PartitionResponse response, ProducerBatch batch) {\n        if (response.baseOffset == ProduceResponse.INVALID_OFFSET)\n            return;\n        long lastOffset = response.baseOffset + batch.recordCount - 1;\n        txnPartitionMap.updateLastAckedOffset(batch.topicPartition, isTransactional(), lastOffset);\n    }\n\n    public synchronized void handleCompletedBatch(ProducerBatch batch, ProduceResponse.PartitionResponse response) {\n        int lastAckedSequence = maybeUpdateLastAckedSequence(batch.topicPartition, batch.lastSequence());\n        log.trace(\"ProducerId: {}; Set last ack'd sequence number for topic-partition {} to {}\",\n                batch.producerId(),\n                batch.topicPartition,\n                lastAckedSequence);\n\n        updateLastAckedOffset(response, batch);\n        removeInFlightBatch(batch);\n    }\n\n    public synchronized void transitionToUninitialized(RuntimeException exception) {\n        transitionTo(State.UNINITIALIZED);\n        if (pendingTransition != null) {\n            pendingTransition.result.fail(exception);\n        }\n        lastError = null;\n    }\n\n    public synchronized void maybeTransitionToErrorState(RuntimeException exception) {\n        if (exception instanceof ClusterAuthorizationException\n                || exception instanceof TransactionalIdAuthorizationException\n                || exception instanceof ProducerFencedException\n                || exception instanceof UnsupportedVersionException\n                || exception instanceof InvalidPidMappingException) {\n            transitionToFatalError(exception);\n        } else if (isTransactional()) {\n            // RetriableExceptions from the Sender thread are converted to Abortable errors\n            // because they indicate that the transaction cannot be completed after all retry attempts.\n            // This conversion ensures the application layer treats these errors as abortable,\n            // preventing duplicate message delivery.\n            if (exception instanceof RetriableException ||\n                    exception instanceof InvalidTxnStateException) {\n                exception = new TransactionAbortableException(\"Transaction Request was aborted after exhausting retries.\", exception);\n            }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L651-L800",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 651,
  "end_line": 800,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}