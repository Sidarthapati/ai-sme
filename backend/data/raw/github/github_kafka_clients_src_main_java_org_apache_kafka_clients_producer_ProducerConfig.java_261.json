{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_ProducerConfig.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "content": "\n    /** <code>metric.reporters</code> */\n    public static final String METRIC_REPORTER_CLASSES_CONFIG = CommonClientConfigs.METRIC_REPORTER_CLASSES_CONFIG;\n\n    // max.in.flight.requests.per.connection should be less than or equal to 5 when idempotence producer enabled to ensure message ordering\n    // The value 5 is aligned with ProducerStateEntry#NUM_BATCHES_TO_RETAIN.\n    private static final int MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_FOR_IDEMPOTENCE = 5;\n\n    /** <code>max.in.flight.requests.per.connection</code> */\n    public static final String MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION = \"max.in.flight.requests.per.connection\";\n    private static final String MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_DOC = \"The maximum number of unacknowledged requests the client will send on a single connection before blocking.\"\n                                                                            + \" Note that if this configuration is set to be greater than 1 and <code>enable.idempotence</code> is set to false, there is a risk of\"\n                                                                            + \" message reordering after a failed send due to retries (i.e., if retries are enabled); \"\n                                                                            + \" if retries are disabled or if <code>enable.idempotence</code> is set to true, ordering will be preserved.\"\n                                                                            + \" Additionally, enabling idempotence requires the value of this configuration to be less than or equal to \" + MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_FOR_IDEMPOTENCE + \",\"\n                                                                            + \" because broker only retains at most 5 batches for each producer. If the value is more than 5, previous batches may be removed on broker side.\";\n\n    /** <code>retries</code> */\n    public static final String RETRIES_CONFIG = CommonClientConfigs.RETRIES_CONFIG;\n    private static final String RETRIES_DOC = \"Number of times to retry a request that fails with a transient error.\"\n            + \" Setting a value greater than zero will cause the client to resend any record whose send fails with a potentially transient error. \"\n            + \" Requests will be retried this many times until they succeed, fail with a non-transient error, or the <code>\" + DELIVERY_TIMEOUT_MS_CONFIG + \"</code> expires.\"\n            + \" Note that this automatic retry will simply resend the same record upon receiving the error.\"\n            + \" Setting a value of zero will disable this automatic retry behaviour, so that the transient errors will be propagated to the application to be handled.\"\n            + \" Users should generally prefer to leave this config unset and instead use <code>\" + DELIVERY_TIMEOUT_MS_CONFIG + \"</code> to control\"\n            + \" retry behavior.\"\n            + \"<p>\"\n            + \"Enabling idempotence requires this config value to be greater than 0.\"\n            + \" If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled.\"\n            + \"<p>\"\n            + \"Allowing retries while setting <code>enable.idempotence</code> to <code>false</code> and <code>\" + MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION + \"</code> to greater than 1 will potentially change the\"\n            + \" ordering of records because if two batches are sent to a single partition, and the first fails and is retried but the second\"\n            + \" succeeds, then the records in the second batch may appear first.\";\n\n    /** <code>key.serializer</code> */\n    public static final String KEY_SERIALIZER_CLASS_CONFIG = \"key.serializer\";\n    public static final String KEY_SERIALIZER_CLASS_DOC = \"Serializer class for key that implements the <code>org.apache.kafka.common.serialization.Serializer</code> interface.\";\n\n    /** <code>value.serializer</code> */\n    public static final String VALUE_SERIALIZER_CLASS_CONFIG = \"value.serializer\";\n    public static final String VALUE_SERIALIZER_CLASS_DOC = \"Serializer class for value that implements the <code>org.apache.kafka.common.serialization.Serializer</code> interface.\";\n\n    /** <code>socket.connection.setup.timeout.ms</code> */\n    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG = CommonClientConfigs.SOCKET_CONNECTION_SETUP_TIMEOUT_MS_CONFIG;\n\n    /** <code>socket.connection.setup.timeout.max.ms</code> */\n    public static final String SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG = CommonClientConfigs.SOCKET_CONNECTION_SETUP_TIMEOUT_MAX_MS_CONFIG;\n\n    /** <code>connections.max.idle.ms</code> */\n    public static final String CONNECTIONS_MAX_IDLE_MS_CONFIG = CommonClientConfigs.CONNECTIONS_MAX_IDLE_MS_CONFIG;\n\n    /** <code>partitioner.class</code> */\n    public static final String PARTITIONER_CLASS_CONFIG = \"partitioner.class\";\n    private static final String PARTITIONER_CLASS_DOC = \"Determines which partition to send a record to when records are produced. Available options are:\" +\n            \"<ul>\" +\n            \"<li>If not set, the default partitioning logic is used. \" +\n            \"This strategy send records to a partition until at least \" + BATCH_SIZE_CONFIG + \" bytes is produced to the partition. It works with the strategy:\" +\n            \"<ol>\" +\n            \"<li>If no partition is specified but a key is present, choose a partition based on a hash of the key.</li>\" +\n            \"<li>If no partition or key is present, choose the sticky partition that changes when at least \" + BATCH_SIZE_CONFIG + \" bytes are produced to the partition.</li>\" +\n            \"</ol>\" +\n            \"</li>\" +\n            \"<li><code>org.apache.kafka.clients.producer.RoundRobinPartitioner</code>: A partitioning strategy where \" +\n            \"each record in a series of consecutive records is sent to a different partition, regardless of whether the 'key' is provided or not, \" +\n            \"until partitions run out and the process starts over again. Note: There's a known issue that will cause uneven distribution when a new batch is created. \" +\n            \"See KAFKA-9965 for more detail.\" +\n            \"</li>\" +\n            \"</ul>\" +\n            \"<p>Implementing the <code>org.apache.kafka.clients.producer.Partitioner</code> interface allows you to plug in a custom partitioner.\";\n\n    /** <code>interceptor.classes</code> */\n    public static final String INTERCEPTOR_CLASSES_CONFIG = \"interceptor.classes\";\n    public static final String INTERCEPTOR_CLASSES_DOC = \"A list of classes to use as interceptors. \"\n                                                        + \"Implementing the <code>org.apache.kafka.clients.producer.ProducerInterceptor</code> interface allows you to intercept (and possibly mutate) the records \"\n                                                        + \"received by the producer before they are published to the Kafka cluster. By default, there are no interceptors.\";\n\n    /** <code>enable.idempotence</code> */\n    public static final String ENABLE_IDEMPOTENCE_CONFIG = \"enable.idempotence\";\n    public static final String ENABLE_IDEMPOTENCE_DOC = \"When set to 'true', the producer will ensure that exactly one copy of each message is written in the stream. If 'false', producer \"\n                                                        + \"retries due to broker failures, etc., may write duplicates of the retried message in the stream. \"\n                                                        + \"Note that enabling idempotence requires <code>\" + MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION + \"</code> to be less than or equal to \" + MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_FOR_IDEMPOTENCE\n                                                        + \" (with message ordering preserved for any allowable value), <code>\" + RETRIES_CONFIG + \"</code> to be greater than 0, and <code>\"\n                                                        + ACKS_CONFIG + \"</code> must be 'all'. \"\n                                                        + \"<p>\"\n                                                        + \"Idempotence is enabled by default if no conflicting configurations are set. \"\n                                                        + \"If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled. \"\n                                                        + \"If idempotence is explicitly enabled and conflicting configurations are set, a <code>ConfigException</code> is thrown.\";\n\n    /** <code> transaction.timeout.ms </code> */\n    public static final String TRANSACTION_TIMEOUT_CONFIG = \"transaction.timeout.ms\";\n    public static final String TRANSACTION_TIMEOUT_DOC = \"The maximum amount of time in milliseconds that a transaction will remain open before the coordinator proactively aborts it. \" +\n            \"The start of the transaction is set at the time that the first partition is added to it. \" +\n            \"If this value is larger than the <code>transaction.max.timeout.ms</code> setting in the broker, the request will fail with a <code>InvalidTxnTimeoutException</code> error.\";\n\n    /** <code> transactional.id </code> */\n    public static final String TRANSACTIONAL_ID_CONFIG = \"transactional.id\";\n    public static final String TRANSACTIONAL_ID_DOC = \"The TransactionalId to use for transactional delivery. This enables reliability semantics which span multiple producer sessions since it allows the client to guarantee that transactions using the same TransactionalId have been completed prior to starting any new transactions. If no TransactionalId is provided, then the producer is limited to idempotent delivery. \" +\n            \"If a TransactionalId is configured, <code>enable.idempotence</code> is implied. \" +\n            \"By default the TransactionId is not configured, which means transactions cannot be used. \" +\n            \"Note that, by default, transactions require a cluster of at least three brokers which is the recommended setting for production; for development you can change this, by adjusting broker setting <code>transaction.state.log.replication.factor</code>.\";\n\n    /** <code> transaction.two.phase.commit.enable </code> */\n    public static final String TRANSACTION_TWO_PHASE_COMMIT_ENABLE_CONFIG = \"transaction.two.phase.commit.enable\";\n    private static final String TRANSACTION_TWO_PHASE_COMMIT_ENABLE_DOC = \"If set to true, then the broker is informed that the client is participating in \" +\n            \"two phase commit protocol and transactions that this client starts never expire.\";\n\n    /**\n     * <code>security.providers</code>\n     */\n    public static final String SECURITY_PROVIDERS_CONFIG = SecurityConfig.SECURITY_PROVIDERS_CONFIG;\n    private static final String SECURITY_PROVIDERS_DOC = SecurityConfig.SECURITY_PROVIDERS_DOC;\n\n    private static final AtomicInteger PRODUCER_CLIENT_ID_SEQUENCE = new AtomicInteger(1);\n\n    static {\n        CONFIG = new ConfigDef().define(BOOTSTRAP_SERVERS_CONFIG,\n                                        Type.LIST,\n                                        NO_DEFAULT_VALUE,\n                                        ConfigDef.ValidList.anyNonDuplicateValues(false, false),\n                                        Importance.HIGH,\n                                        CommonClientConfigs.BOOTSTRAP_SERVERS_DOC)\n                                .define(CLIENT_DNS_LOOKUP_CONFIG,\n                                        Type.STRING,\n                                        ClientDnsLookup.USE_ALL_DNS_IPS.toString(),\n                                        in(ClientDnsLookup.USE_ALL_DNS_IPS.toString(),\n                                           ClientDnsLookup.RESOLVE_CANONICAL_BOOTSTRAP_SERVERS_ONLY.toString()),\n                                        Importance.MEDIUM,\n                                        CommonClientConfigs.CLIENT_DNS_LOOKUP_DOC)\n                                .define(BUFFER_MEMORY_CONFIG, Type.LONG, 32 * 1024 * 1024L, atLeast(0L), Importance.HIGH, BUFFER_MEMORY_DOC)\n                                .define(RETRIES_CONFIG, Type.INT, Integer.MAX_VALUE, between(0, Integer.MAX_VALUE), Importance.HIGH, RETRIES_DOC)\n                                .define(ACKS_CONFIG,\n                                        Type.STRING,\n                                        \"all\",\n                                        in(\"all\", \"-1\", \"0\", \"1\"),\n                                        Importance.LOW,\n                                        ACKS_DOC)\n                                .define(COMPRESSION_TYPE_CONFIG, Type.STRING, CompressionType.NONE.name, in(Utils.enumOptions(CompressionType.class)), Importance.HIGH, COMPRESSION_TYPE_DOC)\n                                .define(COMPRESSION_GZIP_LEVEL_CONFIG, Type.INT, CompressionType.GZIP.defaultLevel(), CompressionType.GZIP.levelValidator(), Importance.MEDIUM, COMPRESSION_GZIP_LEVEL_DOC)\n                                .define(COMPRESSION_LZ4_LEVEL_CONFIG, Type.INT, CompressionType.LZ4.defaultLevel(), CompressionType.LZ4.levelValidator(), Importance.MEDIUM, COMPRESSION_LZ4_LEVEL_DOC)\n                                .define(COMPRESSION_ZSTD_LEVEL_CONFIG, Type.INT, CompressionType.ZSTD.defaultLevel(), CompressionType.ZSTD.levelValidator(), Importance.MEDIUM, COMPRESSION_ZSTD_LEVEL_DOC)\n                                .define(BATCH_SIZE_CONFIG, Type.INT, 16384, atLeast(0), Importance.MEDIUM, BATCH_SIZE_DOC)\n                                .define(PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_CONFIG, Type.BOOLEAN, true, Importance.LOW, PARTITIONER_ADAPTIVE_PARTITIONING_ENABLE_DOC)\n                                .define(PARTITIONER_AVAILABILITY_TIMEOUT_MS_CONFIG, Type.LONG, 0, atLeast(0), Importance.LOW, PARTITIONER_AVAILABILITY_TIMEOUT_MS_DOC)\n                                .define(PARTITIONER_IGNORE_KEYS_CONFIG, Type.BOOLEAN, false, Importance.MEDIUM, PARTITIONER_IGNORE_KEYS_DOC)\n                                .define(LINGER_MS_CONFIG, Type.LONG, 5, atLeast(0), Importance.MEDIUM, LINGER_MS_DOC)\n                                .define(DELIVERY_TIMEOUT_MS_CONFIG, Type.INT, 120 * 1000, atLeast(0), Importance.MEDIUM, DELIVERY_TIMEOUT_MS_DOC)\n                                .define(CLIENT_ID_CONFIG, Type.STRING, \"\", Importance.MEDIUM, CommonClientConfigs.CLIENT_ID_DOC)\n                                .define(SEND_BUFFER_CONFIG, Type.INT, 128 * 1024, atLeast(CommonClientConfigs.SEND_BUFFER_LOWER_BOUND), Importance.MEDIUM, CommonClientConfigs.SEND_BUFFER_DOC)\n                                .define(RECEIVE_BUFFER_CONFIG, Type.INT, 32 * 1024, atLeast(CommonClientConfigs.RECEIVE_BUFFER_LOWER_BOUND), Importance.MEDIUM, CommonClientConfigs.RECEIVE_BUFFER_DOC)\n                                .define(MAX_REQUEST_SIZE_CONFIG,",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.608681",
  "source_type": "github"
}