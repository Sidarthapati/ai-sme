{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_781",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "        lastError = null;\n    }\n\n    public synchronized void maybeTransitionToErrorState(RuntimeException exception) {\n        if (exception instanceof ClusterAuthorizationException\n                || exception instanceof TransactionalIdAuthorizationException\n                || exception instanceof ProducerFencedException\n                || exception instanceof UnsupportedVersionException\n                || exception instanceof InvalidPidMappingException) {\n            transitionToFatalError(exception);\n        } else if (isTransactional()) {\n            // RetriableExceptions from the Sender thread are converted to Abortable errors\n            // because they indicate that the transaction cannot be completed after all retry attempts.\n            // This conversion ensures the application layer treats these errors as abortable,\n            // preventing duplicate message delivery.\n            if (exception instanceof RetriableException ||\n                    exception instanceof InvalidTxnStateException) {\n                exception = new TransactionAbortableException(\"Transaction Request was aborted after exhausting retries.\", exception);\n            }\n\n            if (needToTriggerEpochBumpFromClient() && !isCompleting()) {\n                clientSideEpochBumpRequired = true;\n            }\n            transitionToAbortableError(exception);\n        }\n    }\n\n    synchronized void handleFailedBatch(ProducerBatch batch, RuntimeException exception, boolean adjustSequenceNumbers) {\n        maybeTransitionToErrorState(exception);\n        removeInFlightBatch(batch);\n\n        if (hasFatalError()) {\n            log.debug(\"Ignoring batch {} with producer id {}, epoch {}, and sequence number {} \" +\n                            \"since the producer is already in fatal error state\", batch, batch.producerId(),\n                    batch.producerEpoch(), batch.baseSequence(), exception);\n            return;\n        }\n\n        if (exception instanceof OutOfOrderSequenceException && !isTransactional()) {\n            log.error(\"The broker returned {} for topic-partition {} with producerId {}, epoch {}, and sequence number {}\",\n                    exception, batch.topicPartition, batch.producerId(), batch.producerEpoch(), batch.baseSequence());\n\n            // If we fail with an OutOfOrderSequenceException, we have a gap in the log. Bump the epoch for this\n            // partition, which will reset the sequence number to 0 and allow us to continue\n            requestIdempotentEpochBumpForPartition(batch.topicPartition);\n        } else if (exception instanceof UnknownProducerIdException) {\n            // If we get an UnknownProducerId for a partition, then the broker has no state for that producer. It will\n            // therefore accept a write with sequence number 0. We reset the sequence number for the partition here so\n            // that the producer can continue after aborting the transaction. All inflight-requests to this partition\n            // will also fail with an UnknownProducerId error, so the sequence will remain at 0. Note that if the\n            // broker supports bumping the epoch, we will later reset all sequence numbers after calling InitProducerId\n            resetSequenceForPartition(batch.topicPartition);\n        } else {\n            if (adjustSequenceNumbers) {\n                if (!isTransactional()) {\n                    requestIdempotentEpochBumpForPartition(batch.topicPartition);\n                } else {\n                    txnPartitionMap.adjustSequencesDueToFailedBatch(batch);\n                }\n            }\n        }\n    }\n\n    synchronized boolean hasInflightBatches(TopicPartition topicPartition) {\n        return txnPartitionMap.getOrCreate(topicPartition).hasInflightBatches();\n    }\n\n    synchronized boolean hasStaleProducerIdAndEpoch(TopicPartition topicPartition) {\n        return !producerIdAndEpoch.equals(txnPartitionMap.getOrCreate(topicPartition).producerIdAndEpoch());\n    }\n\n    synchronized boolean hasUnresolvedSequences() {\n        return !partitionsWithUnresolvedSequences.isEmpty();\n    }\n\n    synchronized boolean hasUnresolvedSequence(TopicPartition topicPartition) {\n        return partitionsWithUnresolvedSequences.containsKey(topicPartition);\n    }\n\n    synchronized void markSequenceUnresolved(ProducerBatch batch) {\n        int nextSequence = batch.lastSequence() + 1;\n        partitionsWithUnresolvedSequences.compute(batch.topicPartition,\n            (k, v) -> v == null ? nextSequence : Math.max(v, nextSequence));\n        log.debug(\"Marking partition {} unresolved with next sequence number {}\", batch.topicPartition,\n                partitionsWithUnresolvedSequences.get(batch.topicPartition));\n    }\n\n    // Attempts to resolve unresolved sequences. If all in-flight requests are complete and some partitions are still\n    // unresolved, either bump the epoch if possible, or transition to a fatal error\n    synchronized void maybeResolveSequences() {\n        for (Iterator<TopicPartition> iter = partitionsWithUnresolvedSequences.keySet().iterator(); iter.hasNext(); ) {\n            TopicPartition topicPartition = iter.next();\n            if (!hasInflightBatches(topicPartition)) {\n                // The partition has been fully drained. At this point, the last ack'd sequence should be one less than\n                // next sequence destined for the partition. If so, the partition is fully resolved. If not, we should\n                // reset the sequence number if necessary.\n                if (isNextSequence(topicPartition, sequenceNumber(topicPartition))) {\n                    // This would happen when a batch was expired, but subsequent batches succeeded.\n                    iter.remove();\n                } else {\n                    // We would enter this branch if all in flight batches were ultimately expired in the producer.\n                    if (isTransactional()) {\n                        // For the transactional producer, we bump the epoch if possible, otherwise we transition to a fatal error\n                        String unackedMessagesErr = \"The client hasn't received acknowledgment for some previously \" +\n                                \"sent messages and can no longer retry them. \";\n                        KafkaException abortableException = new KafkaException(unackedMessagesErr + \"It is safe to abort \" +\n                                \"the transaction and continue.\");\n                        KafkaException fatalException = new KafkaException(unackedMessagesErr + \"It isn't safe to continue.\");\n\n                        transitionToAbortableErrorOrFatalError(abortableException, fatalException);\n                    } else {\n                        // For the idempotent producer, bump the epoch\n                        log.info(\"No inflight batches remaining for {}, last ack'd sequence for partition is {}, next sequence is {}. \" +\n                                        \"Going to bump epoch and reset sequence numbers.\", topicPartition,\n                                lastAckedSequence(topicPartition).orElse(TxnPartitionEntry.NO_LAST_ACKED_SEQUENCE_NUMBER), sequenceNumber(topicPartition));\n                        requestIdempotentEpochBumpForPartition(topicPartition);\n                    }\n\n                    iter.remove();\n                }\n            }\n        }\n    }\n\n    private boolean isNextSequence(TopicPartition topicPartition, int sequence) {\n        return sequence - lastAckedSequence(topicPartition).orElse(TxnPartitionEntry.NO_LAST_ACKED_SEQUENCE_NUMBER) == 1;\n    }\n\n    private boolean isNextSequenceForUnresolvedPartition(TopicPartition topicPartition, int sequence) {\n        return this.hasUnresolvedSequence(topicPartition) &&\n                sequence == this.partitionsWithUnresolvedSequences.get(topicPartition);\n    }\n\n    synchronized TxnRequestHandler nextRequest(boolean hasIncompleteBatches) {\n        if (!newPartitionsInTransaction.isEmpty())\n            enqueueRequest(addPartitionsToTransactionHandler());\n\n        TxnRequestHandler nextRequestHandler = pendingRequests.peek();\n        if (nextRequestHandler == null)\n            return null;\n\n        // Do not send the EndTxn until all batches have been flushed\n        if (nextRequestHandler.isEndTxn() && hasIncompleteBatches)\n            return null;\n\n        pendingRequests.poll();\n        if (maybeTerminateRequestWithError(nextRequestHandler)) {\n            log.trace(\"Not sending transactional request {} because we are in an error state\",\n                    nextRequestHandler.requestBuilder());\n            return null;",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L781-L930",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 781,
  "end_line": 930,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}