{
  "id": "kafka_clients_src_main_resources_common_message_README.md_1",
  "title": "kafka/clients/src/main/resources/common/message/README.md",
  "content": "Apache Kafka Message Definitions\n================================\n\nIntroduction\n------------\nThe JSON files in this directory define the Apache Kafka message protocol.\nThis protocol describes what information clients and servers send to each\nother, and how it is serialized.  Note that this version of JSON supports\ncomments.  Comments begin with a double forward slash.\n\nWhen Kafka is compiled, these specification files are translated into Java code\nto read and write messages.  Any change to these JSON files will trigger a\nrecompilation of this generated code.\n\nThese specification files replace an older system where hand-written\nserialization code was used.  Over time, we will migrate all messages to using\nautomatically generated serialization and deserialization code.\n\nRequests and Responses\n----------------------\nThe Kafka protocol features requests and responses.  Requests are sent to a\nserver in order to get a response.  Each request is uniquely identified by a\n16-bit integer called the \"api key\".  The API key of the response will always\nmatch that of the request.\n\nEach message has a unique 16-bit version number.  The schema might be different\nfor each version of the message.  Sometimes, the version is incremented even\nthough the schema has not changed.  This may indicate that the server should\nbehave differently in some way.  The version of a response must always match\nthe version of the corresponding request.\n\nEach request or response has a top-level field named \"validVersions.\"  This\nspecifies the versions of the protocol that our code understands.  For example,\nspecifying \"0-2\" indicates that we understand versions 0, 1, and 2.  You must\nalways specify the highest message version which is supported.\n\nDropping support for old message versions is no longer allowed without a KIP.\nTherefore, please be careful not to increase the lower end of the version\nsupport interval for any message.\n\nMessageData Objects\n-------------------\nUsing the JSON files in this directory, we generate Java code for MessageData\nobjects.  These objects store request and response data for kafka.  MessageData\nobjects do not contain a version number.  Instead, a single MessageData object\nrepresents every possible version of a Message.  This makes working with\nmessages more convenient, because the same code path can be used for every\nversion of a message.\n\nFields\n------\nEach message contains an array of fields.  Fields specify the data that should\nbe sent with the message.  In general, fields have a name, a type, and version\ninformation associated with them.\n\nThe order that fields appear in a message is important.  Fields which come\nfirst in the message definition will be sent first over the network.  Changing\nthe order of the fields in a message is an incompatible change.\n\nIn each new message version, we may add or subtract fields.  For example, if we\nare creating a new version 3 of a message, we can add a new field with the\nversion spec \"3+\".  This specifies that the field only appears in version 3 and\nlater.  If a field is being removed, we should change its version from \"0+\" to\n\"0-2\" to indicate that it will not appear in version 3 and later.\n\nField Types\n-----------\nThere are several primitive field types available.\n\n* \"bool\": either true or false.\n\n* \"int8\": an 8-bit integer.\n\n* \"int16\": a 16-bit integer.\n\n* \"uint16\": a 16-bit unsigned integer.\n\n* \"int32\": a 32-bit integer.\n\n* \"uint32\": a 32-bit unsigned integer.\n\n* \"int64\": a 64-bit integer.\n\n* \"float64\": is a double-precision floating point number (IEEE 754).\n\n* \"string\": a UTF-8 string.\n\n* \"uuid\": a type 4 immutable universally unique identifier.\n\n* \"bytes\": binary data.\n\n* \"records\": recordset such as memory recordset.\n\n* \"struct\": a composite object consisting of one or more fields.\n\nIn addition to these primitive field types, there is also an array type.  Array\ntypes start with a \"[]\" and end with the name of the element type.  For\nexample, []Foo declares an array of \"Foo\" objects.  Array fields have their own\narray of fields, which specifies what is in the contained objects.\n\nFor information about how fields are serialized, see the [Kafka Protocol\nGuide](https://kafka.apache.org/protocol.html).\n\nNullable Fields\n---------------\nBooleans, ints, floats and uuid can never be null. Uuid fields use a special zero uuid\nvalue (all bits set to 0) as a sentinel to represent \"no UUID\" instead of null. However,\nfields that are strings, bytes, records, struct, or arrays may optionally be \"nullable\".\nWhen a field is \"nullable\", that simply means that we are prepared to serialize and\ndeserialize null entries for that field.\n\nIf you want to declare a field as nullable, you set \"nullableVersions\" for that\nfield.  Nullability is implemented as a version range in order to accommodate a\nvery common pattern in Kafka where a field that was originally not nullable\nbecomes nullable in a later version.\n\nIf a field is declared as non-nullable, and it is present in the message\nversion you are using, you should set it to a non-null value before serializing\nthe message.  Otherwise, you will get a runtime error.\n\nTagged Fields\n-------------\nTagged fields are an extension to the Kafka protocol which allows optional data\nto be attached to messages.  Tagged fields can appear at the root level of\nmessages, or within any structure in the message.\n\nUnlike mandatory fields, tagged fields can be added to message versions that\nalready exists.  Older servers will ignore new tagged fields which they do not\nunderstand.\n\nIn order to make a field tagged, set a \"tag\" for the field, and also set up\ntagged versions for the field.  The taggedVersions you specify should be\nopen-ended-- that is, they should specify a start version, but not an end\nversion.\n\nYou can remove support for a tagged field from a specific version of a message,\nbut you can't reuse a tag once it has been used for something else.  Once tags\nhave been used for something, they can't be used for anything else, without\nbreaking compatibility.\n\nNote that tagged fields can only be added to \"flexible\" message versions.\n\n#### Default Value Handling for Tagged Fields\n\nIn Kafka's serialization mechanism, a tagged field may be omitted from the serialized message \nif all its associated fields are equal to their default values, whether those defaults are explicit \nor implicit. This behavior optimizes message size by avoiding the transmission of redundant data.\n\nFlexible Versions\n-----------------",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/resources/common/message/README.md#L1-L150",
  "file_path": "clients/src/main/resources/common/message/README.md",
  "repo_name": "kafka",
  "language": "markdown",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.672908",
  "source_type": "github"
}