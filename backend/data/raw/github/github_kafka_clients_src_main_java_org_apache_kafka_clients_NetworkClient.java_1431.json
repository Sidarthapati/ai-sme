{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_1431",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "                return reconnectBackoffMs;\n\n            if (connectionStates.canConnect(nodeConnectionId, now)) {\n                // We don't have a connection to this node right now, make one\n                log.debug(\"Initialize connection to node {} for sending telemetry request\", node);\n                initiateConnect(node, now);\n                return reconnectBackoffMs;\n            }\n\n            // In either case, we just need to wait for a network event to let us know the selected\n            // connection might be usable again.\n            return Long.MAX_VALUE;\n        }\n\n        public void handleResponse(GetTelemetrySubscriptionsResponse response) {\n            clientTelemetrySender.handleResponse(response);\n        }\n\n        public void handleResponse(PushTelemetryResponse response) {\n            clientTelemetrySender.handleResponse(response);\n        }\n\n        public void handleFailedRequest(ApiKeys apiKey, KafkaException maybeFatalException) {\n            if (apiKey == ApiKeys.GET_TELEMETRY_SUBSCRIPTIONS)\n                clientTelemetrySender.handleFailedGetTelemetrySubscriptionsRequest(maybeFatalException);\n            else if (apiKey == ApiKeys.PUSH_TELEMETRY)\n                clientTelemetrySender.handleFailedPushTelemetryRequest(maybeFatalException);\n            else\n                throw new IllegalStateException(\"Invalid api key for failed telemetry request\");\n        }\n\n        public void close() {\n            try {\n                clientTelemetrySender.close();\n            } catch (Exception exception) {\n                log.error(\"Failed to close client telemetry sender\", exception);\n            }\n        }\n    }\n\n    @Override\n    public ClientRequest newClientRequest(String nodeId,\n                                          AbstractRequest.Builder<?> requestBuilder,\n                                          long createdTimeMs,\n                                          boolean expectResponse) {\n        return newClientRequest(nodeId, requestBuilder, createdTimeMs, expectResponse, defaultRequestTimeoutMs, null);\n    }\n\n    // visible for testing\n    int nextCorrelationId() {\n        if (SaslClientAuthenticator.isReserved(correlation)) {\n            // the numeric overflow is fine as negative values is acceptable\n            correlation = SaslClientAuthenticator.MAX_RESERVED_CORRELATION_ID + 1;\n        }\n        return correlation++;\n    }\n\n    // visible for testing\n    Node telemetryConnectedNode() {\n        return telemetrySender.stickyNode;\n    }\n\n    @Override\n    public ClientRequest newClientRequest(String nodeId,\n                                          AbstractRequest.Builder<?> requestBuilder,\n                                          long createdTimeMs,\n                                          boolean expectResponse,\n                                          int requestTimeoutMs,\n                                          RequestCompletionHandler callback) {\n        return new ClientRequest(nodeId, requestBuilder, nextCorrelationId(), clientId, createdTimeMs, expectResponse,\n                requestTimeoutMs, callback);\n    }\n\n    public boolean discoverBrokerVersions() {\n        return discoverBrokerVersions;\n    }\n\n    static class InFlightRequest {\n        final RequestHeader header;\n        final String destination;\n        final RequestCompletionHandler callback;\n        final boolean expectResponse;\n        final AbstractRequest request;\n        final boolean isInternalRequest; // used to flag requests which are initiated internally by NetworkClient\n        final Send send;\n        final long sendTimeMs;\n        final long createdTimeMs;\n        final long requestTimeoutMs;\n        long throttleTimeMs;\n\n        public InFlightRequest(ClientRequest clientRequest,\n                               RequestHeader header,\n                               boolean isInternalRequest,\n                               AbstractRequest request,\n                               Send send,\n                               long sendTimeMs) {\n            this(header,\n                 clientRequest.requestTimeoutMs(),\n                 clientRequest.createdTimeMs(),\n                 clientRequest.destination(),\n                 clientRequest.callback(),\n                 clientRequest.expectResponse(),\n                 isInternalRequest,\n                 request,\n                 send,\n                 sendTimeMs);\n        }\n\n        public InFlightRequest(RequestHeader header,\n                               int requestTimeoutMs,\n                               long createdTimeMs,\n                               String destination,\n                               RequestCompletionHandler callback,\n                               boolean expectResponse,\n                               boolean isInternalRequest,\n                               AbstractRequest request,\n                               Send send,\n                               long sendTimeMs) {\n            this.header = header;\n            this.requestTimeoutMs = requestTimeoutMs;\n            this.createdTimeMs = createdTimeMs;\n            this.destination = destination;\n            this.callback = callback;\n            this.expectResponse = expectResponse;\n            this.isInternalRequest = isInternalRequest;\n            this.request = request;\n            this.send = send;\n            this.sendTimeMs = sendTimeMs;\n        }\n\n        public long timeElapsedSinceSendMs(long currentTimeMs) {\n            return Math.max(0, currentTimeMs - sendTimeMs);\n        }\n\n        public long throttleTimeMs() {\n            return throttleTimeMs;\n        }\n\n        public long timeElapsedSinceCreateMs(long currentTimeMs) {\n            return Math.max(0, currentTimeMs - createdTimeMs);\n        }\n\n        public ClientResponse completed(AbstractResponse response, long timeMs) {\n            return new ClientResponse(header, callback, destination, createdTimeMs, timeMs,\n                    false, null, null, response);\n        }\n\n        public ClientResponse timedOut(long timeMs) {\n            // A timed out request is considered disconnected as well\n            return new ClientResponse(header, callback, destination, createdTimeMs, timeMs,",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L1431-L1580",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1431,
  "end_line": 1580,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}