{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "     *\n     * When an invalid state transition is detected during execution on an <em>application</em> thread, the\n     * {@link #currentState} is <em>not updated</em> and an {@link IllegalStateException} is thrown. This gives the\n     * application the opportunity to fix the issue without permanently poisoning the state of the\n     * transaction manager. The {@link Producer} API calls that perform a state transition include:\n     *\n     * <ul>\n     *     <li>{@link Producer#initTransactions()} calls {@link #initializeTransactions(boolean)}</li>\n     *     <li>{@link Producer#beginTransaction()} calls {@link #beginTransaction()}</li>\n     *     <li>{@link Producer#commitTransaction()}} calls {@link #beginCommit()}</li>\n     *     <li>{@link Producer#abortTransaction()} calls {@link #beginAbort()}\n     *     </li>\n     *     <li>{@link Producer#sendOffsetsToTransaction(Map, ConsumerGroupMetadata)} calls\n     *         {@link #sendOffsetsToTransaction(Map, ConsumerGroupMetadata)}\n     *     </li>\n     *     <li>{@link Producer#send(ProducerRecord)} (and its variants) calls\n     *         {@link #maybeAddPartition(TopicPartition)} and\n     *         {@link #maybeTransitionToErrorState(RuntimeException)}\n     *     </li>\n     * </ul>\n     *\n     * <p/>\n     *\n     * The {@link Producer} is implemented such that much of its work delegated to and performed asynchronously on the\n     * <em>{@link Sender}</em> thread. This includes record batching, network I/O, broker response handlers, etc. If an\n     * invalid state transition is detected in the <em>{@link Sender}</em> thread, in addition to throwing an\n     * {@link IllegalStateException}, the transaction manager intentionally \"poisons\" itself by setting its\n     * {@link #currentState} to {@link State#FATAL_ERROR}, a state from which it cannot recover.\n     *\n     * <p/>\n     *\n     * It's important to prevent possible corruption when the transaction manager has determined that it is in a\n     * fatal state. Subsequent transaction operations attempted via either the <em>application</em> or the\n     * <em>{@link Sender}</em> thread should fail. This is achieved when these operations invoke the\n     * {@link #maybeFailWithError()} method, as it causes a {@link KafkaException} to be thrown, ensuring the stated\n     * transactional guarantees are not violated.\n     *\n     * <p/>\n     *\n     * See KAFKA-14831 for more detail.\n     *\n     * @return {@code true} to set state to {@link State#FATAL_ERROR} before throwing an exception,\n     *         {@code false} to throw an exception without first changing the state\n     */\n    protected boolean shouldPoisonStateOnInvalidTransition() {\n        return Thread.currentThread() instanceof Sender.SenderThread;\n    }\n\n    synchronized TransactionalRequestResult initializeTransactions(ProducerIdAndEpoch producerIdAndEpoch) {\n        return initializeTransactions(producerIdAndEpoch, false);\n    }\n\n    public synchronized TransactionalRequestResult initializeTransactions(boolean keepPreparedTxn) {\n        return initializeTransactions(ProducerIdAndEpoch.NONE, keepPreparedTxn);\n    }\n\n    synchronized TransactionalRequestResult initializeTransactions(\n        ProducerIdAndEpoch producerIdAndEpoch,\n        boolean keepPreparedTxn\n    ) {\n        maybeFailWithError();\n\n        boolean isEpochBump = producerIdAndEpoch != ProducerIdAndEpoch.NONE;\n        return handleCachedTransactionRequestResult(() -> {\n            // If this is an epoch bump, we will transition the state as part of handling the EndTxnRequest\n            if (!isEpochBump) {\n                transitionTo(State.INITIALIZING);\n                log.info(\"Invoking InitProducerId for the first time in order to acquire a producer ID\");\n                if (keepPreparedTxn) {\n                    log.info(\"Invoking InitProducerId with keepPreparedTxn set to true for 2PC transactions\");\n                }\n            } else {\n                log.info(\"Invoking InitProducerId with current producer ID and epoch {} in order to bump the epoch\", producerIdAndEpoch);\n            }\n            InitProducerIdRequestData requestData = new InitProducerIdRequestData()\n                    .setTransactionalId(transactionalId)\n                    .setTransactionTimeoutMs(transactionTimeoutMs)\n                    .setProducerId(producerIdAndEpoch.producerId)\n                    .setProducerEpoch(producerIdAndEpoch.epoch)\n                    .setEnable2Pc(enable2PC)\n                    .setKeepPreparedTxn(keepPreparedTxn);\n\n            InitProducerIdHandler handler = new InitProducerIdHandler(new InitProducerIdRequest.Builder(requestData),\n                    isEpochBump);\n            enqueueRequest(handler);\n            return handler.result;\n        }, State.INITIALIZING, \"initTransactions\");\n    }\n\n    public synchronized void beginTransaction() {\n        ensureTransactional();\n        throwIfPendingState(TransactionOperation.BEGIN_TRANSACTION);\n        maybeFailWithError();\n        transitionTo(State.IN_TRANSACTION);\n    }\n\n    /**\n     * Prepare a transaction for a two-phase commit.\n     * This transitions the transaction to the PREPARED_TRANSACTION state.\n     * The preparedTxnState is set with the current producer ID and epoch.\n     */\n    public synchronized void prepareTransaction() {\n        ensureTransactional();\n        throwIfPendingState(TransactionOperation.PREPARE_TRANSACTION);\n        maybeFailWithError();\n        transitionTo(State.PREPARED_TRANSACTION);\n        this.preparedTxnState = new ProducerIdAndEpoch(\n            this.producerIdAndEpoch.producerId,\n            this.producerIdAndEpoch.epoch\n        );\n    }\n\n    public synchronized TransactionalRequestResult beginCommit() {\n        return handleCachedTransactionRequestResult(() -> {\n            maybeFailWithError();\n            transitionTo(State.COMMITTING_TRANSACTION);\n            return beginCompletingTransaction(TransactionResult.COMMIT);\n        }, State.COMMITTING_TRANSACTION, \"commitTransaction\");\n    }\n\n    public synchronized TransactionalRequestResult beginAbort() {\n        return handleCachedTransactionRequestResult(() -> {\n            if (currentState != State.ABORTABLE_ERROR)\n                maybeFailWithError();\n            transitionTo(State.ABORTING_TRANSACTION);\n\n            // We're aborting the transaction, so there should be no need to add new partitions\n            newPartitionsInTransaction.clear();\n            return beginCompletingTransaction(TransactionResult.ABORT);\n        }, State.ABORTING_TRANSACTION, \"abortTransaction\");\n    }\n\n    private TransactionalRequestResult beginCompletingTransaction(TransactionResult transactionResult) {\n        if (!newPartitionsInTransaction.isEmpty())\n            enqueueRequest(addPartitionsToTransactionHandler());\n\n        EndTxnRequest.Builder builder = new EndTxnRequest.Builder(\n            new EndTxnRequestData()\n                .setTransactionalId(transactionalId)\n                .setProducerId(producerIdAndEpoch.producerId)\n                .setProducerEpoch(producerIdAndEpoch.epoch)\n                .setCommitted(transactionResult.id),\n            isTransactionV2Enabled\n        );\n\n        // Maybe update the transaction version here before we enqueue the EndTxn request so there are no races with\n        // completion of the EndTxn request. Since this method may update clientSideEpochBumpRequired, we want to update\n        // before the check below, but we also want to call it after the EndTxnRequest.Builder so we complete the transaction\n        // with the same version as it started.\n        maybeUpdateTransactionV2Enabled(false);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}