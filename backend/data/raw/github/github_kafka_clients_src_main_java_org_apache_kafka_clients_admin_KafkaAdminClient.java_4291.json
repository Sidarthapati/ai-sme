{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_4291",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new DescribeClientQuotasResult(future);\n    }\n\n    @Override\n    public AlterClientQuotasResult alterClientQuotas(Collection<ClientQuotaAlteration> entries, AlterClientQuotasOptions options) {\n        Map<ClientQuotaEntity, KafkaFutureImpl<Void>> futures = new HashMap<>(entries.size());\n        for (ClientQuotaAlteration entry : entries) {\n            futures.put(entry.entity(), new KafkaFutureImpl<>());\n        }\n\n        final long now = time.milliseconds();\n        runnable.call(new Call(\"alterClientQuotas\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedNodeProvider()) {\n\n            @Override\n            AlterClientQuotasRequest.Builder createRequest(int timeoutMs) {\n                return new AlterClientQuotasRequest.Builder(entries, options.validateOnly());\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                AlterClientQuotasResponse response = (AlterClientQuotasResponse) abstractResponse;\n                response.complete(futures);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        }, now);\n\n        return new AlterClientQuotasResult(Collections.unmodifiableMap(futures));\n    }\n\n    @Override\n    public DescribeUserScramCredentialsResult describeUserScramCredentials(List<String> users, DescribeUserScramCredentialsOptions options) {\n        final KafkaFutureImpl<DescribeUserScramCredentialsResponseData> dataFuture = new KafkaFutureImpl<>();\n        final long now = time.milliseconds();\n        Call call = new Call(\"describeUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedNodeProvider()) {\n            @Override\n            public DescribeUserScramCredentialsRequest.Builder createRequest(final int timeoutMs) {\n                final DescribeUserScramCredentialsRequestData requestData = new DescribeUserScramCredentialsRequestData();\n\n                if (users != null && !users.isEmpty()) {\n                    final List<UserName> userNames = new ArrayList<>(users.size());\n\n                    for (final String user : users) {\n                        if (user != null) {\n                            userNames.add(new UserName().setName(user));\n                        }\n                    }\n\n                    requestData.setUsers(userNames);\n                }\n\n                return new DescribeUserScramCredentialsRequest.Builder(requestData);\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                DescribeUserScramCredentialsResponse response = (DescribeUserScramCredentialsResponse) abstractResponse;\n                DescribeUserScramCredentialsResponseData data = response.data();\n                short messageLevelErrorCode = data.errorCode();\n                if (messageLevelErrorCode != Errors.NONE.code()) {\n                    dataFuture.completeExceptionally(Errors.forCode(messageLevelErrorCode).exception(data.errorMessage()));\n                } else {\n                    dataFuture.complete(data);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                dataFuture.completeExceptionally(throwable);\n            }\n        };\n        runnable.call(call, now);\n        return new DescribeUserScramCredentialsResult(dataFuture);\n    }\n\n    @Override\n    public AlterUserScramCredentialsResult alterUserScramCredentials(List<UserScramCredentialAlteration> alterations,\n                                                                     AlterUserScramCredentialsOptions options) {\n        final long now = time.milliseconds();\n        final Map<String, KafkaFutureImpl<Void>> futures = new HashMap<>();\n        for (UserScramCredentialAlteration alteration : alterations) {\n            futures.put(alteration.user(), new KafkaFutureImpl<>());\n        }\n        final Map<String, Exception> userIllegalAlterationExceptions = new HashMap<>();\n        // We need to keep track of users with deletions of an unknown SCRAM mechanism\n        final String usernameMustNotBeEmptyMsg = \"Username must not be empty\";\n        String passwordMustNotBeEmptyMsg = \"Password must not be empty\";\n        final String unknownScramMechanismMsg = \"Unknown SCRAM mechanism\";\n        alterations.stream().filter(a -> a instanceof UserScramCredentialDeletion).forEach(alteration -> {\n            final String user = alteration.user();\n            if (user == null || user.isEmpty()) {\n                userIllegalAlterationExceptions.put(alteration.user(), new UnacceptableCredentialException(usernameMustNotBeEmptyMsg));\n            } else {\n                UserScramCredentialDeletion deletion = (UserScramCredentialDeletion) alteration;\n                ScramMechanism mechanism = deletion.mechanism();\n                if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n                    userIllegalAlterationExceptions.put(user, new UnsupportedSaslMechanismException(unknownScramMechanismMsg));\n                }\n            }\n        });\n        // Creating an upsertion may throw InvalidKeyException or NoSuchAlgorithmException,\n        // so keep track of which users are affected by such a failure so we can fail all their alterations later\n        final Map<String, Map<ScramMechanism, AlterUserScramCredentialsRequestData.ScramCredentialUpsertion>> userInsertions = new HashMap<>();\n        alterations.stream().filter(a -> a instanceof UserScramCredentialUpsertion)\n            .filter(alteration -> !userIllegalAlterationExceptions.containsKey(alteration.user()))\n            .forEach(alteration -> {\n                final String user = alteration.user();\n                if (user == null || user.isEmpty()) {\n                    userIllegalAlterationExceptions.put(alteration.user(), new UnacceptableCredentialException(usernameMustNotBeEmptyMsg));\n                } else {\n                    UserScramCredentialUpsertion upsertion = (UserScramCredentialUpsertion) alteration;\n                    try {\n                        byte[] password = upsertion.password();\n                        if (password == null || password.length == 0) {\n                            userIllegalAlterationExceptions.put(user, new UnacceptableCredentialException(passwordMustNotBeEmptyMsg));\n                        } else {\n                            ScramMechanism mechanism = upsertion.credentialInfo().mechanism();\n                            if (mechanism == null || mechanism == ScramMechanism.UNKNOWN) {\n                                userIllegalAlterationExceptions.put(user, new UnsupportedSaslMechanismException(unknownScramMechanismMsg));\n                            } else {\n                                userInsertions.putIfAbsent(user, new HashMap<>());\n                                userInsertions.get(user).put(mechanism, getScramCredentialUpsertion(upsertion));\n                            }\n                        }\n                    } catch (NoSuchAlgorithmException e) {\n                        // we might overwrite an exception from a previous alteration, but we don't really care\n                        // since we just need to mark this user as having at least one illegal alteration\n                        // and make an exception instance available for completing the corresponding future exceptionally\n                        userIllegalAlterationExceptions.put(user, new UnsupportedSaslMechanismException(unknownScramMechanismMsg));\n                    } catch (InvalidKeyException e) {\n                        // generally shouldn't happen since we deal with the empty password case above,\n                        // but we still need to catch/handle it\n                        userIllegalAlterationExceptions.put(user, new UnacceptableCredentialException(e.getMessage(), e));\n                    }\n                }\n            });\n\n        // submit alterations only for users that do not have an illegal alteration as identified above\n        Call call = new Call(\"alterUserScramCredentials\", calcDeadlineMs(now, options.timeoutMs()),",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L4291-L4440",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 4291,
  "end_line": 4440,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}