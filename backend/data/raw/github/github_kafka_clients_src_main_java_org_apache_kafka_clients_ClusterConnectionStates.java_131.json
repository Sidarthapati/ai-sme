{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_ClusterConnectionStates.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "content": "     * Check whether a connection is either being established or awaiting API version information.\n     * @param id The id of the node to check\n     * @return true if the node is either connecting or has connected and is awaiting API versions, false otherwise\n     */\n    public boolean isPreparingConnection(String id) {\n        NodeConnectionState state = nodeState.get(id);\n        return state != null &&\n                (state.state == ConnectionState.CONNECTING || state.state == ConnectionState.CHECKING_API_VERSIONS);\n    }\n\n    /**\n     * Enter the connecting state for the given connection, moving to a new resolved address if necessary.\n     * @param id the id of the connection\n     * @param now the current time in ms\n     * @param host the host of the connection, to be resolved internally if needed\n     */\n    public void connecting(String id, long now, String host) {\n        NodeConnectionState connectionState = nodeState.get(id);\n        if (connectionState != null && connectionState.host().equals(host)) {\n            connectionState.lastConnectAttemptMs = now;\n            connectionState.state = ConnectionState.CONNECTING;\n            // Move to next resolved address, or if addresses are exhausted, mark node to be re-resolved\n            connectionState.moveToNextAddress();\n            connectingNodes.add(id);\n            return;\n        } else if (connectionState != null) {\n            log.info(\"Hostname for node {} changed from {} to {}.\", id, connectionState.host(), host);\n        }\n\n        // Create a new NodeConnectionState if nodeState does not already contain one\n        // for the specified id or if the hostname associated with the node id changed.\n        nodeState.put(id, new NodeConnectionState(ConnectionState.CONNECTING, now,\n                reconnectBackoff.backoff(0), connectionSetupTimeout.backoff(0), host, hostResolver, log));\n        connectingNodes.add(id);\n    }\n\n    /**\n     * Returns a resolved address for the given connection, resolving it if necessary.\n     * @param id the id of the connection\n     * @throws UnknownHostException if the address was not resolvable\n     */\n    public InetAddress currentAddress(String id) throws UnknownHostException {\n        return nodeState(id).currentAddress();\n    }\n\n    /**\n     * Enter the disconnected state for the given node.\n     * @param id the connection we have disconnected\n     * @param now the current time in ms\n     */\n    public void disconnected(String id, long now) {\n        NodeConnectionState nodeState = nodeState(id);\n        nodeState.lastConnectAttemptMs = now;\n        updateReconnectBackoff(nodeState);\n        if (nodeState.state == ConnectionState.CONNECTING) {\n            updateConnectionSetupTimeout(nodeState);\n            connectingNodes.remove(id);\n        } else {\n            resetConnectionSetupTimeout(nodeState);\n            if (nodeState.state.isConnected()) {\n                // If a connection had previously been established, clear the addresses to trigger a new DNS resolution\n                // because the node IPs may have changed\n                nodeState.clearAddresses();\n            }\n        }\n        nodeState.state = ConnectionState.DISCONNECTED;\n    }\n\n    /**\n     * Indicate that the connection is throttled until the specified deadline.\n     * @param id the connection to be throttled\n     * @param throttleUntilTimeMs the throttle deadline in milliseconds\n     */\n    public void throttle(String id, long throttleUntilTimeMs) {\n        NodeConnectionState state = nodeState.get(id);\n        // The throttle deadline should never regress.\n        if (state != null && state.throttleUntilTimeMs < throttleUntilTimeMs) {\n            state.throttleUntilTimeMs = throttleUntilTimeMs;\n        }\n    }\n\n    /**\n     * Return the remaining throttling delay in milliseconds if throttling is in progress. Return 0, otherwise.\n     * @param id the connection to check\n     * @param now the current time in ms\n     */\n    public long throttleDelayMs(String id, long now) {\n        NodeConnectionState state = nodeState.get(id);\n        if (state != null && state.throttleUntilTimeMs > now) {\n            return state.throttleUntilTimeMs - now;\n        } else {\n            return 0;\n        }\n    }\n\n    /**\n     * Return the number of milliseconds to wait, based on the connection state and the throttle time, before\n     * attempting to send data. If the connection has been established but being throttled, return throttle delay.\n     * Otherwise, return connection delay.\n     * @param id the connection to check\n     * @param now the current time in ms\n     */\n    public long pollDelayMs(String id, long now) {\n        long throttleDelayMs = throttleDelayMs(id, now);\n        if (isConnected(id) && throttleDelayMs > 0) {\n            return throttleDelayMs;\n        } else {\n            return connectionDelay(id, now);\n        }\n    }\n\n    /**\n     * Enter the checking_api_versions state for the given node.\n     * @param id the connection identifier\n     */\n    public void checkingApiVersions(String id) {\n        NodeConnectionState nodeState = nodeState(id);\n        nodeState.state = ConnectionState.CHECKING_API_VERSIONS;\n        resetConnectionSetupTimeout(nodeState);\n        connectingNodes.remove(id);\n    }\n\n    /**\n     * Enter the ready state for the given node.\n     * @param id the connection identifier\n     */\n    public void ready(String id) {\n        NodeConnectionState nodeState = nodeState(id);\n        nodeState.state = ConnectionState.READY;\n        nodeState.authenticationException = null;\n        resetReconnectBackoff(nodeState);\n        resetConnectionSetupTimeout(nodeState);\n        connectingNodes.remove(id);\n    }\n\n    /**\n     * Enter the authentication failed state for the given node.\n     * @param id the connection identifier\n     * @param now the current time in ms\n     * @param exception the authentication exception\n     */\n    public void authenticationFailed(String id, long now, AuthenticationException exception) {\n        NodeConnectionState nodeState = nodeState(id);\n        nodeState.authenticationException = exception;\n        nodeState.state = ConnectionState.AUTHENTICATION_FAILED;\n        nodeState.lastConnectAttemptMs = now;\n        updateReconnectBackoff(nodeState);\n    }\n\n    /**",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/ClusterConnectionStates.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.577459",
  "source_type": "github"
}