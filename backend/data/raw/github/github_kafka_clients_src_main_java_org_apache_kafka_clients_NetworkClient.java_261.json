{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_NetworkClient.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "content": "                         long reconnectBackoffMs,\n                         long reconnectBackoffMax,\n                         int socketSendBuffer,\n                         int socketReceiveBuffer,\n                         int defaultRequestTimeoutMs,\n                         long connectionSetupTimeoutMs,\n                         long connectionSetupTimeoutMaxMs,\n                         Time time,\n                         boolean discoverBrokerVersions,\n                         ApiVersions apiVersions,\n                         LogContext logContext,\n                         MetadataRecoveryStrategy metadataRecoveryStrategy) {\n        this(metadataUpdater,\n             null,\n             selector,\n             clientId,\n             maxInFlightRequestsPerConnection,\n             reconnectBackoffMs,\n             reconnectBackoffMax,\n             socketSendBuffer,\n             socketReceiveBuffer,\n             defaultRequestTimeoutMs,\n             connectionSetupTimeoutMs,\n             connectionSetupTimeoutMaxMs,\n             time,\n             discoverBrokerVersions,\n             apiVersions,\n             null,\n             logContext,\n             new DefaultHostResolver(),\n             null,\n             Long.MAX_VALUE,\n             metadataRecoveryStrategy);\n    }\n\n    public NetworkClient(MetadataUpdater metadataUpdater,\n                         Metadata metadata,\n                         Selectable selector,\n                         String clientId,\n                         int maxInFlightRequestsPerConnection,\n                         long reconnectBackoffMs,\n                         long reconnectBackoffMax,\n                         int socketSendBuffer,\n                         int socketReceiveBuffer,\n                         int defaultRequestTimeoutMs,\n                         long connectionSetupTimeoutMs,\n                         long connectionSetupTimeoutMaxMs,\n                         Time time,\n                         boolean discoverBrokerVersions,\n                         ApiVersions apiVersions,\n                         Sensor throttleTimeSensor,\n                         LogContext logContext,\n                         HostResolver hostResolver,\n                         ClientTelemetrySender clientTelemetrySender,\n                         long rebootstrapTriggerMs,\n                         MetadataRecoveryStrategy metadataRecoveryStrategy) {\n        /* It would be better if we could pass `DefaultMetadataUpdater` from the public constructor, but it's not\n         * possible because `DefaultMetadataUpdater` is an inner class and it can only be instantiated after the\n         * super constructor is invoked.\n         */\n        if (metadataUpdater == null) {\n            if (metadata == null)\n                throw new IllegalArgumentException(\"`metadata` must not be null\");\n            this.metadataUpdater = new DefaultMetadataUpdater(metadata);\n        } else {\n            this.metadataUpdater = metadataUpdater;\n        }\n        this.selector = selector;\n        this.clientId = clientId;\n        this.inFlightRequests = new InFlightRequests(maxInFlightRequestsPerConnection);\n        this.connectionStates = new ClusterConnectionStates(\n                reconnectBackoffMs, reconnectBackoffMax,\n                connectionSetupTimeoutMs, connectionSetupTimeoutMaxMs, logContext, hostResolver);\n        this.socketSendBuffer = socketSendBuffer;\n        this.socketReceiveBuffer = socketReceiveBuffer;\n        this.correlation = 0;\n        this.randOffset = new Random();\n        this.defaultRequestTimeoutMs = defaultRequestTimeoutMs;\n        this.reconnectBackoffMs = reconnectBackoffMs;\n        this.time = time;\n        this.discoverBrokerVersions = discoverBrokerVersions;\n        this.apiVersions = apiVersions;\n        this.throttleTimeSensor = throttleTimeSensor;\n        this.log = logContext.logger(NetworkClient.class);\n        this.state = new AtomicReference<>(State.ACTIVE);\n        this.telemetrySender = (clientTelemetrySender != null) ? new TelemetrySender(clientTelemetrySender) : null;\n        this.rebootstrapTriggerMs = rebootstrapTriggerMs;\n        this.metadataRecoveryStrategy = metadataRecoveryStrategy;\n    }\n\n    /**\n     * Begin connecting to the given node, return true if we are already connected and ready to send to that node.\n     *\n     * @param node The node to check\n     * @param now The current timestamp\n     * @return True if we are ready to send to the given node\n     */\n    @Override\n    public boolean ready(Node node, long now) {\n        if (node.isEmpty())\n            throw new IllegalArgumentException(\"Cannot connect to empty node \" + node);\n\n        if (isReady(node, now))\n            return true;\n\n        if (connectionStates.canConnect(node.idString(), now))\n            // if we are interested in sending to a node and we don't have a connection to it, initiate one\n            initiateConnect(node, now);\n\n        return false;\n    }\n\n    // Visible for testing\n    boolean canConnect(Node node, long now) {\n        return connectionStates.canConnect(node.idString(), now);\n    }\n\n    /**\n     * Disconnects the connection to a particular node, if there is one.\n     * Any pending ClientRequests for this connection will receive disconnections.\n     *\n     * @param nodeId The id of the node\n     */\n    @Override\n    public void disconnect(String nodeId) {\n        if (connectionStates.isDisconnected(nodeId)) {\n            log.debug(\"Client requested disconnect from node {}, which is already disconnected\", nodeId);\n            return;\n        }\n\n        log.info(\"Client requested disconnect from node {}\", nodeId);\n        selector.close(nodeId);\n        long now = time.milliseconds();\n        cancelInFlightRequests(nodeId, now, abortedSends, false);\n        connectionStates.disconnected(nodeId, now);\n    }\n\n    private void cancelInFlightRequests(String nodeId,\n                                        long now,\n                                        Collection<ClientResponse> responses,\n                                        boolean timedOut) {\n        Iterable<InFlightRequest> inFlightRequests = this.inFlightRequests.clearAll(nodeId);\n        for (InFlightRequest request : inFlightRequests) {\n            if (log.isDebugEnabled()) {\n                log.debug(\"Cancelled in-flight {} request with correlation id {} due to node {} being disconnected \" +\n                        \"(elapsed time since creation: {}ms, elapsed time since send: {}ms, throttle time: {}ms, request timeout: {}ms): {}\",\n                    request.header.apiKey(), request.header.correlationId(), nodeId,\n                    request.timeElapsedSinceCreateMs(now), request.timeElapsedSinceSendMs(now),\n                    request.throttleTimeMs(), request.requestTimeoutMs, request.request);\n            } else {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/NetworkClient.java#L261-L410",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/NetworkClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 410,
  "last_modified": "2026-02-06T01:16:27.578839",
  "source_type": "github"
}