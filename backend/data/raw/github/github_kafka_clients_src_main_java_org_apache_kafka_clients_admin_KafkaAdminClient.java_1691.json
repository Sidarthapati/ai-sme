{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1691",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                }\n            };\n        }\n    }\n\n    static Cluster parseDescribeClusterResponse(DescribeClusterResponseData response) {\n        ApiError apiError = new ApiError(response.errorCode(), response.errorMessage());\n        if (apiError.isFailure()) {\n            throw apiError.exception();\n        }\n        if (response.endpointType() != EndpointType.CONTROLLER.id()) {\n            throw new MismatchedEndpointTypeException(\"Expected response from CONTROLLER \" +\n                \"endpoint, but got response from endpoint type \" + (int) response.endpointType());\n        }\n        List<Node> nodes = new ArrayList<>();\n        Node controllerNode = null;\n        for (DescribeClusterResponseData.DescribeClusterBroker node : response.brokers()) {\n            Node newNode = new Node(node.brokerId(), node.host(), node.port(), node.rack());\n            nodes.add(newNode);\n            if (node.brokerId() == response.controllerId()) {\n                controllerNode = newNode;\n            }\n        }\n        return new Cluster(response.clusterId(),\n            nodes,\n            Collections.emptyList(),\n            Collections.emptySet(),\n            Collections.emptySet(),\n            controllerNode);\n    }\n\n    /**\n     * Returns true if a topic name cannot be represented in an RPC.  This function does NOT check\n     * whether the name is too long, contains invalid characters, etc.  It is better to enforce\n     * those policies on the server, so that they can be changed in the future if needed.\n     */\n    private static boolean topicNameIsUnrepresentable(String topicName) {\n        return topicName == null || topicName.isEmpty();\n    }\n\n    private static boolean topicIdIsUnrepresentable(Uuid topicId) {\n        return topicId == null || topicId.equals(Uuid.ZERO_UUID);\n    }\n\n    // for testing\n    int numPendingCalls() {\n        return runnable.pendingCalls.size();\n    }\n\n    /**\n     * Fail futures in the given stream which are not done.\n     * Used when a response handler expected a result for some entity but no result was present.\n     */\n    private static <K, V> void completeUnrealizedFutures(\n        Stream<Map.Entry<K, KafkaFutureImpl<V>>> futures,\n        Function<K, String> messageFormatter) {\n        futures.filter(entry -> !entry.getValue().isDone()).forEach(entry ->\n            entry.getValue().completeExceptionally(new ApiException(messageFormatter.apply(entry.getKey()))));\n    }\n\n    /**\n     * Fail futures in the given Map which were retried due to exceeding quota. We propagate\n     * the initial error back to the caller if the request timed out.\n     */\n    private static <K, V> void maybeCompleteQuotaExceededException(\n        boolean shouldRetryOnQuotaViolation,\n        Throwable throwable,\n        Map<K, KafkaFutureImpl<V>> futures,\n        Map<K, ThrottlingQuotaExceededException> quotaExceededExceptions,\n        int throttleTimeDelta) {\n        if (shouldRetryOnQuotaViolation && throwable instanceof TimeoutException) {\n            quotaExceededExceptions.forEach((key, value) -> futures.get(key).completeExceptionally(\n                new ThrottlingQuotaExceededException(\n                    Math.max(0, value.throttleTimeMs() - throttleTimeDelta),\n                    value.getMessage())));\n        }\n    }\n\n    @Override\n    public CreateTopicsResult createTopics(final Collection<NewTopic> newTopics,\n                                           final CreateTopicsOptions options) {\n        final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> topicFutures = new HashMap<>(newTopics.size());\n        final CreatableTopicCollection topics = new CreatableTopicCollection();\n        for (NewTopic newTopic : newTopics) {\n            if (topicNameIsUnrepresentable(newTopic.name())) {\n                KafkaFutureImpl<TopicMetadataAndConfig> future = new KafkaFutureImpl<>();\n                future.completeExceptionally(new InvalidTopicException(\"The given topic name '\" +\n                    newTopic.name() + \"' cannot be represented in a request.\"));\n                topicFutures.put(newTopic.name(), future);\n            } else if (!topicFutures.containsKey(newTopic.name())) {\n                topicFutures.put(newTopic.name(), new KafkaFutureImpl<>());\n                topics.add(newTopic.convertToCreatableTopic());\n            }\n        }\n        if (!topics.isEmpty()) {\n            final long now = time.milliseconds();\n            final long deadline = calcDeadlineMs(now, options.timeoutMs());\n            final Call call = getCreateTopicsCall(options, topicFutures, topics,\n                Collections.emptyMap(), now, deadline);\n            runnable.call(call, now);\n        }\n        return new CreateTopicsResult(new HashMap<>(topicFutures));\n    }\n\n    private Call getCreateTopicsCall(final CreateTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<TopicMetadataAndConfig>> futures,\n                                     final CreatableTopicCollection topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"createTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            public CreateTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateTopicsRequest.Builder(\n                    new CreateTopicsRequestData()\n                        .setTopics(topics)\n                        .setTimeoutMs(timeoutMs)\n                        .setValidateOnly(options.shouldValidateOnly()));\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                // Check for controller change\n                handleNotControllerError(abstractResponse);\n                // Handle server responses for particular topics.\n                final CreateTopicsResponse response = (CreateTopicsResponse) abstractResponse;\n                final CreatableTopicCollection retryTopics = new CreatableTopicCollection();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (CreatableTopicResult result : response.data().topics()) {\n                    KafkaFutureImpl<TopicMetadataAndConfig> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(topics.find(result.name()).duplicate());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            TopicMetadataAndConfig topicMetadataAndConfig;\n                            if (result.topicConfigErrorCode() != Errors.NONE.code()) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1691-L1840",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1691,
  "end_line": 1840,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}