{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_ProducerBatch.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.producer.Callback;\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.errors.RecordBatchTooLargeException;\nimport org.apache.kafka.common.header.Header;\nimport org.apache.kafka.common.record.AbstractRecords;\nimport org.apache.kafka.common.record.CompressionRatioEstimator;\nimport org.apache.kafka.common.record.CompressionType;\nimport org.apache.kafka.common.record.MemoryRecords;\nimport org.apache.kafka.common.record.MemoryRecordsBuilder;\nimport org.apache.kafka.common.record.MutableRecordBatch;\nimport org.apache.kafka.common.record.Record;\nimport org.apache.kafka.common.record.RecordBatch;\nimport org.apache.kafka.common.record.TimestampType;\nimport org.apache.kafka.common.requests.ProduceResponse;\nimport org.apache.kafka.common.utils.ProducerIdAndEpoch;\nimport org.apache.kafka.common.utils.Time;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.nio.ByteBuffer;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.OptionalInt;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.concurrent.atomic.AtomicReference;\nimport java.util.function.Function;\n\nimport static org.apache.kafka.common.record.RecordBatch.MAGIC_VALUE_V2;\nimport static org.apache.kafka.common.record.RecordBatch.NO_TIMESTAMP;\n\n/**\n * A batch of records that is or will be sent.\n *\n * This class is not thread safe and external synchronization must be used when modifying it\n */\npublic final class ProducerBatch {\n\n    private static final Logger log = LoggerFactory.getLogger(ProducerBatch.class);\n\n    private enum FinalState { ABORTED, FAILED, SUCCEEDED }\n\n    final long createdMs;\n    final TopicPartition topicPartition;\n    final ProduceRequestResult produceFuture;\n\n    private final List<Thunk> thunks = new ArrayList<>();\n    private final MemoryRecordsBuilder recordsBuilder;\n    private final AtomicInteger attempts = new AtomicInteger(0);\n    private final boolean isSplitBatch;\n    private final AtomicReference<FinalState> finalState = new AtomicReference<>(null);\n    private boolean bufferDeallocated = false;\n    // Tracks if the batch has been sent to the NetworkClient\n    private boolean inflight = false;\n\n    int recordCount;\n    int maxRecordSize;\n    private long lastAttemptMs;\n    private long lastAppendTime;\n    private long drainedMs;\n    private boolean retry;\n    private boolean reopened;\n\n    // Tracks the current-leader's epoch to which this batch would be sent, in the current to produce the batch.\n    private OptionalInt currentLeaderEpoch;\n    // Tracks the attempt in which leader was changed to currentLeaderEpoch for the 1st time.\n    private int attemptsWhenLeaderLastChanged;\n\n    public ProducerBatch(TopicPartition tp, MemoryRecordsBuilder recordsBuilder, long createdMs) {\n        this(tp, recordsBuilder, createdMs, false);\n    }\n\n    public ProducerBatch(TopicPartition tp, MemoryRecordsBuilder recordsBuilder, long createdMs, boolean isSplitBatch) {\n        this.createdMs = createdMs;\n        this.lastAttemptMs = createdMs;\n        this.recordsBuilder = recordsBuilder;\n        this.topicPartition = tp;\n        this.lastAppendTime = createdMs;\n        this.produceFuture = new ProduceRequestResult(topicPartition);\n        this.retry = false;\n        this.isSplitBatch = isSplitBatch;\n        float compressionRatioEstimation = CompressionRatioEstimator.estimation(topicPartition.topic(),\n                                                                                recordsBuilder.compression().type());\n        this.currentLeaderEpoch = OptionalInt.empty();\n        this.attemptsWhenLeaderLastChanged = 0;\n        recordsBuilder.setEstimatedCompressionRatio(compressionRatioEstimation);\n    }\n\n    /**\n     * It will update the leader to which this batch will be produced for the ongoing attempt, if a newer leader is known.\n     * @param latestLeaderEpoch latest leader's epoch.\n     */\n    void maybeUpdateLeaderEpoch(OptionalInt latestLeaderEpoch) {\n        if (latestLeaderEpoch.isPresent()\n            && (currentLeaderEpoch.isEmpty() || currentLeaderEpoch.getAsInt() < latestLeaderEpoch.getAsInt())) {\n            log.trace(\"For {}, leader will be updated, currentLeaderEpoch: {}, attemptsWhenLeaderLastChanged:{}, latestLeaderEpoch: {}, current attempt: {}\",\n                this, currentLeaderEpoch, attemptsWhenLeaderLastChanged, latestLeaderEpoch, attempts);\n            attemptsWhenLeaderLastChanged = attempts();\n            currentLeaderEpoch = latestLeaderEpoch;\n        } else {\n            log.trace(\"For {}, leader wasn't updated, currentLeaderEpoch: {}, attemptsWhenLeaderLastChanged:{}, latestLeaderEpoch: {}, current attempt: {}\",\n                this, currentLeaderEpoch, attemptsWhenLeaderLastChanged, latestLeaderEpoch, attempts);\n        }\n    }\n\n    /**\n     * It will return true, for a when batch is being retried, it will be retried to a newer leader.\n     */\n\n    boolean hasLeaderChangedForTheOngoingRetry() {\n        int attempts = attempts();\n        boolean isRetry = attempts >= 1;\n        if (!isRetry)\n            return false;\n        return attempts == attemptsWhenLeaderLastChanged;\n    }\n\n\n    /**\n     * Append the record to the current record set and return the relative offset within that record set\n     *\n     * @return The RecordSend corresponding to this record or null if there isn't sufficient room.\n     */\n    public FutureRecordMetadata tryAppend(long timestamp, byte[] key, byte[] value, Header[] headers, Callback callback, long now) {\n        if (!recordsBuilder.hasRoomFor(timestamp, key, value, headers)) {\n            return null;\n        } else {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.609686",
  "source_type": "github"
}