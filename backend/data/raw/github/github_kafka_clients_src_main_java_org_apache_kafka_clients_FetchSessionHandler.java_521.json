{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_FetchSessionHandler.java_521",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "content": "     *\n     * @param response  The response.\n     * @param version   The version of the request.\n     * @return          True if the response is well-formed; false if it can't be processed\n     *                  because of missing or unexpected partitions.\n     */\n    public boolean handleResponse(FetchResponse response, short version) {\n        if (response.error() != Errors.NONE) {\n            log.info(\"Node {} was unable to process the fetch request with {}: {}.\",\n                node, nextMetadata, response.error());\n            if (response.error() == Errors.FETCH_SESSION_ID_NOT_FOUND) {\n                nextMetadata = FetchMetadata.INITIAL;\n            } else {\n                nextMetadata = nextMetadata.nextCloseExistingAttemptNew();\n            }\n            return false;\n        }\n        Set<TopicPartition> topicPartitions = response.responseData(sessionTopicNames, version).keySet();\n        if (nextMetadata.isFull()) {\n            if (topicPartitions.isEmpty() && response.throttleTimeMs() > 0) {\n                // Normally, an empty full fetch response would be invalid.  However, KIP-219\n                // specifies that if the broker wants to throttle the client, it will respond\n                // to a full fetch request with an empty response and a throttleTimeMs\n                // value set.  We don't want to log this with a warning, since it's not an error.\n                // However, the empty full fetch response can't be processed, so it's still appropriate\n                // to return false here.\n                if (log.isDebugEnabled()) {\n                    log.debug(\"Node {} sent a empty full fetch response to indicate that this \" +\n                        \"client should be throttled for {} ms.\", node, response.throttleTimeMs());\n                }\n                nextMetadata = FetchMetadata.INITIAL;\n                return false;\n            }\n            String problem = verifyFullFetchResponsePartitions(topicPartitions, response.topicIds(), version);\n            if (problem != null) {\n                log.info(\"Node {} sent an invalid full fetch response with {}\", node, problem);\n                nextMetadata = FetchMetadata.INITIAL;\n                return false;\n            } else if (response.sessionId() == INVALID_SESSION_ID) {\n                if (log.isDebugEnabled())\n                    log.debug(\"Node {} sent a full fetch response{}\", node, responseDataToLogString(topicPartitions));\n                nextMetadata = FetchMetadata.INITIAL;\n                return true;\n            } else {\n                // The server created a new incremental fetch session.\n                if (log.isDebugEnabled())\n                    log.debug(\"Node {} sent a full fetch response that created a new incremental \" +\n                            \"fetch session {}{}\", node, response.sessionId(), responseDataToLogString(topicPartitions));\n                nextMetadata = FetchMetadata.newIncremental(response.sessionId());\n                return true;\n            }\n        } else {\n            String problem = verifyIncrementalFetchResponsePartitions(topicPartitions, response.topicIds(), version);\n            if (problem != null) {\n                log.info(\"Node {} sent an invalid incremental fetch response with {}\", node, problem);\n                nextMetadata = nextMetadata.nextCloseExistingAttemptNew();\n                return false;\n            } else if (response.sessionId() == INVALID_SESSION_ID) {\n                // The incremental fetch session was closed by the server.\n                if (log.isDebugEnabled())\n                    log.debug(\"Node {} sent an incremental fetch response closing session {}{}\",\n                            node, nextMetadata.sessionId(), responseDataToLogString(topicPartitions));\n                nextMetadata = FetchMetadata.INITIAL;\n                return true;\n            } else {\n                // The incremental fetch session was continued by the server.\n                // We don't have to do anything special here to support KIP-219, since an empty incremental\n                // fetch request is perfectly valid.\n                if (log.isDebugEnabled())\n                    log.debug(\"Node {} sent an incremental fetch response with throttleTimeMs = {} \" +\n                        \"for session {}{}\", node, response.throttleTimeMs(), response.sessionId(),\n                        responseDataToLogString(topicPartitions));\n                nextMetadata = nextMetadata.nextIncremental();\n                return true;\n            }\n        }\n    }\n\n    /**\n     * The client will initiate the session close on next fetch request.\n     */\n    public void notifyClose() {\n        if (log.isDebugEnabled()) {\n            log.debug(\"Set the metadata for next fetch request to close the existing session ID={}\", nextMetadata.sessionId());\n        }\n        nextMetadata = nextMetadata.nextCloseExisting();\n    }\n\n    /**\n     * Handle an error sending the prepared request.\n     *\n     * When a network error occurs, we close any existing fetch session on our next request,\n     * and try to create a new session.\n     *\n     * @param t     The exception.\n     */\n    public void handleError(Throwable t) {\n        log.info(\"Error sending fetch request {} to node {}:\", nextMetadata, node, t);\n        nextMetadata = nextMetadata.nextCloseExistingAttemptNew();\n    }\n\n    /**\n     * Get the fetch request session's partitions.\n     */\n    public Set<TopicPartition> sessionTopicPartitions() {\n        return sessionPartitions.keySet();\n    }\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java#L521-L629",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 521,
  "end_line": 629,
  "last_modified": "2026-02-06T01:16:27.577970",
  "source_type": "github"
}