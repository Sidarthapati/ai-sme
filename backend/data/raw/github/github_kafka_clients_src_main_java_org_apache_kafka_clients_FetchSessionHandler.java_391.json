{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_FetchSessionHandler.java_391",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "content": "\n    private String topicPartitionsToLogString(Collection<TopicPartition> partitions) {\n        if (!log.isTraceEnabled()) {\n            return String.format(\"%d partition(s)\", partitions.size());\n        }\n        return \"(\" + partitions.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \")) + \")\";\n    }\n\n    private String topicIdPartitionsToLogString(Collection<TopicIdPartition> partitions) {\n        if (!log.isTraceEnabled()) {\n            return String.format(\"%d partition(s)\", partitions.size());\n        }\n        return \"(\" + partitions.stream().map(TopicIdPartition::toString).collect(Collectors.joining(\", \")) + \")\";\n    }\n\n    /**\n     * Return missing items which are expected to be in a particular set, but which are not.\n     *\n     * @param toFind    The items to look for.\n     * @param toSearch  The set of items to search.\n     * @return          Empty set if all items were found; some of the missing ones in a set, if not.\n     */\n    static <T> Set<T> findMissing(Set<T> toFind, Set<T> toSearch) {\n        Set<T> ret = new LinkedHashSet<>();\n        for (T toFindItem: toFind) {\n            if (!toSearch.contains(toFindItem)) {\n                ret.add(toFindItem);\n            }\n        }\n        return ret;\n    }\n\n    /**\n     * Verify that a full fetch response contains all the partitions in the fetch session.\n     *\n     * @param topicPartitions  The topicPartitions from the FetchResponse.\n     * @param ids              The topic IDs from the FetchResponse.\n     * @param version          The version of the FetchResponse.\n     * @return                 null if the full fetch response partitions are valid; human-readable problem description otherwise.\n     */\n    String verifyFullFetchResponsePartitions(Set<TopicPartition> topicPartitions, Set<Uuid> ids, short version) {\n        StringBuilder bld = new StringBuilder();\n        Set<TopicPartition> extra =\n            findMissing(topicPartitions, sessionPartitions.keySet());\n        Set<TopicPartition> omitted =\n            findMissing(sessionPartitions.keySet(), topicPartitions);\n        Set<Uuid> extraIds = new HashSet<>();\n        if (version >= 13) {\n            extraIds = findMissing(ids, sessionTopicNames.keySet());\n        }\n        if (!omitted.isEmpty()) {\n            bld.append(\"omittedPartitions=(\").append(omitted.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).append(\"), \");\n        }\n        if (!extra.isEmpty()) {\n            bld.append(\"extraPartitions=(\").append(extra.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).append(\"), \");\n        }\n        if (!extraIds.isEmpty()) {\n            bld.append(\"extraIds=(\").append(extraIds.stream().map(Uuid::toString).collect(Collectors.joining(\", \"))).append(\"), \");\n        }\n        if ((!omitted.isEmpty()) || (!extra.isEmpty()) || (!extraIds.isEmpty())) {\n            bld.append(\"response=(\").append(topicPartitions.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).append(\")\");\n            return bld.toString();\n        }\n        return null;\n    }\n\n    /**\n     * Verify that the partitions in an incremental fetch response are contained in the session.\n     *\n     * @param topicPartitions  The topicPartitions from the FetchResponse.\n     * @param ids              The topic IDs from the FetchResponse.\n     * @param version          The version of the FetchResponse.\n     * @return                 null if the incremental fetch response partitions are valid; human-readable problem description otherwise.\n     */\n    String verifyIncrementalFetchResponsePartitions(Set<TopicPartition> topicPartitions, Set<Uuid> ids, short version) {\n        Set<Uuid> extraIds = new HashSet<>();\n        if (version >= 13) {\n            extraIds = findMissing(ids, sessionTopicNames.keySet());\n        }\n        Set<TopicPartition> extra =\n            findMissing(topicPartitions, sessionPartitions.keySet());\n        StringBuilder bld = new StringBuilder();\n        if (!extra.isEmpty())\n            bld.append(\"extraPartitions=(\").append(extra.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).append(\"), \");\n        if (!extraIds.isEmpty())\n            bld.append(\"extraIds=(\").append(extraIds.stream().map(Uuid::toString).collect(Collectors.joining(\", \"))).append(\"), \");\n        if ((!extra.isEmpty()) || (!extraIds.isEmpty())) {\n            bld.append(\"response=(\").append(topicPartitions.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).append(\")\");\n            return bld.toString();\n        }\n        return null;\n    }\n\n    /**\n     * Create a string describing the partitions in a FetchResponse.\n     *\n     * @param topicPartitions  The topicPartitions from the FetchResponse.\n     * @return                 The string to log.\n     */\n    private String responseDataToLogString(Set<TopicPartition> topicPartitions) {\n        if (!log.isTraceEnabled()) {\n            int implied = sessionPartitions.size() - topicPartitions.size();\n            if (implied > 0) {\n                return String.format(\" with %d response partition(s), %d implied partition(s)\",\n                    topicPartitions.size(), implied);\n            } else {\n                return String.format(\" with %d response partition(s)\",\n                    topicPartitions.size());\n            }\n        }\n        StringBuilder bld = new StringBuilder();\n        bld.append(\" with response=(\").\n            append(topicPartitions.stream().map(TopicPartition::toString).collect(Collectors.joining(\", \"))).\n            append(\")\");\n        String prefix = \", implied=(\";\n        String suffix = \"\";\n        for (TopicPartition partition : sessionPartitions.keySet()) {\n            if (!topicPartitions.contains(partition)) {\n                bld.append(prefix);\n                bld.append(partition);\n                prefix = \", \";\n                suffix = \")\";\n            }\n        }\n        bld.append(suffix);\n        return bld.toString();\n    }\n\n    /**\n     * Handle the fetch response.\n     *\n     * @param response  The response.\n     * @param version   The version of the request.\n     * @return          True if the response is well-formed; false if it can't be processed\n     *                  because of missing or unexpected partitions.\n     */\n    public boolean handleResponse(FetchResponse response, short version) {\n        if (response.error() != Errors.NONE) {\n            log.info(\"Node {} was unable to process the fetch request with {}: {}.\",\n                node, nextMetadata, response.error());\n            if (response.error() == Errors.FETCH_SESSION_ID_NOT_FOUND) {\n                nextMetadata = FetchMetadata.INITIAL;\n            } else {\n                nextMetadata = nextMetadata.nextCloseExistingAttemptNew();\n            }\n            return false;\n        }\n        Set<TopicPartition> topicPartitions = response.responseData(sessionTopicNames, version).keySet();\n        if (nextMetadata.isFull()) {\n            if (topicPartitions.isEmpty() && response.throttleTimeMs() > 0) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java#L391-L540",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/FetchSessionHandler.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 391,
  "end_line": 540,
  "last_modified": "2026-02-06T01:16:27.577970",
  "source_type": "github"
}