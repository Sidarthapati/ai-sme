{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_ProducerMetadata.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerMetadata.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.Metadata;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.internals.ClusterResourceListeners;\nimport org.apache.kafka.common.protocol.Errors;\nimport org.apache.kafka.common.requests.MetadataRequest;\nimport org.apache.kafka.common.requests.MetadataResponse;\nimport org.apache.kafka.common.utils.LogContext;\nimport org.apache.kafka.common.utils.Time;\n\nimport org.slf4j.Logger;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class ProducerMetadata extends Metadata {\n    // If a topic hasn't been accessed for this many milliseconds, it is removed from the cache.\n    private final long metadataIdleMs;\n\n    /* Topics with expiry time */\n    private final Map<String, Long> topics = new HashMap<>();\n    private final Set<String> newTopics = new HashSet<>();\n    private final Logger log;\n    private final Time time;\n    private Map<String, Errors> errors = null;\n\n    public ProducerMetadata(long refreshBackoffMs,\n                            long refreshBackoffMaxMs,\n                            long metadataExpireMs,\n                            long metadataIdleMs,\n                            LogContext logContext,\n                            ClusterResourceListeners clusterResourceListeners,\n                            Time time) {\n        super(refreshBackoffMs, refreshBackoffMaxMs, metadataExpireMs, logContext, clusterResourceListeners);\n        this.metadataIdleMs = metadataIdleMs;\n        this.log = logContext.logger(ProducerMetadata.class);\n        this.time = time;\n    }\n\n    @Override\n    public synchronized MetadataRequest.Builder newMetadataRequestBuilder() {\n        return new MetadataRequest.Builder(new ArrayList<>(topics.keySet()), true);\n    }\n\n    @Override\n    public synchronized MetadataRequest.Builder newMetadataRequestBuilderForNewTopics() {\n        return new MetadataRequest.Builder(new ArrayList<>(newTopics), true);\n    }\n\n    public synchronized void add(String topic, long nowMs) {\n        Objects.requireNonNull(topic, \"topic cannot be null\");\n        if (topics.put(topic, nowMs + metadataIdleMs) == null) {\n            newTopics.add(topic);\n            requestUpdateForNewTopics();\n        }\n    }\n\n    public synchronized int requestUpdateForTopic(String topic) {\n        if (newTopics.contains(topic)) {\n            return requestUpdateForNewTopics();\n        } else {\n            return requestUpdate(false);\n        }\n    }\n\n    // Visible for testing\n    synchronized Set<String> topics() {\n        return topics.keySet();\n    }\n\n    // Visible for testing\n    synchronized Set<String> newTopics() {\n        return newTopics;\n    }\n\n    public synchronized boolean containsTopic(String topic) {\n        return topics.containsKey(topic);\n    }\n\n    @Override\n    public synchronized boolean retainTopic(String topic, boolean isInternal, long nowMs) {\n        Long expireMs = topics.get(topic);\n        if (expireMs == null) {\n            return false;\n        } else if (newTopics.contains(topic)) {\n            return true;\n        } else if (expireMs <= nowMs) {\n            log.debug(\"Removing unused topic {} from the metadata list, expiryMs {} now {}\", topic, expireMs, nowMs);\n            topics.remove(topic);\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Wait for metadata update until the current version is larger than the last version we know of\n     */\n    public synchronized void awaitUpdate(final int lastVersion, final long timeoutMs) throws InterruptedException {\n        long currentTimeMs = time.milliseconds();\n        long deadlineMs = currentTimeMs + timeoutMs < 0 ? Long.MAX_VALUE : currentTimeMs + timeoutMs;\n        time.waitObject(this, () -> {\n            // Throw fatal exceptions, if there are any. Recoverable topic errors will be handled by the caller.\n            maybeThrowFatalException();\n            return updateVersion() > lastVersion || isClosed();\n        }, deadlineMs);\n\n        if (isClosed())\n            throw new KafkaException(\"Requested metadata update after close\");\n    }\n\n    @Override\n    public synchronized void update(int requestVersion, MetadataResponse response, boolean isPartialUpdate, long nowMs) {\n        super.update(requestVersion, response, isPartialUpdate, nowMs);\n        errors = response.errors();\n\n        // Remove all topics in the response that are in the new topic set. Note that if an error was encountered for a\n        // new topic's metadata, then any work to resolve the error will include the topic in a full metadata update.\n        if (!newTopics.isEmpty()) {\n            for (MetadataResponse.TopicMetadata metadata : response.topicMetadata()) {\n                newTopics.remove(metadata.topic());\n            }\n        }\n\n        notifyAll();\n    }\n\n    public Errors getError(final String topic) {\n        if (errors != null) {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerMetadata.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerMetadata.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.609839",
  "source_type": "github"
}