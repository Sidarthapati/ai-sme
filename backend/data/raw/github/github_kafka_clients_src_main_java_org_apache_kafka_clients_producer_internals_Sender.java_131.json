{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_Sender.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java",
  "content": "                  RecordAccumulator accumulator,\n                  boolean guaranteeMessageOrder,\n                  int maxRequestSize,\n                  short acks,\n                  int retries,\n                  SenderMetricsRegistry metricsRegistry,\n                  Time time,\n                  int requestTimeoutMs,\n                  long retryBackoffMs,\n                  TransactionManager transactionManager) {\n        this.log = logContext.logger(Sender.class);\n        this.client = client;\n        this.accumulator = accumulator;\n        this.metadata = metadata;\n        this.guaranteeMessageOrder = guaranteeMessageOrder;\n        this.maxRequestSize = maxRequestSize;\n        this.running = true;\n        this.acks = acks;\n        this.retries = retries;\n        this.time = time;\n        this.sensors = new SenderMetrics(metricsRegistry, metadata, client, time);\n        this.requestTimeoutMs = requestTimeoutMs;\n        this.retryBackoffMs = retryBackoffMs;\n        this.transactionManager = transactionManager;\n        this.inFlightBatches = new HashMap<>();\n    }\n\n    public List<ProducerBatch> inFlightBatches(TopicPartition tp) {\n        return inFlightBatches.containsKey(tp) ? inFlightBatches.get(tp) : new ArrayList<>();\n    }\n\n    private void maybeRemoveFromInflightBatches(ProducerBatch batch) {\n        List<ProducerBatch> batches = inFlightBatches.get(batch.topicPartition);\n        if (batches != null) {\n            batches.remove(batch);\n            if (batches.isEmpty()) {\n                inFlightBatches.remove(batch.topicPartition);\n            }\n        }\n    }\n\n    private void maybeRemoveAndDeallocateBatch(ProducerBatch batch) {\n        maybeRemoveFromInflightBatches(batch);\n        this.accumulator.completeAndDeallocateBatch(batch);\n    }\n\n    private void maybeRemoveAndDeallocateBatchLater(ProducerBatch batch) {\n        maybeRemoveFromInflightBatches(batch);\n        this.accumulator.completeBatch(batch);\n    }\n\n    /**\n     *  Get the in-flight batches that has reached delivery timeout.\n     */\n    private List<ProducerBatch> getExpiredInflightBatches(long now) {\n        List<ProducerBatch> expiredBatches = new ArrayList<>();\n\n        for (Iterator<Map.Entry<TopicPartition, List<ProducerBatch>>> batchIt = inFlightBatches.entrySet().iterator(); batchIt.hasNext();) {\n            Map.Entry<TopicPartition, List<ProducerBatch>> entry = batchIt.next();\n            List<ProducerBatch> partitionInFlightBatches = entry.getValue();\n            if (partitionInFlightBatches != null) {\n                Iterator<ProducerBatch> iter = partitionInFlightBatches.iterator();\n                while (iter.hasNext()) {\n                    ProducerBatch batch = iter.next();\n                    if (batch.hasReachedDeliveryTimeout(accumulator.getDeliveryTimeoutMs(), now)) {\n                        iter.remove();\n                        // expireBatches is called in Sender.sendProducerData, before client.poll.\n                        // The !batch.isDone() invariant should always hold. An IllegalStateException\n                        // exception will be thrown if the invariant is violated.\n                        if (!batch.isDone()) {\n                            expiredBatches.add(batch);\n                        } else {\n                            throw new IllegalStateException(batch.topicPartition + \" batch created at \" +\n                                batch.createdMs + \" gets unexpected final state \" + batch.finalState());\n                        }\n                    } else {\n                        accumulator.maybeUpdateNextBatchExpiryTime(batch);\n                        break;\n                    }\n                }\n                if (partitionInFlightBatches.isEmpty()) {\n                    batchIt.remove();\n                }\n            }\n        }\n        return expiredBatches;\n    }\n\n    private void addToInflightBatches(List<ProducerBatch> batches) {\n        for (ProducerBatch batch : batches) {\n            List<ProducerBatch> inflightBatchList = inFlightBatches.computeIfAbsent(batch.topicPartition,\n                k -> new ArrayList<>());\n            inflightBatchList.add(batch);\n        }\n    }\n\n    public void addToInflightBatches(Map<Integer, List<ProducerBatch>> batches) {\n        for (List<ProducerBatch> batchList : batches.values()) {\n            addToInflightBatches(batchList);\n        }\n    }\n\n    private boolean hasPendingTransactionalRequests() {\n        return transactionManager != null && transactionManager.hasPendingRequests() && transactionManager.hasOngoingTransaction();\n    }\n\n    /**\n     * The main run loop for the sender thread\n     */\n    @Override\n    public void run() {\n        log.debug(\"Starting Kafka producer I/O thread.\");\n\n        // main loop, runs until close is called\n        while (running) {\n            try {\n                runOnce();\n            } catch (Exception e) {\n                log.error(\"Uncaught error in kafka producer I/O thread: \", e);\n            }\n        }\n\n        log.debug(\"Beginning shutdown of Kafka producer I/O thread, sending remaining records.\");\n\n        // okay we stopped accepting requests but there may still be\n        // requests in the transaction manager, accumulator or waiting for acknowledgment,\n        // wait until these are completed.\n        while (!forceClose && ((this.accumulator.hasUndrained() || this.client.inFlightRequestCount() > 0) || hasPendingTransactionalRequests())) {\n            try {\n                runOnce();\n            } catch (Exception e) {\n                log.error(\"Uncaught error in kafka producer I/O thread: \", e);\n            }\n        }\n\n        // Abort the transaction if any commit or abort didn't go through the transaction manager's queue\n        while (!forceClose && transactionManager != null && transactionManager.hasOngoingTransaction()) {\n            if (!transactionManager.isCompleting()) {\n                log.info(\"Aborting incomplete transaction due to shutdown\");\n                try {\n                    // It is possible for the transaction manager to throw errors when aborting. Catch these\n                    // so as not to interfere with the rest of the shutdown logic.\n                    transactionManager.beginAbort();\n                } catch (Exception e) {\n                    log.error(\"Error in kafka producer I/O thread while aborting transaction when during closing: \", e);\n                    // Force close in case the transactionManager is in error states.\n                    forceClose = true;\n                }\n            }\n            try {",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/Sender.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.610196",
  "source_type": "github"
}