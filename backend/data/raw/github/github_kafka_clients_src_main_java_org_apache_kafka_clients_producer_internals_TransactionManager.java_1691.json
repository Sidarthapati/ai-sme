{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1691",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "            return null;\n        }\n\n        @Override\n        String coordinatorKey() {\n            return null;\n        }\n\n        @Override\n        public void handleResponse(AbstractResponse response) {\n            CoordinatorType coordinatorType = CoordinatorType.forId(builder.data().keyType());\n\n            List<Coordinator> coordinators = ((FindCoordinatorResponse) response).coordinators();\n            if (coordinators.size() != 1) {\n                log.error(\"Group coordinator lookup failed: Invalid response containing more than a single coordinator\");\n                fatalError(new IllegalStateException(\"Group coordinator lookup failed: Invalid response containing more than a single coordinator\"));\n            }\n            Coordinator coordinatorData = coordinators.get(0);\n            // For older versions without batching, obtain key from request data since it is not included in response\n            String key = coordinatorData.key() == null ? builder.data().key() : coordinatorData.key();\n            Errors error = Errors.forCode(coordinatorData.errorCode());\n            if (error == Errors.NONE) {\n                Node node = new Node(coordinatorData.nodeId(), coordinatorData.host(), coordinatorData.port());\n                switch (coordinatorType) {\n                    case GROUP:\n                        consumerGroupCoordinator = node;\n                        break;\n                    case TRANSACTION:\n                        transactionCoordinator = node;\n                        break;\n                    default:\n                        log.error(\"Group coordinator lookup failed: Unexpected coordinator type in response\");\n                        fatalError(new IllegalStateException(\"Group coordinator lookup failed: Unexpected coordinator type in response\"));\n                }\n                result.done();\n                log.info(\"Discovered {} coordinator {}\", coordinatorType.toString().toLowerCase(Locale.ROOT), node);\n            } else if (error.exception() instanceof RetriableException) {\n                reenqueue();\n            } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED) {\n                fatalError(error.exception());\n            } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\n                abortableError(GroupAuthorizationException.forGroupId(key));\n            } else if (error == Errors.TRANSACTION_ABORTABLE) {\n                abortableError(error.exception());\n            } else {\n                fatalError(new KafkaException(String.format(\"Could not find a coordinator with type %s with key %s due to \" +\n                        \"unexpected error: %s\", coordinatorType, key,\n                        coordinatorData.errorMessage())));\n            }\n        }\n    }\n\n    private class EndTxnHandler extends TxnRequestHandler {\n        private final EndTxnRequest.Builder builder;\n\n        private EndTxnHandler(EndTxnRequest.Builder builder) {\n            super(\"EndTxn(\" + builder.data.committed() + \")\");\n            this.builder = builder;\n        }\n\n        @Override\n        EndTxnRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return Priority.END_TXN;\n        }\n\n        @Override\n        boolean isEndTxn() {\n            return true;\n        }\n\n        @Override\n        public void handleResponse(AbstractResponse response) {\n            EndTxnResponse endTxnResponse = (EndTxnResponse) response;\n            Errors error = endTxnResponse.error();\n            boolean isAbort = !builder.data.committed();\n            if (error == Errors.NONE) {\n                // For End Txn version 5+, the broker includes the producerId and producerEpoch in the EndTxnResponse.\n                // For versions lower than 5, the producer Id and epoch are set to -1 by default.\n                // When Transaction Version 2 is enabled, the end txn request 5+ is used,\n                // it mandates bumping the epoch after every transaction.\n                // If the epoch overflows, a new producerId is returned with epoch set to 0.\n                // Note, we still may see EndTxn TV1 (< 5) responses when the producer has upgraded to TV2 due to the upgrade\n                // occurring at the end of beginCompletingTransaction. The next transaction started should be TV2.\n                if (endTxnResponse.data().producerId() != -1) {\n                    ProducerIdAndEpoch producerIdAndEpoch = new ProducerIdAndEpoch(\n                        endTxnResponse.data().producerId(),\n                        endTxnResponse.data().producerEpoch()\n                    );\n                    setProducerIdAndEpoch(producerIdAndEpoch);\n                    resetSequenceNumbers();\n                }\n                resetTransactionState();\n                result.done();\n            } else if (error == Errors.COORDINATOR_NOT_AVAILABLE || error == Errors.NOT_COORDINATOR) {\n                lookupCoordinator(FindCoordinatorRequest.CoordinatorType.TRANSACTION, transactionalId);\n                reenqueue();\n            } else if (error.exception() instanceof RetriableException) {\n                reenqueue();\n            } else if (error == Errors.INVALID_PRODUCER_EPOCH || error == Errors.PRODUCER_FENCED) {\n                // We could still receive INVALID_PRODUCER_EPOCH from old versioned transaction coordinator,\n                // just treat it the same as PRODUCE_FENCED.\n                fatalError(Errors.PRODUCER_FENCED.exception());\n            } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED ||\n                    error == Errors.INVALID_TXN_STATE || error == Errors.INVALID_PRODUCER_ID_MAPPING) {\n                fatalError(error.exception());\n            } else if (error == Errors.UNKNOWN_PRODUCER_ID) {\n                abortableErrorIfPossible(error.exception());\n            } else if (isAbort && error.exception() instanceof TransactionAbortableException) {\n                // When aborting a transaction, we must convert TRANSACTION_ABORTABLE errors to KafkaException\n                // because if an abort operation itself encounters an abortable error, retrying the abort would create a cycle.\n                // Instead, we treat this as fatal error at the application layer to ensure the transaction can be cleanly terminated.\n                fatalError(new KafkaException(\"Failed to abort transaction\", error.exception()));\n            } else if (error == Errors.TRANSACTION_ABORTABLE) {\n                abortableError(error.exception());\n            } else {\n                fatalError(new KafkaException(\"Unhandled error in EndTxnResponse: \" + error.message()));\n            }\n        }\n    }\n\n    private class AddOffsetsToTxnHandler extends TxnRequestHandler {\n        private final AddOffsetsToTxnRequest.Builder builder;\n        private final Map<TopicPartition, OffsetAndMetadata> offsets;\n        private final ConsumerGroupMetadata groupMetadata;\n\n        private AddOffsetsToTxnHandler(AddOffsetsToTxnRequest.Builder builder,\n                                       Map<TopicPartition, OffsetAndMetadata> offsets,\n                                       ConsumerGroupMetadata groupMetadata) {\n            super(\"AddOffsetsToTxn\");\n            this.builder = builder;\n            this.offsets = offsets;\n            this.groupMetadata = groupMetadata;\n        }\n\n        @Override\n        AddOffsetsToTxnRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return Priority.ADD_PARTITIONS_OR_OFFSETS;\n        }\n\n        @Override",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1691-L1840",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1691,
  "end_line": 1840,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}