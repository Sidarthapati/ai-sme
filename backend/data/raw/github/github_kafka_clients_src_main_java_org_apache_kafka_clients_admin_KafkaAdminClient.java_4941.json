{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_4941",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                if (response.error().isFailure()) {\n                    future.completeExceptionally(response.error().exception());\n                } else {\n                    future.complete(response\n                        .data()\n                        .configResources()\n                        .stream()\n                        .filter(entry -> entry.resourceType() == ConfigResource.Type.CLIENT_METRICS.id())\n                        .map(entry -> new ClientMetricsResourceListing(entry.resourceName()))\n                        .collect(Collectors.toList()));\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        }, now);\n        return new ListClientMetricsResourcesResult(future);\n    }\n\n    @Override\n    public AddRaftVoterResult addRaftVoter(\n        int voterId,\n        Uuid voterDirectoryId,\n        Set<RaftVoterEndpoint> endpoints,\n        AddRaftVoterOptions options\n    ) {\n        NodeProvider provider = new LeastLoadedBrokerOrActiveKController();\n\n        final KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n        final long now = time.milliseconds();\n        final Call call = new Call(\n            \"addRaftVoter\", calcDeadlineMs(now, options.timeoutMs()), provider) {\n\n            @Override\n            AddRaftVoterRequest.Builder createRequest(int timeoutMs) {\n                AddRaftVoterRequestData.ListenerCollection listeners =\n                    new AddRaftVoterRequestData.ListenerCollection();\n                endpoints.forEach(endpoint ->\n                    listeners.add(new AddRaftVoterRequestData.Listener().\n                        setName(endpoint.listener()).\n                        setHost(endpoint.host()).\n                        setPort(endpoint.port())));\n                return new AddRaftVoterRequest.Builder(\n                    new AddRaftVoterRequestData().\n                        setClusterId(options.clusterId().orElse(null)).\n                        setTimeoutMs(timeoutMs).\n                        setVoterId(voterId).\n                        setVoterDirectoryId(voterDirectoryId).\n                        setListeners(listeners));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse response) {\n                handleNotControllerError(response);\n                AddRaftVoterResponse addResponse = (AddRaftVoterResponse) response;\n                Errors error = Errors.forCode(addResponse.data().errorCode());\n                if (error != Errors.NONE)\n                    future.completeExceptionally(error.exception(addResponse.data().errorMessage()));\n                else\n                    future.complete(null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        };\n        runnable.call(call, now);\n        return new AddRaftVoterResult(future);\n    }\n\n    @Override\n    public RemoveRaftVoterResult removeRaftVoter(\n        int voterId,\n        Uuid voterDirectoryId,\n        RemoveRaftVoterOptions options\n    ) {\n        NodeProvider provider = new LeastLoadedBrokerOrActiveKController();\n\n        final KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n        final long now = time.milliseconds();\n        final Call call = new Call(\n            \"removeRaftVoter\", calcDeadlineMs(now, options.timeoutMs()), provider) {\n\n            @Override\n            RemoveRaftVoterRequest.Builder createRequest(int timeoutMs) {\n                return new RemoveRaftVoterRequest.Builder(\n                    new RemoveRaftVoterRequestData().\n                        setClusterId(options.clusterId().orElse(null)).\n                        setVoterId(voterId).\n                        setVoterDirectoryId(voterDirectoryId));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse response) {\n                handleNotControllerError(response);\n                RemoveRaftVoterResponse addResponse = (RemoveRaftVoterResponse) response;\n                Errors error = Errors.forCode(addResponse.data().errorCode());\n                if (error != Errors.NONE)\n                    future.completeExceptionally(error.exception(addResponse.data().errorMessage()));\n                else\n                    future.complete(null);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                future.completeExceptionally(throwable);\n            }\n        };\n        runnable.call(call, now);\n        return new RemoveRaftVoterResult(future);\n    }\n\n    @Override\n    public Uuid clientInstanceId(Duration timeout) {\n        if (timeout.isNegative()) {\n            throw new IllegalArgumentException(\"The timeout cannot be negative.\");\n        }\n\n        if (clientTelemetryReporter.isEmpty()) {\n            throw new IllegalStateException(\"Telemetry is not enabled. Set config `\" + AdminClientConfig.ENABLE_METRICS_PUSH_CONFIG + \"` to `true`.\");\n\n        }\n\n        if (clientInstanceId != null) {\n            return clientInstanceId;\n        }\n\n        clientInstanceId = ClientTelemetryUtils.fetchClientInstanceId(clientTelemetryReporter.get(), timeout);\n        return clientInstanceId;\n    }\n\n    private <K, V> void invokeDriver(\n        AdminApiHandler<K, V> handler,\n        AdminApiFuture<K, V> future,\n        Integer timeoutMs\n    ) {\n        long currentTimeMs = time.milliseconds();\n        long deadlineMs = calcDeadlineMs(currentTimeMs, timeoutMs);\n\n        AdminApiDriver<K, V> driver = new AdminApiDriver<>(\n            handler,\n            future,\n            deadlineMs,\n            retryBackoffMs,\n            retryBackoffMaxMs,\n            logContext\n        );",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L4941-L5090",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 4941,
  "end_line": 5090,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}