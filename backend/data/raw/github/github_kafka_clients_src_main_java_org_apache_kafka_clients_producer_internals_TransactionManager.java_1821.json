{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1821",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "        private AddOffsetsToTxnHandler(AddOffsetsToTxnRequest.Builder builder,\n                                       Map<TopicPartition, OffsetAndMetadata> offsets,\n                                       ConsumerGroupMetadata groupMetadata) {\n            super(\"AddOffsetsToTxn\");\n            this.builder = builder;\n            this.offsets = offsets;\n            this.groupMetadata = groupMetadata;\n        }\n\n        @Override\n        AddOffsetsToTxnRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return Priority.ADD_PARTITIONS_OR_OFFSETS;\n        }\n\n        @Override\n        public void handleResponse(AbstractResponse response) {\n            AddOffsetsToTxnResponse addOffsetsToTxnResponse = (AddOffsetsToTxnResponse) response;\n            Errors error = Errors.forCode(addOffsetsToTxnResponse.data().errorCode());\n\n            if (error == Errors.NONE) {\n                log.debug(\"Successfully added partition for consumer group {} to transaction\", builder.data.groupId());\n\n                // note the result is not completed until the TxnOffsetCommit returns\n                pendingRequests.add(txnOffsetCommitHandler(result, offsets, groupMetadata));\n\n                transactionStarted = true;\n            } else if (error == Errors.COORDINATOR_NOT_AVAILABLE || error == Errors.NOT_COORDINATOR) {\n                lookupCoordinator(FindCoordinatorRequest.CoordinatorType.TRANSACTION, transactionalId);\n                reenqueue();\n            } else if (error.exception() instanceof RetriableException) {\n                reenqueue();\n            } else if (error == Errors.UNKNOWN_PRODUCER_ID) {\n                abortableErrorIfPossible(error.exception());\n            } else if (error == Errors.INVALID_PRODUCER_EPOCH || error == Errors.PRODUCER_FENCED) {\n                // We could still receive INVALID_PRODUCER_EPOCH from old versioned transaction coordinator,\n                // just treat it the same as PRODUCE_FENCED.\n                fatalError(Errors.PRODUCER_FENCED.exception());\n            } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED ||\n                    error == Errors.INVALID_TXN_STATE || error == Errors.INVALID_PRODUCER_ID_MAPPING) {\n                fatalError(error.exception());\n            } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\n                abortableError(GroupAuthorizationException.forGroupId(builder.data.groupId()));\n            } else if (error == Errors.TRANSACTION_ABORTABLE) {\n                abortableError(error.exception());\n            } else {\n                fatalError(new KafkaException(\"Unexpected error in AddOffsetsToTxnResponse: \" + error.message()));\n            }\n        }\n    }\n\n    private class TxnOffsetCommitHandler extends TxnRequestHandler {\n        private final TxnOffsetCommitRequest.Builder builder;\n\n        private TxnOffsetCommitHandler(TransactionalRequestResult result,\n                                       TxnOffsetCommitRequest.Builder builder) {\n            super(result);\n            this.builder = builder;\n        }\n\n        private TxnOffsetCommitHandler(TxnOffsetCommitRequest.Builder builder) {\n            super(\"TxnOffsetCommitHandler\");\n            this.builder = builder;\n        }\n\n        @Override\n        TxnOffsetCommitRequest.Builder requestBuilder() {\n            return builder;\n        }\n\n        @Override\n        Priority priority() {\n            return Priority.ADD_PARTITIONS_OR_OFFSETS;\n        }\n\n        @Override\n        FindCoordinatorRequest.CoordinatorType coordinatorType() {\n            return FindCoordinatorRequest.CoordinatorType.GROUP;\n        }\n\n        @Override\n        String coordinatorKey() {\n            return builder.data.groupId();\n        }\n\n        @Override\n        public void handleResponse(AbstractResponse response) {\n            TxnOffsetCommitResponse txnOffsetCommitResponse = (TxnOffsetCommitResponse) response;\n            boolean coordinatorReloaded = false;\n            Map<TopicPartition, Errors> errors = txnOffsetCommitResponse.errors();\n\n            log.debug(\"Received TxnOffsetCommit response for consumer group {}: {}\", builder.data.groupId(),\n                    errors);\n\n            for (Map.Entry<TopicPartition, Errors> entry : errors.entrySet()) {\n                TopicPartition topicPartition = entry.getKey();\n                Errors error = entry.getValue();\n                if (error == Errors.NONE) {\n                    pendingTxnOffsetCommits.remove(topicPartition);\n                } else if (error == Errors.COORDINATOR_NOT_AVAILABLE\n                        || error == Errors.NOT_COORDINATOR\n                        || error == Errors.REQUEST_TIMED_OUT) {\n                    if (!coordinatorReloaded) {\n                        coordinatorReloaded = true;\n                        lookupCoordinator(FindCoordinatorRequest.CoordinatorType.GROUP, builder.data.groupId());\n                    }\n                } else if (error.exception() instanceof RetriableException) {\n                    // If the topic is unknown, the coordinator is loading, or is another retriable error, retry with the current coordinator\n                    continue;\n                } else if (error == Errors.GROUP_AUTHORIZATION_FAILED) {\n                    abortableError(GroupAuthorizationException.forGroupId(builder.data.groupId()));\n                    break;\n                } else if (error == Errors.FENCED_INSTANCE_ID ||\n                        error == Errors.TRANSACTION_ABORTABLE) {\n                    abortableError(error.exception());\n                    break;\n                } else if (error == Errors.UNKNOWN_MEMBER_ID\n                        || error == Errors.ILLEGAL_GENERATION) {\n                    abortableError(new CommitFailedException(\"Transaction offset Commit failed \" +\n                        \"due to consumer group metadata mismatch: \" + error.exception().getMessage()));\n                    break;\n                } else if (error == Errors.INVALID_PRODUCER_EPOCH\n                        || error == Errors.PRODUCER_FENCED) {\n                    // We could still receive INVALID_PRODUCER_EPOCH from old versioned transaction coordinator,\n                    // just treat it the same as PRODUCE_FENCED.\n                    fatalError(Errors.PRODUCER_FENCED.exception());\n                    break;\n                } else if (error == Errors.TRANSACTIONAL_ID_AUTHORIZATION_FAILED\n                        || error == Errors.UNSUPPORTED_FOR_MESSAGE_FORMAT) {\n                    fatalError(error.exception());\n                    break;\n                } else {\n                    fatalError(new KafkaException(\"Unexpected error in TxnOffsetCommitResponse: \" + error.message()));\n                    break;\n                }\n            }\n\n            if (result.isCompleted()) {\n                pendingTxnOffsetCommits.clear();\n            } else if (pendingTxnOffsetCommits.isEmpty()) {\n                result.done();\n            } else {\n                // Retry the commits which failed with a retriable error\n                reenqueue();\n            }\n        }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1821-L1970",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1821,
  "end_line": 1970,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}