{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_ProducerBatch.java_521",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java",
  "content": "            CompressionRatioEstimator.updateEstimation(topicPartition.topic(),\n                                                       recordsBuilder.compression().type(),\n                                                       (float) recordsBuilder.compressionRatio());\n        }\n        reopened = false;\n    }\n\n    /**\n     * Abort the record builder and reset the state of the underlying buffer. This is used prior to aborting\n     * the batch with {@link #abort(RuntimeException)} and ensures that no record previously appended can be\n     * read. This is used in scenarios where we want to ensure a batch ultimately gets aborted, but in which\n     * it is not safe to invoke the completion callbacks (e.g. because we are holding a lock, such as\n     * when aborting batches in {@link RecordAccumulator}).\n     */\n    public void abortRecordAppends() {\n        recordsBuilder.abort();\n    }\n\n    public boolean isClosed() {\n        return recordsBuilder.isClosed();\n    }\n\n    public ByteBuffer buffer() {\n        return recordsBuilder.buffer();\n    }\n\n    public int initialCapacity() {\n        return recordsBuilder.initialCapacity();\n    }\n\n    public boolean isWritable() {\n        return !recordsBuilder.isClosed();\n    }\n\n    public byte magic() {\n        return recordsBuilder.magic();\n    }\n\n    public long producerId() {\n        return recordsBuilder.producerId();\n    }\n\n    public short producerEpoch() {\n        return recordsBuilder.producerEpoch();\n    }\n\n    public int baseSequence() {\n        return recordsBuilder.baseSequence();\n    }\n\n    public int lastSequence() {\n        return recordsBuilder.baseSequence() + recordsBuilder.numRecords() - 1;\n    }\n\n    public boolean hasSequence() {\n        return baseSequence() != RecordBatch.NO_SEQUENCE;\n    }\n\n    public boolean isTransactional() {\n        return recordsBuilder.isTransactional();\n    }\n\n    public boolean sequenceHasBeenReset() {\n        return reopened;\n    }\n\n    public boolean isBufferDeallocated() {\n        return bufferDeallocated;\n    }\n\n    public void markBufferDeallocated() {\n        bufferDeallocated = true;\n    }\n\n    public boolean isInflight() {\n        return inflight;\n    }\n\n    public void setInflight(boolean inflight) {\n        this.inflight = inflight;\n    }\n\n    // VisibleForTesting\n    OptionalInt currentLeaderEpoch() {\n        return currentLeaderEpoch;\n    }\n\n    // VisibleForTesting\n    int attemptsWhenLeaderLastChanged() {\n        return attemptsWhenLeaderLastChanged;\n    }\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java#L521-L613",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/ProducerBatch.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 521,
  "end_line": 613,
  "last_modified": "2026-02-06T01:16:27.609686",
  "source_type": "github"
}