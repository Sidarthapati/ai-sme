{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1951",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                Collections.emptyMap(), now, deadline);\n            runnable.call(call, now);\n        }\n        return new HashMap<>(topicFutures);\n    }\n\n    private Call getDeleteTopicsCall(final DeleteTopicsOptions options,\n                                     final Map<String, KafkaFutureImpl<Void>> futures,\n                                     final List<String> topics,\n                                     final Map<String, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                     final long now,\n                                     final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopicNames(topics)\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                // Check for controller change\n                handleNotControllerError(abstractResponse);\n                // Handle server responses for particular topics.\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<String> retryTopics = new ArrayList<>();\n                final Map<String, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.name());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic {}\", result.name());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.name());\n                                    retryTopicQuotaExceededExceptions.put(result.name(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                // If there are topics to retry, retry them; complete unrealized futures otherwise.\n                if (retryTopics.isEmpty()) {\n                    // The server should send back a response for every topic. But do a sanity check anyway.\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                // If there were any topics retries due to a quota exceeded exception, we propagate\n                // the initial error back to the caller if the request timed out.\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                // Fail all the other remaining futures\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }\n\n    private Call getDeleteTopicsWithIdsCall(final DeleteTopicsOptions options,\n                                            final Map<Uuid, KafkaFutureImpl<Void>> futures,\n                                            final List<Uuid> topicIds,\n                                            final Map<Uuid, ThrottlingQuotaExceededException> quotaExceededExceptions,\n                                            final long now,\n                                            final long deadline) {\n        return new Call(\"deleteTopics\", deadline, new ControllerNodeProvider()) {\n            @Override\n            DeleteTopicsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteTopicsRequest.Builder(\n                    new DeleteTopicsRequestData()\n                        .setTopics(topicIds.stream().map(\n                            topic -> new DeleteTopicState().setTopicId(topic)).collect(Collectors.toList()))\n                        .setTimeoutMs(timeoutMs));\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                // Check for controller change\n                handleNotControllerError(abstractResponse);\n                // Handle server responses for particular topics.\n                final DeleteTopicsResponse response = (DeleteTopicsResponse) abstractResponse;\n                final List<Uuid> retryTopics = new ArrayList<>();\n                final Map<Uuid, ThrottlingQuotaExceededException> retryTopicQuotaExceededExceptions = new HashMap<>();\n                for (DeletableTopicResult result : response.data().responses()) {\n                    KafkaFutureImpl<Void> future = futures.get(result.topicId());\n                    if (future == null) {\n                        log.warn(\"Server response mentioned unknown topic ID {}\", result.topicId());\n                    } else {\n                        ApiError error = new ApiError(result.errorCode(), result.errorMessage());\n                        if (error.isFailure()) {\n                            if (error.is(Errors.THROTTLING_QUOTA_EXCEEDED)) {\n                                ThrottlingQuotaExceededException quotaExceededException = new ThrottlingQuotaExceededException(\n                                    response.throttleTimeMs(), error.messageWithFallback());\n                                if (options.shouldRetryOnQuotaViolation()) {\n                                    retryTopics.add(result.topicId());\n                                    retryTopicQuotaExceededExceptions.put(result.topicId(), quotaExceededException);\n                                } else {\n                                    future.completeExceptionally(quotaExceededException);\n                                }\n                            } else {\n                                future.completeExceptionally(error.exception());\n                            }\n                        } else {\n                            future.complete(null);\n                        }\n                    }\n                }\n                // If there are topics to retry, retry them; complete unrealized futures otherwise.\n                if (retryTopics.isEmpty()) {\n                    // The server should send back a response for every topic. But do a sanity check anyway.\n                    completeUnrealizedFutures(futures.entrySet().stream(),\n                        topic -> \"The controller response did not contain a result for topic \" + topic);\n                } else {\n                    final long now = time.milliseconds();\n                    final Call call = getDeleteTopicsWithIdsCall(options, futures, retryTopics,\n                        retryTopicQuotaExceededExceptions, now, deadline);\n                    runnable.call(call, now);\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                // If there were any topics retries due to a quota exceeded exception, we propagate\n                // the initial error back to the caller if the request timed out.\n                maybeCompleteQuotaExceededException(options.shouldRetryOnQuotaViolation(),\n                    throwable, futures, quotaExceededExceptions, (int) (time.milliseconds() - now));\n                // Fail all the other remaining futures\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        };\n    }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1951-L2100",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1951,
  "end_line": 2100,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}