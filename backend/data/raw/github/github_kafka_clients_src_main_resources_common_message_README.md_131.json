{
  "id": "kafka_clients_src_main_resources_common_message_README.md_131",
  "title": "kafka/clients/src/main/resources/common/message/README.md",
  "content": "In order to make a field tagged, set a \"tag\" for the field, and also set up\ntagged versions for the field.  The taggedVersions you specify should be\nopen-ended-- that is, they should specify a start version, but not an end\nversion.\n\nYou can remove support for a tagged field from a specific version of a message,\nbut you can't reuse a tag once it has been used for something else.  Once tags\nhave been used for something, they can't be used for anything else, without\nbreaking compatibility.\n\nNote that tagged fields can only be added to \"flexible\" message versions.\n\n#### Default Value Handling for Tagged Fields\n\nIn Kafka's serialization mechanism, a tagged field may be omitted from the serialized message \nif all its associated fields are equal to their default values, whether those defaults are explicit \nor implicit. This behavior optimizes message size by avoiding the transmission of redundant data.\n\nFlexible Versions\n-----------------\nKafka serialization has been improved over time to be more flexible and\nefficient.  Message versions that contain these improvements are referred to as\n\"flexible versions.\"\n\nIn flexible versions, variable-length fields such as strings, arrays, and bytes\nfields are serialized in a more efficient way that saves space.  The new\nserialization types start with compact.  For example COMPACT_STRING is a more\nefficient form of STRING.\n\nSerializing Messages\n--------------------\nThe Message#write method writes out a message to a buffer.  The fields that are\nwritten out will depend on the version number that you supply to write().  When\nyou write out a message using an older version, fields that are too old to be\npresent in the schema will be omitted.\n\nWhen working with older message versions, please verify that the older message\nschema includes all the data that needs to be sent.  For example, it is probably\nOK to skip sending a timeout field.  However, a field which radically alters the\nmeaning of the request, such as a \"validateOnly\" boolean, should not be ignored.\n\nIt's often useful to know how much space a message will take up before writing\nit out to a buffer.  You can find this out by calling the Message#size method.\n\nDeserializing Messages\n----------------------\nMessage objects may be deserialized using the Message#read method.  This method\noverwrites all the data currently in the message object with new data.\n\nAny fields in the message object that are not present in the version that you\nare deserializing will be reset to default values.  Unless a custom default has\nbeen set:\n\n* Integer fields default to 0.\n\n* Floats default to 0.\n\n* Booleans default to false.\n\n* Strings default to the empty string.\n\n* Bytes fields default to the empty byte array.\n\n* Uuid fields default to zero uuid.\n\n* Records fields default to null.\n\n* Array fields default to empty.\n\nYou can specify \"null\" as a default value for a string field by specifying the\nliteral string \"null\".  Note that you can only specify null as a default if all\nversions of the field are nullable.\n\nCustom Default Values\n---------------------\nYou may set a custom default for fields that are integers, booleans, floats, or\nstrings.  Just add a \"default\" entry in the JSON object.  The custom default\noverrides the normal default for the type.  So for example, you could make a\nboolean field default to true rather than false, and so forth.\n\nNote that the default must be valid for the field type.  So the default for an\nint16 field must be an integer that fits in 16 bits, and so forth.  You may\nspecify hex or octal values, as long as they are prefixed with 0x or 0.  It is\ncurrently not possible to specify a custom default for bytes or array fields.\n\nCustom defaults are useful when an older message version lacked some\ninformation.  For example, if an older request lacked a timeout field, you may\nwant to specify that the server should assume that the timeout for such a\nrequest is 5000 ms (or some other arbitrary value).\n\nIgnorable Fields\n----------------\nWhen we write messages using an older or newer format, not all fields may be\npresent.  The message receiver will fill in the default value for the field\nduring deserialization.  Therefore, if the source field was set to a non-default\nvalue, that information will be lost.\n\nIn some cases, this information loss is acceptable.  For example, if a timeout\nfield does not get preserved, this is not a problem.  However, in other cases,\nthe field is really quite important and should not be discarded.  One example is\na \"verify only\" boolean which changes the whole meaning of the request.\n\nBy default, we assume that information loss is not acceptable.  The message\nserialization code will throw an exception if the ignored field is not set to\nthe default value.  If information loss for a field is OK, please set\n\"ignorable\" to true for the field to disable this behavior.  When ignorable is\nset to true, the field may be silently omitted during serialization.\n\nHash Sets\n---------\nOne very common pattern in Kafka is to load array elements from a message into\na Map or Set for easier access.  The message protocol makes this easier with\nthe \"mapKey\" concept.\n\nIf some of the elements of an array are annotated with \"mapKey\": true, the\nentire array will be treated as a linked hash set rather than a list.  Elements\nin this set will be accessible in O(1) time with an automatically generated\n\"find\" function.  The order of elements in the set will still be preserved,\nhowever.  New entries that are added to the set always show up as last in the\nordering.\n\nIncompatible Changes\n--------------------\nIt's very important to avoid making incompatible changes to the message\nprotocol.  Here are some examples of incompatible changes:\n\n#### Making changes to a protocol version which has already been released.\nProtocol versions that have been released must be regarded as done.  If there\nwere mistakes, they should be corrected in a new version rather than changing\nthe existing version.\n\n#### Re-ordering existing fields.\nIt is OK to add new fields before or after existing fields.  However, existing\nfields should not be re-ordered with respect to each other.\n\n#### Changing the default of an existing field.\nYou must never change the default of a field which already exists.  Otherwise,\nnew clients and old servers will not agree on the default, and so forth.\n\n#### Changing the type of an existing field.\nOne exception is that an array of primitives may be changed to an array of\nstructures containing the same data, as long as the conversion is done\ncorrectly.  The Kafka protocol does not do any \"boxing\" of structures, so an\narray of structs that contain a single int32 is the same as an array of int32s.\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/resources/common/message/README.md#L131-L275",
  "file_path": "clients/src/main/resources/common/message/README.md",
  "repo_name": "kafka",
  "language": "markdown",
  "start_line": 131,
  "end_line": 275,
  "last_modified": "2026-02-06T01:16:27.672908",
  "source_type": "github"
}