{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_1431",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "        private boolean hasActiveExternalCalls() {\n            if (hasActiveExternalCalls(pendingCalls)) {\n                return true;\n            }\n            for (List<Call> callList : callsToSend.values()) {\n                if (hasActiveExternalCalls(callList)) {\n                    return true;\n                }\n            }\n            return hasActiveExternalCalls(correlationIdToCalls.values());\n        }\n\n        private boolean threadShouldExit(long now, long curHardShutdownTimeMs) {\n            if (!hasActiveExternalCalls()) {\n                log.trace(\"All work has been completed, and the I/O thread is now exiting.\");\n                return true;\n            }\n            if (now >= curHardShutdownTimeMs) {\n                log.info(\"Forcing a hard I/O thread shutdown. Requests in progress will be aborted.\");\n                return true;\n            }\n            log.debug(\"Hard shutdown in {} ms.\", curHardShutdownTimeMs - now);\n            return false;\n        }\n\n        @Override\n        public void run() {\n            log.debug(\"Thread starting\");\n            try {\n                processRequests();\n            } finally {\n                closing = true;\n                AppInfoParser.unregisterAppInfo(JMX_PREFIX, clientId, metrics);\n\n                int numTimedOut = 0;\n                TimeoutProcessor timeoutProcessor = new TimeoutProcessor(Long.MAX_VALUE);\n                synchronized (this) {\n                    numTimedOut += timeoutProcessor.handleTimeouts(newCalls, \"The AdminClient thread has exited.\");\n                }\n                numTimedOut += timeoutProcessor.handleTimeouts(pendingCalls, \"The AdminClient thread has exited.\");\n                numTimedOut += timeoutCallsToSend(timeoutProcessor);\n                numTimedOut += timeoutProcessor.handleTimeouts(correlationIdToCalls.values(),\n                    \"The AdminClient thread has exited.\");\n                if (numTimedOut > 0) {\n                    log.info(\"Timed out {} remaining operation(s) during close.\", numTimedOut);\n                }\n                closeQuietly(client, \"KafkaClient\");\n                closeQuietly(metrics, \"Metrics\");\n                log.debug(\"Exiting AdminClientRunnable thread.\");\n            }\n        }\n\n        private void processRequests() {\n            long now = time.milliseconds();\n            while (true) {\n                // Copy newCalls into pendingCalls.\n                drainNewCalls();\n\n                // Check if the AdminClient thread should shut down.\n                long curHardShutdownTimeMs = hardShutdownTimeMs.get();\n                if ((curHardShutdownTimeMs != INVALID_SHUTDOWN_TIME) && threadShouldExit(now, curHardShutdownTimeMs))\n                    break;\n\n                // Handle timeouts.\n                TimeoutProcessor timeoutProcessor = timeoutProcessorFactory.create(now);\n                timeoutPendingCalls(timeoutProcessor);\n                timeoutCallsToSend(timeoutProcessor);\n                timeoutCallsInFlight(timeoutProcessor);\n\n                long pollTimeout = Math.min(1200000, timeoutProcessor.nextTimeoutMs());\n                if (curHardShutdownTimeMs != INVALID_SHUTDOWN_TIME) {\n                    pollTimeout = Math.min(pollTimeout, curHardShutdownTimeMs - now);\n                }\n\n                // Choose nodes for our pending calls.\n                pollTimeout = Math.min(pollTimeout, maybeDrainPendingCalls(now));\n                long metadataFetchDelayMs = metadataManager.metadataFetchDelayMs(now);\n                if (metadataFetchDelayMs == 0) {\n                    metadataManager.transitionToUpdatePending(now);\n                    Call metadataCall = makeMetadataCall(now);\n                    // Create a new metadata fetch call and add it to the end of pendingCalls.\n                    // Assign a node for just the new call (we handled the other pending nodes above).\n\n                    if (!maybeDrainPendingCall(metadataCall, now))\n                        pendingCalls.add(metadataCall);\n                }\n                pollTimeout = Math.min(pollTimeout, sendEligibleCalls(now));\n\n                if (metadataFetchDelayMs > 0) {\n                    pollTimeout = Math.min(pollTimeout, metadataFetchDelayMs);\n                }\n\n                // Ensure that we use a small poll timeout if there are pending calls which need to be sent\n                if (!pendingCalls.isEmpty())\n                    pollTimeout = Math.min(pollTimeout, retryBackoffMs);\n\n                // Wait for network responses.\n                log.trace(\"Entering KafkaClient#poll(timeout={})\", pollTimeout);\n                List<ClientResponse> responses = client.poll(Math.max(0L, pollTimeout), now);\n                log.trace(\"KafkaClient#poll retrieved {} response(s)\", responses.size());\n\n                // unassign calls to disconnected nodes\n                unassignUnsentCalls(client::connectionFailed);\n\n                // Update the current time and handle the latest responses.\n                now = time.milliseconds();\n                handleResponses(now, responses);\n            }\n        }\n\n        /**\n         * Queue a call for sending.\n         * <p>\n         * If the AdminClient thread has exited, this will fail. Otherwise, it will succeed (even\n         * if the AdminClient is shutting down). This function should called when retrying an\n         * existing call.\n         *\n         * @param call The new call object.\n         * @param now  The current time in milliseconds.\n         */\n        void enqueue(Call call, long now) {\n            if (call.tries > maxRetries) {\n                log.debug(\"Max retries {} for {} reached\", maxRetries, call);\n                call.handleTimeoutFailure(time.milliseconds(), new TimeoutException(\n                    \"Exceeded maxRetries after \" + call.tries + \" tries.\"));\n                return;\n            }\n            if (log.isDebugEnabled()) {\n                log.debug(\"Queueing {} with a timeout {} ms from now.\", call,\n                    Math.min(requestTimeoutMs, call.deadlineMs - now));\n            }\n            boolean accepted = false;\n            synchronized (this) {\n                if (!closing) {\n                    newCalls.add(call);\n                    accepted = true;\n                }\n            }\n            if (accepted) {\n                client.wakeup(); // wake the thread if it is in poll()\n            } else {\n                log.debug(\"The AdminClient thread has exited. Timing out {}.\", call);\n                call.handleTimeoutFailure(time.milliseconds(),\n                    new TimeoutException(\"The AdminClient thread has exited.\"));\n            }\n        }\n\n        /**\n         * Initiate a new call.\n         * <p>",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L1431-L1580",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1431,
  "end_line": 1580,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}