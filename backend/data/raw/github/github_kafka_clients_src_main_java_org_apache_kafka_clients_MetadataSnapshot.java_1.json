{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_MetadataSnapshot.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/MetadataSnapshot.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients;\n\nimport org.apache.kafka.common.Cluster;\nimport org.apache.kafka.common.ClusterResource;\nimport org.apache.kafka.common.Node;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.requests.MetadataResponse;\nimport org.apache.kafka.common.requests.MetadataResponse.PartitionMetadata;\n\nimport java.net.InetSocketAddress;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.OptionalInt;\nimport java.util.Set;\nimport java.util.function.BiPredicate;\nimport java.util.function.Predicate;\nimport java.util.stream.Collectors;\n\n/**\n * An internal immutable snapshot of nodes, topics, and partitions in the Kafka cluster. This keeps an up-to-date Cluster\n * instance which is optimized for read access.\n * Prefer to extend MetadataSnapshot's API for internal client usage Vs the public {@link Cluster}\n */\npublic class MetadataSnapshot {\n    private final String clusterId;\n    private final Map<Integer, Node> nodes;\n    private final Set<String> unauthorizedTopics;\n    private final Set<String> invalidTopics;\n    private final Set<String> internalTopics;\n    private final Node controller;\n    private final Map<TopicPartition, PartitionMetadata> metadataByPartition;\n    private final Map<String, Uuid> topicIds;\n    private final Map<Uuid, String> topicNames;\n    private Cluster clusterInstance;\n\n    public MetadataSnapshot(String clusterId,\n                  Map<Integer, Node> nodes,\n                  Collection<PartitionMetadata> partitions,\n                  Set<String> unauthorizedTopics,\n                  Set<String> invalidTopics,\n                  Set<String> internalTopics,\n                  Node controller,\n                  Map<String, Uuid> topicIds) {\n        this(clusterId, nodes, partitions, unauthorizedTopics, invalidTopics, internalTopics, controller, topicIds, null);\n    }\n\n    // Visible for testing\n    public MetadataSnapshot(String clusterId,\n        Map<Integer, Node> nodes,\n        Collection<PartitionMetadata> partitions,\n        Set<String> unauthorizedTopics,\n        Set<String> invalidTopics,\n        Set<String> internalTopics,\n        Node controller,\n        Map<String, Uuid> topicIds,\n        Cluster clusterInstance) {\n        this.clusterId = clusterId;\n        this.nodes = Collections.unmodifiableMap(nodes);\n        this.unauthorizedTopics = Collections.unmodifiableSet(unauthorizedTopics);\n        this.invalidTopics = Collections.unmodifiableSet(invalidTopics);\n        this.internalTopics = Collections.unmodifiableSet(internalTopics);\n        this.controller = controller;\n        this.topicIds = Collections.unmodifiableMap(topicIds);\n        this.topicNames = Collections.unmodifiableMap(\n            topicIds.entrySet().stream().collect(Collectors.toMap(Map.Entry::getValue, Map.Entry::getKey))\n        );\n\n        Map<TopicPartition, PartitionMetadata> tmpMetadataByPartition = new HashMap<>(partitions.size());\n        for (PartitionMetadata p : partitions) {\n            tmpMetadataByPartition.put(p.topicPartition, p);\n        }\n        this.metadataByPartition = Collections.unmodifiableMap(tmpMetadataByPartition);\n\n        if (clusterInstance == null) {\n            computeClusterView();\n        } else {\n            this.clusterInstance = clusterInstance;\n        }\n    }\n\n    Optional<PartitionMetadata> partitionMetadata(TopicPartition topicPartition) {\n        return Optional.ofNullable(metadataByPartition.get(topicPartition));\n    }\n\n    Map<String, Uuid> topicIds() {\n        return topicIds;\n    }\n\n    Map<Uuid, String> topicNames() {\n        return topicNames;\n    }\n\n    Optional<Node> nodeById(int id) {\n        return Optional.ofNullable(nodes.get(id));\n    }\n\n    public Cluster cluster() {\n        if (clusterInstance == null) {\n            throw new IllegalStateException(\"Cached Cluster instance should not be null, but was.\");\n        } else {\n            return clusterInstance;\n        }\n    }\n\n    /**\n     * Get leader-epoch for partition.\n     *\n     * @param tp partition\n     * @return leader-epoch if known, else return OptionalInt.empty()\n     */\n    public OptionalInt leaderEpochFor(TopicPartition tp) {\n        PartitionMetadata partitionMetadata = metadataByPartition.get(tp);\n        if (partitionMetadata == null || partitionMetadata.leaderEpoch.isEmpty()) {\n            return OptionalInt.empty();\n        } else {\n            return OptionalInt.of(partitionMetadata.leaderEpoch.get());\n        }\n    }\n\n    ClusterResource clusterResource() {\n        return new ClusterResource(clusterId);\n    }\n\n    /**\n     * Merges the metadata snapshot's contents with the provided metadata, returning a new metadata snapshot. The provided\n     * metadata is presumed to be more recent than the snapshot's metadata, and therefore all overlapping metadata will\n     * be overridden.",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/MetadataSnapshot.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/MetadataSnapshot.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.578672",
  "source_type": "github"
}