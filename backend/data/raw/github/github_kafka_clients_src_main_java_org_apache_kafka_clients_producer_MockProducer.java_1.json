{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_MockProducer.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer;\n\nimport org.apache.kafka.clients.consumer.ConsumerGroupMetadata;\nimport org.apache.kafka.clients.consumer.OffsetAndMetadata;\nimport org.apache.kafka.clients.producer.internals.FutureRecordMetadata;\nimport org.apache.kafka.clients.producer.internals.ProduceRequestResult;\nimport org.apache.kafka.common.Cluster;\nimport org.apache.kafka.common.KafkaException;\nimport org.apache.kafka.common.Metric;\nimport org.apache.kafka.common.MetricName;\nimport org.apache.kafka.common.PartitionInfo;\nimport org.apache.kafka.common.TopicPartition;\nimport org.apache.kafka.common.Uuid;\nimport org.apache.kafka.common.errors.ProducerFencedException;\nimport org.apache.kafka.common.errors.TimeoutException;\nimport org.apache.kafka.common.header.internals.RecordHeaders;\nimport org.apache.kafka.common.metrics.KafkaMetric;\nimport org.apache.kafka.common.record.RecordBatch;\nimport org.apache.kafka.common.serialization.Serializer;\nimport org.apache.kafka.common.utils.Time;\n\nimport java.time.Duration;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.concurrent.Future;\n\n/**\n * A mock of the producer interface you can use for testing code that uses Kafka.\n * <p>\n * By default this mock will synchronously complete each send call successfully. However it can be configured to allow\n * the user to control the completion of the call and supply an optional error for the producer to throw.\n */\npublic class MockProducer<K, V> implements Producer<K, V> {\n\n    private final Cluster cluster;\n    private final Partitioner partitioner;\n    private final List<ProducerRecord<K, V>> sent;\n    private final List<ProducerRecord<K, V>> uncommittedSends;\n    private final Deque<Completion> completions;\n    private final Map<TopicPartition, Long> offsets;\n    private final List<Map<String, Map<TopicPartition, OffsetAndMetadata>>> consumerGroupOffsets;\n    private final Map<MetricName, Metric> mockMetrics;\n    private final Serializer<K> keySerializer;\n    private final Serializer<V> valueSerializer;\n    private final boolean autoComplete;\n    private Map<String, Map<TopicPartition, OffsetAndMetadata>> uncommittedConsumerGroupOffsets;\n    private boolean closed;\n    private boolean transactionInitialized;\n    private boolean transactionInFlight;\n    private boolean transactionCommitted;\n    private boolean transactionAborted;\n    private boolean producerFenced;\n    private boolean sentOffsets;\n    private long commitCount = 0L;\n    private final List<KafkaMetric> addedMetrics = new ArrayList<>();\n\n    public RuntimeException initTransactionException = null;\n    public RuntimeException beginTransactionException = null;\n    public RuntimeException sendOffsetsToTransactionException = null;\n    public RuntimeException commitTransactionException = null;\n    public RuntimeException abortTransactionException = null;\n    public RuntimeException sendException = null;\n    public RuntimeException flushException = null;\n    public RuntimeException partitionsForException = null;\n    public RuntimeException closeException = null;\n    private boolean telemetryDisabled = false;\n    private Uuid clientInstanceId;\n    private int injectTimeoutExceptionCounter;\n\n    /**\n     * Create a mock producer\n     *\n     * @param cluster The cluster holding metadata for this producer\n     * @param autoComplete If true automatically complete all requests successfully and execute the callback. Otherwise\n     *        the user must call {@link #completeNext()} or {@link #errorNext(RuntimeException)} after\n     *        {@link #send(ProducerRecord) send()} to complete the call and unblock the {@link\n     *        java.util.concurrent.Future Future&lt;RecordMetadata&gt;} that is returned.\n     * @param partitioner The partition strategy\n     * @param keySerializer The serializer for key that implements {@link Serializer}.\n     * @param valueSerializer The serializer for value that implements {@link Serializer}.\n     */\n    public MockProducer(final Cluster cluster,\n                        final boolean autoComplete,\n                        final Partitioner partitioner,\n                        final Serializer<K> keySerializer,\n                        final Serializer<V> valueSerializer) {\n        this.cluster = cluster;\n        this.autoComplete = autoComplete;\n        this.partitioner = partitioner;\n        this.keySerializer = keySerializer;\n        this.valueSerializer = valueSerializer;\n        this.offsets = new HashMap<>();\n        this.sent = new ArrayList<>();\n        this.uncommittedSends = new ArrayList<>();\n        this.consumerGroupOffsets = new ArrayList<>();\n        this.uncommittedConsumerGroupOffsets = new HashMap<>();\n        this.completions = new ArrayDeque<>();\n        this.mockMetrics = new HashMap<>();\n    }\n\n    /**\n     * Create a new mock producer with invented metadata the given autoComplete setting, partitioner and key\\value serializers.\n     *\n     * Equivalent to {@link #MockProducer(Cluster, boolean, Partitioner, Serializer, Serializer) new MockProducer(Cluster.empty(), autoComplete, partitioner, keySerializer, valueSerializer)}\n     */\n    public MockProducer(final boolean autoComplete,\n                        final Partitioner partitioner,\n                        final Serializer<K> keySerializer,\n                        final Serializer<V> valueSerializer) {\n        this(Cluster.empty(), autoComplete, partitioner, keySerializer, valueSerializer);\n    }\n\n    /**\n     * Create a new mock producer with invented metadata.\n     *\n     * Equivalent to {@link #MockProducer(Cluster, boolean, Partitioner, Serializer, Serializer) new MockProducer(Cluster.empty(), false, null, null, null)}\n     */\n    public MockProducer() {\n        this(Cluster.empty(), false, null, null, null);\n    }\n\n    @Override\n    public void initTransactions(boolean keepPreparedTxn) {\n        verifyNotClosed();\n        verifyNotFenced();\n        if (this.transactionInitialized) {\n            throw new IllegalStateException(\"MockProducer has already been initialized for transactions.\");\n        }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java#L1-L150",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/MockProducer.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 150,
  "last_modified": "2026-02-06T01:16:27.608364",
  "source_type": "github"
}