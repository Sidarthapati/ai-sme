{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_3901",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "\n            @Override\n            void handleFailure(Throwable throwable) {\n                electionFuture.completeExceptionally(throwable);\n            }\n        }, now);\n\n        return new ElectLeadersResult(electionFuture);\n    }\n\n    @Override\n    public AlterPartitionReassignmentsResult alterPartitionReassignments(\n        Map<TopicPartition, Optional<NewPartitionReassignment>> reassignments,\n        AlterPartitionReassignmentsOptions options) {\n        final Map<TopicPartition, KafkaFutureImpl<Void>> futures = new HashMap<>();\n        final Map<String, Map<Integer, Optional<NewPartitionReassignment>>> topicsToReassignments = new TreeMap<>();\n        for (Map.Entry<TopicPartition, Optional<NewPartitionReassignment>> entry : reassignments.entrySet()) {\n            String topic = entry.getKey().topic();\n            int partition = entry.getKey().partition();\n            TopicPartition topicPartition = new TopicPartition(topic, partition);\n            Optional<NewPartitionReassignment> reassignment = entry.getValue();\n            KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n            futures.put(topicPartition, future);\n\n            if (topicNameIsUnrepresentable(topic)) {\n                future.completeExceptionally(new InvalidTopicException(\"The given topic name '\" +\n                    topic + \"' cannot be represented in a request.\"));\n            } else if (topicPartition.partition() < 0) {\n                future.completeExceptionally(new InvalidTopicException(\"The given partition index \" +\n                    topicPartition.partition() + \" is not valid.\"));\n            } else {\n                Map<Integer, Optional<NewPartitionReassignment>> partitionReassignments =\n                    topicsToReassignments.get(topicPartition.topic());\n                if (partitionReassignments == null) {\n                    partitionReassignments = new TreeMap<>();\n                    topicsToReassignments.put(topic, partitionReassignments);\n                }\n\n                partitionReassignments.put(partition, reassignment);\n            }\n        }\n\n        final long now = time.milliseconds();\n        Call call = new Call(\"alterPartitionReassignments\", calcDeadlineMs(now, options.timeoutMs()),\n            new ControllerNodeProvider(true)) {\n\n            @Override\n            public AlterPartitionReassignmentsRequest.Builder createRequest(int timeoutMs) {\n                AlterPartitionReassignmentsRequestData data =\n                    new AlterPartitionReassignmentsRequestData();\n                for (Map.Entry<String, Map<Integer, Optional<NewPartitionReassignment>>> entry :\n                    topicsToReassignments.entrySet()) {\n                    String topicName = entry.getKey();\n                    Map<Integer, Optional<NewPartitionReassignment>> partitionsToReassignments = entry.getValue();\n\n                    List<ReassignablePartition> reassignablePartitions = new ArrayList<>();\n                    for (Map.Entry<Integer, Optional<NewPartitionReassignment>> partitionEntry :\n                        partitionsToReassignments.entrySet()) {\n                        int partitionIndex = partitionEntry.getKey();\n                        Optional<NewPartitionReassignment> reassignment = partitionEntry.getValue();\n\n                        ReassignablePartition reassignablePartition = new ReassignablePartition()\n                            .setPartitionIndex(partitionIndex)\n                            .setReplicas(reassignment.map(NewPartitionReassignment::targetReplicas).orElse(null));\n                        reassignablePartitions.add(reassignablePartition);\n                    }\n\n                    ReassignableTopic reassignableTopic = new ReassignableTopic()\n                        .setName(topicName)\n                        .setPartitions(reassignablePartitions);\n                    data.topics().add(reassignableTopic);\n                }\n                data.setTimeoutMs(timeoutMs);\n                data.setAllowReplicationFactorChange(options.allowReplicationFactorChange());\n                return new AlterPartitionReassignmentsRequest.Builder(data);\n            }\n\n            @Override\n            public void handleResponse(AbstractResponse abstractResponse) {\n                AlterPartitionReassignmentsResponse response = (AlterPartitionReassignmentsResponse) abstractResponse;\n                Map<TopicPartition, ApiException> errors = new HashMap<>();\n                int receivedResponsesCount = 0;\n\n                Errors topLevelError = Errors.forCode(response.data().errorCode());\n                switch (topLevelError) {\n                    case NONE:\n                        receivedResponsesCount += validateTopicResponses(response.data().responses(), errors);\n                        break;\n                    case NOT_CONTROLLER:\n                        handleNotControllerError(topLevelError);\n                        break;\n                    default:\n                        for (ReassignableTopicResponse topicResponse : response.data().responses()) {\n                            String topicName = topicResponse.name();\n                            for (ReassignablePartitionResponse partition : topicResponse.partitions()) {\n                                errors.put(\n                                    new TopicPartition(topicName, partition.partitionIndex()),\n                                    topLevelError.exception(response.data().errorMessage())\n                                );\n                                receivedResponsesCount += 1;\n                            }\n                        }\n                        break;\n                }\n\n                assertResponseCountMatch(errors, receivedResponsesCount);\n                for (Map.Entry<TopicPartition, ApiException> entry : errors.entrySet()) {\n                    ApiException exception = entry.getValue();\n                    if (exception == null)\n                        futures.get(entry.getKey()).complete(null);\n                    else\n                        futures.get(entry.getKey()).completeExceptionally(exception);\n                }\n            }\n\n            private void assertResponseCountMatch(Map<TopicPartition, ApiException> errors, int receivedResponsesCount) {\n                int expectedResponsesCount = topicsToReassignments.values().stream().mapToInt(Map::size).sum();\n                if (errors.values().stream().noneMatch(Objects::nonNull) && receivedResponsesCount != expectedResponsesCount) {\n                    String quantifier = receivedResponsesCount > expectedResponsesCount ? \"many\" : \"less\";\n                    throw new UnknownServerException(\"The server returned too \" + quantifier + \" results.\" +\n                        \"Expected \" + expectedResponsesCount + \" but received \" + receivedResponsesCount);\n                }\n            }\n\n            private int validateTopicResponses(List<ReassignableTopicResponse> topicResponses,\n                                               Map<TopicPartition, ApiException> errors) {\n                int receivedResponsesCount = 0;\n\n                for (ReassignableTopicResponse topicResponse : topicResponses) {\n                    String topicName = topicResponse.name();\n                    for (ReassignablePartitionResponse partResponse : topicResponse.partitions()) {\n                        Errors partitionError = Errors.forCode(partResponse.errorCode());\n\n                        TopicPartition tp = new TopicPartition(topicName, partResponse.partitionIndex());\n                        if (partitionError == Errors.NONE) {\n                            errors.put(tp, null);\n                        } else {\n                            errors.put(tp, partitionError.exception(partResponse.errorMessage()));\n                        }\n                        receivedResponsesCount += 1;\n                    }\n                }\n\n                return receivedResponsesCount;\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                for (KafkaFutureImpl<Void> future : futures.values()) {\n                    future.completeExceptionally(throwable);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L3901-L4050",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 3901,
  "end_line": 4050,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}