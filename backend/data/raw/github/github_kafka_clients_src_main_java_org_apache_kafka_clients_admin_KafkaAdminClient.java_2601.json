{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_2601",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "                KafkaFutureImpl<Void> future = new KafkaFutureImpl<>();\n                futures.put(acl, future);\n                String indefinite = acl.toFilter().findIndefiniteField();\n                if (indefinite == null) {\n                    aclCreations.add(CreateAclsRequest.aclCreation(acl));\n                    aclBindingsSent.add(acl);\n                } else {\n                    future.completeExceptionally(new InvalidRequestException(\"Invalid ACL creation: \" +\n                        indefinite));\n                }\n            }\n        }\n        final CreateAclsRequestData data = new CreateAclsRequestData().setCreations(aclCreations);\n        runnable.call(new Call(\"createAcls\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedBrokerOrActiveKController()) {\n\n            @Override\n            CreateAclsRequest.Builder createRequest(int timeoutMs) {\n                return new CreateAclsRequest.Builder(data);\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                handleNotControllerError(abstractResponse);\n                CreateAclsResponse response = (CreateAclsResponse) abstractResponse;\n                List<AclCreationResult> responses = response.results();\n                Iterator<AclCreationResult> iter = responses.iterator();\n                for (AclBinding aclBinding : aclBindingsSent) {\n                    KafkaFutureImpl<Void> future = futures.get(aclBinding);\n                    if (!iter.hasNext()) {\n                        future.completeExceptionally(new UnknownServerException(\n                            \"The broker reported no creation result for the given ACL: \" + aclBinding));\n                    } else {\n                        AclCreationResult creation = iter.next();\n                        Errors error = Errors.forCode(creation.errorCode());\n                        ApiError apiError = new ApiError(error, creation.errorMessage());\n                        if (apiError.isFailure())\n                            future.completeExceptionally(apiError.exception());\n                        else\n                            future.complete(null);\n                    }\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        }, now);\n        return new CreateAclsResult(new HashMap<>(futures));\n    }\n\n    @Override\n    public DeleteAclsResult deleteAcls(Collection<AclBindingFilter> filters, DeleteAclsOptions options) {\n        final long now = time.milliseconds();\n        final Map<AclBindingFilter, KafkaFutureImpl<FilterResults>> futures = new HashMap<>();\n        final List<AclBindingFilter> aclBindingFiltersSent = new ArrayList<>();\n        final List<DeleteAclsFilter> deleteAclsFilters = new ArrayList<>();\n        for (AclBindingFilter filter : filters) {\n            if (futures.get(filter) == null) {\n                aclBindingFiltersSent.add(filter);\n                deleteAclsFilters.add(DeleteAclsRequest.deleteAclsFilter(filter));\n                futures.put(filter, new KafkaFutureImpl<>());\n            }\n        }\n        final DeleteAclsRequestData data = new DeleteAclsRequestData().setFilters(deleteAclsFilters);\n        runnable.call(new Call(\"deleteAcls\", calcDeadlineMs(now, options.timeoutMs()),\n            new LeastLoadedBrokerOrActiveKController()) {\n\n            @Override\n            DeleteAclsRequest.Builder createRequest(int timeoutMs) {\n                return new DeleteAclsRequest.Builder(data);\n            }\n\n            @Override\n            void handleResponse(AbstractResponse abstractResponse) {\n                handleNotControllerError(abstractResponse);\n                DeleteAclsResponse response = (DeleteAclsResponse) abstractResponse;\n                List<DeleteAclsResponseData.DeleteAclsFilterResult> results = response.filterResults();\n                Iterator<DeleteAclsResponseData.DeleteAclsFilterResult> iter = results.iterator();\n                for (AclBindingFilter bindingFilter : aclBindingFiltersSent) {\n                    KafkaFutureImpl<FilterResults> future = futures.get(bindingFilter);\n                    if (!iter.hasNext()) {\n                        future.completeExceptionally(new UnknownServerException(\n                            \"The broker reported no deletion result for the given filter.\"));\n                    } else {\n                        DeleteAclsFilterResult filterResult = iter.next();\n                        ApiError error = new ApiError(Errors.forCode(filterResult.errorCode()), filterResult.errorMessage());\n                        if (error.isFailure()) {\n                            future.completeExceptionally(error.exception());\n                        } else {\n                            List<FilterResult> filterResults = new ArrayList<>();\n                            for (DeleteAclsMatchingAcl matchingAcl : filterResult.matchingAcls()) {\n                                Errors aclError = Errors.forCode(matchingAcl.errorCode());\n                                AclBinding aclBinding = DeleteAclsResponse.aclBinding(matchingAcl);\n                                filterResults.add(new FilterResult(aclBinding, aclError.exception(matchingAcl.errorMessage())));\n                            }\n                            future.complete(new FilterResults(filterResults));\n                        }\n                    }\n                }\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                completeAllExceptionally(futures.values(), throwable);\n            }\n        }, now);\n        return new DeleteAclsResult(new HashMap<>(futures));\n    }\n\n    @Override\n    public DescribeConfigsResult describeConfigs(Collection<ConfigResource> configResources, final DescribeConfigsOptions options) {\n        // Partition the requested config resources based on which broker they must be sent to with the\n        // null broker being used for config resources which can be obtained from any broker\n        final Map<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> nodeFutures = new HashMap<>(configResources.size());\n\n        for (ConfigResource resource : configResources) {\n            Integer broker = nodeFor(resource);\n            nodeFutures.compute(broker, (key, value) -> {\n                if (value == null) {\n                    value = new HashMap<>();\n                }\n                value.put(resource, new KafkaFutureImpl<>());\n                return value;\n            });\n        }\n\n        final long now = time.milliseconds();\n        for (Map.Entry<Integer, Map<ConfigResource, KafkaFutureImpl<Config>>> entry : nodeFutures.entrySet()) {\n            final Integer node = entry.getKey();\n            Map<ConfigResource, KafkaFutureImpl<Config>> unified = entry.getValue();\n\n            runnable.call(new Call(\"describeConfigs\", calcDeadlineMs(now, options.timeoutMs()),\n                node != null ? new ConstantNodeIdProvider(node, true) : new LeastLoadedBrokerOrActiveKController()) {\n\n                @Override\n                DescribeConfigsRequest.Builder createRequest(int timeoutMs) {\n                    return new DescribeConfigsRequest.Builder(new DescribeConfigsRequestData()\n                        .setResources(unified.keySet().stream()\n                            .map(config ->\n                                new DescribeConfigsRequestData.DescribeConfigsResource()\n                                    .setResourceName(config.name())\n                                    .setResourceType(config.type().id())\n                                    .setConfigurationKeys(null))\n                            .collect(Collectors.toList()))\n                        .setIncludeSynonyms(options.includeSynonyms())\n                        .setIncludeDocumentation(options.includeDocumentation()));\n                }\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L2601-L2750",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 2601,
  "end_line": 2750,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}