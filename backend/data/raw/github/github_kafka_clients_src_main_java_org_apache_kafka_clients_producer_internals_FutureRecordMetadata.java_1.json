{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_FutureRecordMetadata.java_1",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/FutureRecordMetadata.java",
  "content": "/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.kafka.clients.producer.internals;\n\nimport org.apache.kafka.clients.producer.RecordMetadata;\nimport org.apache.kafka.common.utils.Time;\n\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.TimeoutException;\n\n/**\n * The future result of a record send\n */\npublic final class FutureRecordMetadata implements Future<RecordMetadata> {\n\n    private final ProduceRequestResult result;\n    private final int batchIndex;\n    private final long createTimestamp;\n    private final int serializedKeySize;\n    private final int serializedValueSize;\n    private final Time time;\n    private volatile FutureRecordMetadata nextRecordMetadata = null;\n\n    public FutureRecordMetadata(ProduceRequestResult result, int batchIndex, long createTimestamp, int serializedKeySize,\n                                int serializedValueSize, Time time) {\n        this.result = result;\n        this.batchIndex = batchIndex;\n        this.createTimestamp = createTimestamp;\n        this.serializedKeySize = serializedKeySize;\n        this.serializedValueSize = serializedValueSize;\n        this.time = time;\n    }\n\n    @Override\n    public boolean cancel(boolean interrupt) {\n        return false;\n    }\n\n    @Override\n    public boolean isCancelled() {\n        return false;\n    }\n\n    @Override\n    public RecordMetadata get() throws InterruptedException, ExecutionException {\n        this.result.await();\n        if (nextRecordMetadata != null)\n            return nextRecordMetadata.get();\n        return valueOrError();\n    }\n\n    @Override\n    public RecordMetadata get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n        // Handle overflow.\n        long now = time.milliseconds();\n        long timeoutMillis = unit.toMillis(timeout);\n        long deadline = Long.MAX_VALUE - timeoutMillis < now ? Long.MAX_VALUE : now + timeoutMillis;\n        boolean occurred = this.result.await(timeout, unit);\n        if (!occurred)\n            throw new TimeoutException(\"Timeout after waiting for \" + timeoutMillis + \" ms.\");\n        if (nextRecordMetadata != null)\n            return nextRecordMetadata.get(deadline - time.milliseconds(), TimeUnit.MILLISECONDS);\n        return valueOrError();\n    }\n\n    /**\n     * This method is used when we have to split a large batch in smaller ones. A chained metadata will allow the\n     * future that has already returned to the users to wait on the newly created split batches even after the\n     * old big batch has been deemed as done.\n     */\n    void chain(FutureRecordMetadata futureRecordMetadata) {\n        if (nextRecordMetadata == null)\n            nextRecordMetadata = futureRecordMetadata;\n        else\n            nextRecordMetadata.chain(futureRecordMetadata);\n    }\n\n    RecordMetadata valueOrError() throws ExecutionException {\n        RuntimeException exception = this.result.error(batchIndex);\n        if (exception != null)\n            throw new ExecutionException(exception);\n        else\n            return value();\n    }\n\n    RecordMetadata value() {\n        if (nextRecordMetadata != null)\n            return nextRecordMetadata.value();\n        return new RecordMetadata(result.topicPartition(), this.result.baseOffset(), this.batchIndex,\n                                  timestamp(), this.serializedKeySize, this.serializedValueSize);\n    }\n\n    private long timestamp() {\n        return result.hasLogAppendTime() ? result.logAppendTime() : createTimestamp;\n    }\n\n    @Override\n    public boolean isDone() {\n        if (nextRecordMetadata != null)\n            return nextRecordMetadata.isDone();\n        return this.result.completed();\n    }\n\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/FutureRecordMetadata.java#L1-L121",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/FutureRecordMetadata.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1,
  "end_line": 121,
  "last_modified": "2026-02-06T01:16:27.609395",
  "source_type": "github"
}