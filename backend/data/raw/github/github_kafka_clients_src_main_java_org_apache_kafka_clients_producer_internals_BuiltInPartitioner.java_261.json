{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_BuiltInPartitioner.java_261",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/BuiltInPartitioner.java",
  "content": "            return;\n        }\n\n        // We build cumulative frequency table from the queue sizes in place.  At the beginning\n        // each entry contains queue size, then we invert it (so it represents the frequency)\n        // and convert to a running sum.  Then a uniformly distributed random variable\n        // in the range [0..last) would map to a partition with weighted probability.\n        // Example: suppose we have 3 partitions with the corresponding queue sizes:\n        //  0 3 1\n        // Then we can invert them by subtracting the queue size from the max queue size + 1 = 4:\n        //  4 1 3\n        // Then we can convert it into a running sum (next value adds previous value):\n        //  4 5 8\n        // Now if we get a random number in the range [0..8) and find the first value that\n        // is strictly greater than the number (e.g. for 4 it would be 5), then the index of\n        // the value is the index of the partition we're looking for.  In this example\n        // random numbers 0, 1, 2, 3 would map to partition[0], 4 would map to partition[1]\n        // and 5, 6, 7 would map to partition[2].\n\n        // Calculate max queue size + 1 and check if all sizes are the same.\n        int maxSizePlus1 = queueSizes[0];\n        boolean allEqual = true;\n        for (int i = 1; i < length; i++) {\n            if (queueSizes[i] != maxSizePlus1)\n                allEqual = false;\n            if (queueSizes[i] > maxSizePlus1)\n                maxSizePlus1 = queueSizes[i];\n        }\n        ++maxSizePlus1;\n\n        if (allEqual && length == queueSizes.length) {\n            // No need to have complex probability logic when all queue sizes are the same,\n            // and we didn't exclude partitions that experience high latencies (greater than\n            // partitioner.availability.timeout.ms).\n            log.trace(\"All queue lengths are the same, not using adaptive for topic {}\", topic);\n            partitionLoadStats = null;\n            return;\n        }\n\n        // Invert and fold the queue size, so that they become separator values in the CFT.\n        queueSizes[0] = maxSizePlus1 - queueSizes[0];\n        for (int i = 1; i < length; i++) {\n            queueSizes[i] = maxSizePlus1 - queueSizes[i] + queueSizes[i - 1];\n        }\n        log.trace(\"Partition load stats for topic {}: CFT={}, IDs={}, length={}\",\n                topic, queueSizes, partitionIds, length);\n        partitionLoadStats = new PartitionLoadStats(queueSizes, partitionIds, length);\n    }\n\n    /**\n     * Info for the current sticky partition.\n     */\n    public static class StickyPartitionInfo {\n        private final int index;\n        private final AtomicInteger producedBytes = new AtomicInteger();\n\n        StickyPartitionInfo(int index) {\n            this.index = index;\n        }\n\n        public int partition() {\n            return index;\n        }\n    }\n\n    /*\n     * Default hashing function to choose a partition from the serialized key bytes\n     */\n    public static int partitionForKey(final byte[] serializedKey, final int numPartitions) {\n        return Utils.toPositive(Utils.murmur2(serializedKey)) % numPartitions;\n    }\n\n    /**\n     * The partition load stats for each topic that are used for adaptive partition distribution.\n     */\n    private static final class PartitionLoadStats {\n        public final int[] cumulativeFrequencyTable;\n        public final int[] partitionIds;\n        public final int length;\n\n        public PartitionLoadStats(int[] cumulativeFrequencyTable, int[] partitionIds, int length) {\n            assert cumulativeFrequencyTable.length == partitionIds.length;\n            assert length <= cumulativeFrequencyTable.length;\n            this.cumulativeFrequencyTable = cumulativeFrequencyTable;\n            this.partitionIds = partitionIds;\n            this.length = length;\n        }\n    }\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/BuiltInPartitioner.java#L261-L350",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/BuiltInPartitioner.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 261,
  "end_line": 350,
  "last_modified": "2026-02-06T01:16:27.609205",
  "source_type": "github"
}