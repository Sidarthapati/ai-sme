{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_521",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "        log.debug(\"Updating isTV2 enabled to {} with FinalizedFeaturesEpoch {}\", isTransactionV2Enabled, latestFinalizedFeaturesEpoch);\n        if (!onInitiatialization && !wasTransactionV2Enabled && isTransactionV2Enabled)\n            clientSideEpochBumpRequired = true;\n    }\n\n    public boolean isTransactionV2Enabled() {\n        return isTransactionV2Enabled;\n    }\n\n    public boolean is2PCEnabled() {\n        return enable2PC;\n    }\n\n    synchronized boolean hasPartitionsToAdd() {\n        return !newPartitionsInTransaction.isEmpty() || !pendingPartitionsInTransaction.isEmpty();\n    }\n\n    synchronized boolean isCompleting() {\n        return currentState == State.COMMITTING_TRANSACTION || currentState == State.ABORTING_TRANSACTION;\n    }\n\n    synchronized boolean hasError() {\n        return currentState == State.ABORTABLE_ERROR || currentState == State.FATAL_ERROR;\n    }\n\n    synchronized boolean isAborting() {\n        return currentState == State.ABORTING_TRANSACTION;\n    }\n\n    synchronized void transitionToAbortableError(RuntimeException exception) {\n        if (currentState == State.ABORTING_TRANSACTION) {\n            log.debug(\"Skipping transition to abortable error state since the transaction is already being \" +\n                    \"aborted. Underlying exception: \", exception);\n            return;\n        }\n\n        log.info(\"Transiting to abortable error state due to {}\", exception.toString());\n        transitionTo(State.ABORTABLE_ERROR, exception);\n    }\n\n    synchronized void transitionToFatalError(RuntimeException exception) {\n        log.info(\"Transiting to fatal error state due to {}\", exception.toString());\n        transitionTo(State.FATAL_ERROR, exception);\n\n        if (pendingTransition != null) {\n            pendingTransition.result.fail(exception);\n        }\n    }\n\n    /**\n     * Transitions to an abortable error state if the coordinator can handle an abortable error or\n     * to a fatal error if not.\n     *\n     * @param abortableException    The exception in case of an abortable error.\n     * @param fatalException        The exception in case of a fatal error.\n     */\n    private void transitionToAbortableErrorOrFatalError(\n        RuntimeException abortableException,\n        RuntimeException fatalException\n    ) {\n        if (canHandleAbortableError()) {\n            if (needToTriggerEpochBumpFromClient())\n                clientSideEpochBumpRequired = true;\n            transitionToAbortableError(abortableException);\n        } else {\n            transitionToFatalError(fatalException);\n        }\n    }\n\n    // visible for testing\n    synchronized boolean isPartitionPendingAdd(TopicPartition partition) {\n        return newPartitionsInTransaction.contains(partition) || pendingPartitionsInTransaction.contains(partition);\n    }\n\n    /**\n     * Get the current producer id and epoch without blocking. Callers must use {@link ProducerIdAndEpoch#isValid()} to\n     * verify that the result is valid.\n     *\n     * @return the current ProducerIdAndEpoch.\n     */\n    ProducerIdAndEpoch producerIdAndEpoch() {\n        return producerIdAndEpoch;\n    }\n\n    public synchronized void maybeUpdateProducerIdAndEpoch(TopicPartition topicPartition) {\n        if (hasFatalError()) {\n            log.debug(\"Ignoring producer ID and epoch update request since the producer is in fatal error state\");\n            return;\n        }\n\n        if (hasStaleProducerIdAndEpoch(topicPartition) && !hasInflightBatches(topicPartition)) {\n            // If the batch was on a different ID and/or epoch (due to an epoch bump) and all its in-flight batches\n            // have completed, reset the partition sequence so that the next batch (with the new epoch) starts from 0\n            txnPartitionMap.startSequencesAtBeginning(topicPartition, this.producerIdAndEpoch);\n            log.debug(\"ProducerId of partition {} set to {} with epoch {}. Reinitialize sequence at beginning.\",\n                      topicPartition, producerIdAndEpoch.producerId, producerIdAndEpoch.epoch);\n        }\n    }\n\n    /**\n     * Set the producer id and epoch atomically.\n     */\n    private void setProducerIdAndEpoch(ProducerIdAndEpoch producerIdAndEpoch) {\n        // With TV2, the epoch bump is common and frequent. Only log if it is at debug level or the producer ID is changed.\n        if (!isTransactional() || !isTransactionV2Enabled || producerIdAndEpoch.producerId != this.producerIdAndEpoch.producerId) {\n            log.info(\"ProducerId set to {} with epoch {}\", producerIdAndEpoch.producerId, producerIdAndEpoch.epoch);\n        } else {\n            log.debug(\"ProducerId set to {} with epoch {}\", producerIdAndEpoch.producerId, producerIdAndEpoch.epoch);\n        }\n        this.producerIdAndEpoch = producerIdAndEpoch;\n    }\n\n    /**\n     * This method resets the producer ID and epoch and sets the state to UNINITIALIZED, which will trigger a new\n     * InitProducerId request. This method is only called when the producer epoch is exhausted; we will bump the epoch\n     * instead.\n     */\n    private void resetIdempotentProducerId() {\n        if (isTransactional())\n            throw new IllegalStateException(\"Cannot reset producer state for a transactional producer. \" +\n                    \"You must either abort the ongoing transaction or reinitialize the transactional producer instead\");\n        log.debug(\"Resetting idempotent producer ID. ID and epoch before reset are {}\", this.producerIdAndEpoch);\n        setProducerIdAndEpoch(ProducerIdAndEpoch.NONE);\n        transitionTo(State.UNINITIALIZED);\n    }\n\n    private void resetSequenceForPartition(TopicPartition topicPartition) {\n        txnPartitionMap.remove(topicPartition);\n        this.partitionsWithUnresolvedSequences.remove(topicPartition);\n    }\n\n    private void resetSequenceNumbers() {\n        txnPartitionMap.reset();\n        this.partitionsWithUnresolvedSequences.clear();\n    }\n\n    /**\n     * This method is used to trigger an epoch bump for non-transactional idempotent producers.\n     */\n    synchronized void requestIdempotentEpochBumpForPartition(TopicPartition tp) {\n        clientSideEpochBumpRequired = true;\n        this.partitionsToRewriteSequences.add(tp);\n    }\n\n    private void bumpIdempotentProducerEpoch() {\n        if (this.producerIdAndEpoch.epoch == Short.MAX_VALUE) {\n            resetIdempotentProducerId();\n        } else {\n            setProducerIdAndEpoch(new ProducerIdAndEpoch(this.producerIdAndEpoch.producerId, (short) (this.producerIdAndEpoch.epoch + 1)));\n            log.debug(\"Incremented producer epoch, current producer ID and epoch are now {}\", this.producerIdAndEpoch);",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L521-L670",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 521,
  "end_line": 670,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}