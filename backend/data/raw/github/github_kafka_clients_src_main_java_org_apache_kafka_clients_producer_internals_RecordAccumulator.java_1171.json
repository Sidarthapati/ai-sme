{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_RecordAccumulator.java_1171",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/RecordAccumulator.java",
  "content": "    /**\n     * Abort any batches which have not been drained\n     */\n    void abortUndrainedBatches(RuntimeException reason) {\n        for (ProducerBatch batch : incomplete.copyAll()) {\n            Deque<ProducerBatch> dq = getDeque(batch.topicPartition);\n            boolean aborted = false;\n            synchronized (dq) {\n                if ((transactionManager != null && !batch.hasSequence()) || (transactionManager == null && !batch.isClosed())) {\n                    aborted = true;\n                    batch.abortRecordAppends();\n                    dq.remove(batch);\n                }\n            }\n            if (aborted) {\n                batch.abort(reason);\n                completeAndDeallocateBatch(batch);\n            }\n        }\n    }\n\n    public void mutePartition(TopicPartition tp) {\n        muted.add(tp);\n    }\n\n    public void unmutePartition(TopicPartition tp) {\n        muted.remove(tp);\n    }\n\n    /**\n     * Close this accumulator and force all the record buffers to be drained\n     */\n    public void close() {\n        this.closed = true;\n        this.free.close();\n    }\n\n    /**\n     * Partitioner config for built-in partitioner\n     */\n    public static final class PartitionerConfig {\n        private final boolean enableAdaptivePartitioning;\n        private final long partitionAvailabilityTimeoutMs;\n\n        /**\n         * Partitioner config\n         *\n         * @param enableAdaptivePartitioning If it's true, partition switching adapts to broker load, otherwise partition\n         *        switching is random.\n         * @param partitionAvailabilityTimeoutMs If a broker cannot process produce requests from a partition\n         *        for the specified time, the partition is treated by the partitioner as not available.\n         *        If the timeout is 0, this logic is disabled.\n         */\n        public PartitionerConfig(boolean enableAdaptivePartitioning, long partitionAvailabilityTimeoutMs) {\n            this.enableAdaptivePartitioning = enableAdaptivePartitioning;\n            this.partitionAvailabilityTimeoutMs = partitionAvailabilityTimeoutMs;\n        }\n\n        public PartitionerConfig() {\n            this(false, 0);\n        }\n    }\n\n    /*\n     * Metadata about a record just appended to the record accumulator\n     */\n    public static final class RecordAppendResult {\n        public final FutureRecordMetadata future;\n        public final boolean batchIsFull;\n        public final boolean newBatchCreated;\n        public final int appendedBytes;\n\n        public RecordAppendResult(FutureRecordMetadata future,\n                                  boolean batchIsFull,\n                                  boolean newBatchCreated,\n                                  int appendedBytes) {\n            this.future = future;\n            this.batchIsFull = batchIsFull;\n            this.newBatchCreated = newBatchCreated;\n            this.appendedBytes = appendedBytes;\n        }\n    }\n\n    /*\n     * The callbacks passed into append\n     */\n    public interface AppendCallbacks extends Callback {\n        /**\n         * Called to set partition (when append is called, partition may not be calculated yet).\n         * @param partition The partition\n         */\n        void setPartition(int partition);\n    }\n\n    /*\n     * The set of nodes that have at least one complete record batch in the accumulator\n     */\n    public static final class ReadyCheckResult {\n        public final Set<Node> readyNodes;\n        public final long nextReadyCheckDelayMs;\n        public final Set<String> unknownLeaderTopics;\n\n        public ReadyCheckResult(Set<Node> readyNodes, long nextReadyCheckDelayMs, Set<String> unknownLeaderTopics) {\n            this.readyNodes = readyNodes;\n            this.nextReadyCheckDelayMs = nextReadyCheckDelayMs;\n            this.unknownLeaderTopics = unknownLeaderTopics;\n        }\n    }\n\n    /**\n     * Per topic info.\n     */\n    private static class TopicInfo {\n        public final ConcurrentMap<Integer /*partition*/, Deque<ProducerBatch>> batches = new CopyOnWriteMap<>();\n        public final BuiltInPartitioner builtInPartitioner;\n\n        public TopicInfo(BuiltInPartitioner builtInPartitioner) {\n            this.builtInPartitioner = builtInPartitioner;\n        }\n    }\n\n    /**\n     * Node latency stats for each node that are used for adaptive partition distribution\n     * Visible for testing\n     */\n    public static final class NodeLatencyStats {\n        public volatile long readyTimeMs;  // last time the node had batches ready to send\n        public volatile long drainTimeMs;  // last time the node was able to drain batches\n\n        NodeLatencyStats(long nowMs) {\n            readyTimeMs = nowMs;\n            drainTimeMs = nowMs;\n        }\n    }\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/RecordAccumulator.java#L1171-L1306",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/RecordAccumulator.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1171,
  "end_line": 1306,
  "last_modified": "2026-02-06T01:16:27.610051",
  "source_type": "github"
}