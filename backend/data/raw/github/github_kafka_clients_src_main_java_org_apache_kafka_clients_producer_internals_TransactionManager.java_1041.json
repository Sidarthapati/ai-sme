{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_internals_TransactionManager.java_1041",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "content": "        // sequence 0, then retry the failed batch, which should now succeed. For the transactional producer, allow the\n        // batch to fail. When processing the failed batch, we will transition to an abortable error and set a flag\n        // indicating that we need to bump the epoch (if supported by the broker).\n        if (error == Errors.UNKNOWN_PRODUCER_ID) {\n            if (response.logStartOffset == -1) {\n                // We don't know the log start offset with this response. We should just retry the request until we get it.\n                // The UNKNOWN_PRODUCER_ID error code was added along with the new ProduceResponse which includes the\n                // logStartOffset. So the '-1' sentinel is not for backward compatibility. Instead, it is possible for\n                // a broker to not know the logStartOffset at when it is returning the response because the partition\n                // may have moved away from the broker from the time the error was initially raised to the time the\n                // response was being constructed. In these cases, we should just retry the request: we are guaranteed\n                // to eventually get a logStartOffset once things settle down.\n                return true;\n            }\n\n            if (batch.sequenceHasBeenReset()) {\n                // When the first inflight batch fails due to the truncation case, then the sequences of all the other\n                // in flight batches would have been restarted from the beginning. However, when those responses\n                // come back from the broker, they would also come with an UNKNOWN_PRODUCER_ID error. In this case, we should not\n                // reset the sequence numbers to the beginning.\n                return true;\n            } else if (lastAckedOffset(batch.topicPartition).orElse(TxnPartitionEntry.NO_LAST_ACKED_SEQUENCE_NUMBER) < response.logStartOffset) {\n                // The head of the log has been removed, probably due to the retention time elapsing. In this case,\n                // we expect to lose the producer state. For the transactional producer, reset the sequences of all\n                // inflight batches to be from the beginning and retry them, so that the transaction does not need to\n                // be aborted. For the idempotent producer, bump the epoch to avoid reusing (sequence, epoch) pairs\n                if (isTransactional()) {\n                    txnPartitionMap.startSequencesAtBeginning(batch.topicPartition, this.producerIdAndEpoch);\n                } else {\n                    requestIdempotentEpochBumpForPartition(batch.topicPartition);\n                }\n                return true;\n            }\n\n            if (!isTransactional()) {\n                // For the idempotent producer, always retry UNKNOWN_PRODUCER_ID errors. If the batch has the current\n                // producer ID and epoch, request a bump of the epoch. Otherwise just retry the produce.\n                requestIdempotentEpochBumpForPartition(batch.topicPartition);\n                return true;\n            }\n        } else if (error == Errors.OUT_OF_ORDER_SEQUENCE_NUMBER) {\n            if (!hasUnresolvedSequence(batch.topicPartition) &&\n                    (batch.sequenceHasBeenReset() || !isNextSequence(batch.topicPartition, batch.baseSequence()))) {\n                // We should retry the OutOfOrderSequenceException if the batch is _not_ the next batch, ie. its base\n                // sequence isn't the lastAckedSequence + 1.\n                return true;\n            } else if (!isTransactional()) {\n                // For the idempotent producer, retry all OUT_OF_ORDER_SEQUENCE_NUMBER errors. If there are no\n                // unresolved sequences, or this batch is the one immediately following an unresolved sequence, we know\n                // there is actually a gap in the sequences, and we bump the epoch. Otherwise, retry without bumping\n                // and wait to see if the sequence resolves\n                if (!hasUnresolvedSequence(batch.topicPartition) ||\n                        isNextSequenceForUnresolvedPartition(batch.topicPartition, batch.baseSequence())) {\n                    requestIdempotentEpochBumpForPartition(batch.topicPartition);\n                }\n                return true;\n            }\n        }\n\n        // If neither of the above cases are true, retry if the exception is retriable\n        return error.exception() instanceof RetriableException;\n    }\n\n    // visible for testing\n    synchronized boolean isReady() {\n        return isTransactional() && currentState == State.READY;\n    }\n\n    // visible for testing\n    synchronized boolean isInitializing() {\n        return isTransactional() && currentState == State.INITIALIZING;\n    }\n\n    /**\n     * Check if the transaction is in the prepared state.\n     *\n     * @return true if the current state is PREPARED_TRANSACTION\n     */\n    public synchronized boolean isPrepared() {\n        return currentState == State.PREPARED_TRANSACTION;\n    }\n\n    void handleCoordinatorReady() {\n        NodeApiVersions nodeApiVersions = transactionCoordinator != null ?\n                apiVersions.get(transactionCoordinator.idString()) :\n                null;\n        ApiVersion initProducerIdVersion = nodeApiVersions != null ?\n                nodeApiVersions.apiVersion(ApiKeys.INIT_PRODUCER_ID) :\n                null;\n        this.coordinatorSupportsBumpingEpoch = initProducerIdVersion != null &&\n                initProducerIdVersion.maxVersion() >= 3;\n    }\n\n    private void transitionTo(State target) {\n        transitionTo(target, null);\n    }\n\n    private void transitionTo(State target, RuntimeException error) {\n        if (!currentState.isTransitionValid(currentState, target)) {\n            String idString = transactionalId == null ?  \"\" : \"TransactionalId \" + transactionalId + \": \";\n            String message = idString + \"Invalid transition attempted from state \"\n                    + currentState.name() + \" to state \" + target.name();\n\n            if (shouldPoisonStateOnInvalidTransition()) {\n                currentState = State.FATAL_ERROR;\n                lastError = new IllegalStateException(message);\n                throw lastError;\n            } else {\n                throw new IllegalStateException(message);\n            }\n        } else if (target == State.FATAL_ERROR || target == State.ABORTABLE_ERROR) {\n            if (error == null)\n                throw new IllegalArgumentException(\"Cannot transition to \" + target + \" with a null exception\");\n            lastError = error;\n        } else {\n            lastError = null;\n        }\n\n        if (lastError != null)\n            log.debug(\"Transition from state {} to error state {}\", currentState, target, lastError);\n        else\n            log.debug(\"Transition from state {} to {}\", currentState, target);\n\n        currentState = target;\n    }\n\n    private void ensureTransactional() {\n        if (!isTransactional())\n            throw new IllegalStateException(\"Transactional method invoked on a non-transactional producer.\");\n    }\n\n    private void maybeFailWithError() {\n        if (!hasError()) {\n            return;\n        }\n        // for ProducerFencedException, do not wrap it as a KafkaException\n        // but create a new instance without the call trace since it was not thrown because of the current call\n        if (lastError instanceof ProducerFencedException) {\n            throw new ProducerFencedException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" has been fenced by another producer \" +\n                    \"with the same transactionalId\");\n        }\n        if (lastError instanceof InvalidProducerEpochException) {\n            throw new InvalidProducerEpochException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" attempted to produce with an old epoch\");\n        }\n        if (lastError instanceof IllegalStateException) {\n            throw new IllegalStateException(\"Producer with transactionalId '\" + transactionalId\n                    + \"' and \" + producerIdAndEpoch + \" cannot execute transactional method because of previous invalid state transition attempt\", lastError);\n        }",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java#L1041-L1190",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/internals/TransactionManager.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 1041,
  "end_line": 1190,
  "last_modified": "2026-02-06T01:16:27.610496",
  "source_type": "github"
}