{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_producer_ProducerConfig.java_131",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "content": "                                           + \" server at all. The record will be immediately added to the socket buffer and considered sent. No guarantee can be\"\n                                           + \" made that the server has received the record in this case, and the <code>retries</code> configuration will not\"\n                                           + \" take effect (as the client won't generally know of any failures). The offset given back for each record will\"\n                                           + \" always be set to <code>-1</code>.\"\n                                           + \" <li><code>acks=1</code> This will mean the leader will write the record to its local log but will respond\"\n                                           + \" without awaiting full acknowledgement from all followers. In this case should the leader fail immediately after\"\n                                           + \" acknowledging the record but before the followers have replicated it then the record will be lost.\"\n                                           + \" <li><code>acks=all</code> This means the leader will wait for the full set of in-sync replicas to\"\n                                           + \" acknowledge the record. This guarantees that the record will not be lost as long as at least one in-sync replica\"\n                                           + \" remains alive. This is the strongest available guarantee. This is equivalent to the acks=-1 setting.\"\n                                           + \"</ul>\"\n                                           + \"<p>\"\n                                           + \"Note that enabling idempotence requires this config value to be 'all'.\"\n                                           + \" If conflicting configurations are set and idempotence is not explicitly enabled, idempotence is disabled.\";\n\n    /** <code>linger.ms</code> */\n    public static final String LINGER_MS_CONFIG = \"linger.ms\";\n    private static final String LINGER_MS_DOC = \"The producer groups together any records that arrive in between request transmissions into a single batched request. \"\n                                                + \"Normally this occurs only under load when records arrive faster than they can be sent out. However in some circumstances the client may want to \"\n                                                + \"reduce the number of requests even under moderate load. This setting accomplishes this by adding a small amount \"\n                                                + \"of artificial delay&mdash;that is, rather than immediately sending out a record, the producer will wait for up to \"\n                                                + \"the given delay to allow other records to be sent so that the sends can be batched together. This can be thought \"\n                                                + \"of as analogous to Nagle's algorithm in TCP. This setting gives the upper bound on the delay for batching: once \"\n                                                + \"we get <code>\" + BATCH_SIZE_CONFIG + \"</code> worth of records for a partition it will be sent immediately regardless of this \"\n                                                + \"setting, however if we have fewer than this many bytes accumulated for this partition we will 'linger' for the \"\n                                                + \"specified time waiting for more records to show up. This setting defaults to 5 (i.e. 5ms delay). Increasing <code>\" + LINGER_MS_CONFIG + \"=50</code>, \"\n                                                + \"for example, would have the effect of reducing the number of requests sent but would add up to 50ms of latency to records sent in the absence of load.\"\n                                                + \"The default changed from 0 to 5 in Apache Kafka 4.0 as the efficiency gains from larger batches typically result in \"\n                                                + \"similar or lower producer latency despite the increased linger.\";\n\n    /** <code>request.timeout.ms</code> */\n    public static final String REQUEST_TIMEOUT_MS_CONFIG = CommonClientConfigs.REQUEST_TIMEOUT_MS_CONFIG;\n    private static final String REQUEST_TIMEOUT_MS_DOC = CommonClientConfigs.REQUEST_TIMEOUT_MS_DOC\n        + \" This should be larger than <code>replica.lag.time.max.ms</code> (a broker configuration)\"\n        + \" to reduce the possibility of message duplication due to unnecessary producer retries.\";\n\n    /** <code>delivery.timeout.ms</code> */\n    public static final String DELIVERY_TIMEOUT_MS_CONFIG = \"delivery.timeout.ms\";\n    private static final String DELIVERY_TIMEOUT_MS_DOC = \"An upper bound on the time to report success or failure \"\n            + \"after a call to <code>send()</code> returns. This limits the total time that a record will be delayed \"\n            + \"prior to sending, the time to await acknowledgement from the broker (if expected), and the time allowed \"\n            + \"for retriable send failures. The producer may report failure to send a record earlier than this config if \"\n            + \"either an unrecoverable error is encountered, the retries have been exhausted, \"\n            + \"or the record is added to a batch which reached an earlier delivery expiration deadline. \"\n            + \"The value of this config should be greater than or equal to the sum of <code>\" + REQUEST_TIMEOUT_MS_CONFIG + \"</code> \"\n            + \"and <code>\" + LINGER_MS_CONFIG + \"</code>.\";\n\n    /** <code>client.id</code> */\n    public static final String CLIENT_ID_CONFIG = CommonClientConfigs.CLIENT_ID_CONFIG;\n\n    /** <code>send.buffer.bytes</code> */\n    public static final String SEND_BUFFER_CONFIG = CommonClientConfigs.SEND_BUFFER_CONFIG;\n\n    /** <code>receive.buffer.bytes</code> */\n    public static final String RECEIVE_BUFFER_CONFIG = CommonClientConfigs.RECEIVE_BUFFER_CONFIG;\n\n    /** <code>max.request.size</code> */\n    public static final String MAX_REQUEST_SIZE_CONFIG = \"max.request.size\";\n    private static final String MAX_REQUEST_SIZE_DOC =\n        \"The maximum size of a request in bytes. This setting will limit the number of record \" +\n        \"batches the producer will send in a single request to avoid sending huge requests. \" +\n        \"This is also effectively a cap on the maximum uncompressed record batch size. Note that the server \" +\n        \"has its own cap on the record batch size (after compression if compression is enabled) which may be different from this.\";\n\n    /** <code>reconnect.backoff.ms</code> */\n    public static final String RECONNECT_BACKOFF_MS_CONFIG = CommonClientConfigs.RECONNECT_BACKOFF_MS_CONFIG;\n\n    /** <code>reconnect.backoff.max.ms</code> */\n    public static final String RECONNECT_BACKOFF_MAX_MS_CONFIG = CommonClientConfigs.RECONNECT_BACKOFF_MAX_MS_CONFIG;\n\n    /** <code>max.block.ms</code> */\n    public static final String MAX_BLOCK_MS_CONFIG = \"max.block.ms\";\n    private static final String MAX_BLOCK_MS_DOC = \"The configuration controls how long the <code>KafkaProducer</code>'s <code>send()</code>, <code>partitionsFor()</code>, \"\n                                                    + \"<code>initTransactions()</code>, <code>sendOffsetsToTransaction()</code>, <code>commitTransaction()</code> \"\n                                                    + \"and <code>abortTransaction()</code> methods will block. \"\n                                                    + \"For <code>send()</code> this timeout bounds the total time waiting for both metadata fetch and buffer allocation \"\n                                                    + \"(blocking in the user-supplied serializers or partitioner is not counted against this timeout). \"\n                                                    + \"For <code>partitionsFor()</code> this timeout bounds the time spent waiting for metadata if it is unavailable. \"\n                                                    + \"The transaction-related methods always block, but may timeout if \"\n                                                    + \"the transaction coordinator could not be discovered or did not respond within the timeout.\";\n\n    /** <code>buffer.memory</code> */\n    public static final String BUFFER_MEMORY_CONFIG = \"buffer.memory\";\n    private static final String BUFFER_MEMORY_DOC = \"The total bytes of memory the producer can use to buffer records waiting to be sent to the server. If records are \"\n                                                    + \"sent faster than they can be delivered to the server the producer will block for <code>\" + MAX_BLOCK_MS_CONFIG + \"</code> after which it will fail with an exception.\"\n                                                    + \"<p>\"\n                                                    + \"This setting should correspond roughly to the total memory the producer will use, but is not a hard bound since \"\n                                                    + \"not all memory the producer uses is used for buffering. Some additional memory will be used for compression (if \"\n                                                    + \"compression is enabled) as well as for maintaining in-flight requests.\";\n\n    /** <code>retry.backoff.ms</code> */\n    public static final String RETRY_BACKOFF_MS_CONFIG = CommonClientConfigs.RETRY_BACKOFF_MS_CONFIG;\n\n    /** <code>retry.backoff.max.ms</code> */\n    public static final String RETRY_BACKOFF_MAX_MS_CONFIG = CommonClientConfigs.RETRY_BACKOFF_MAX_MS_CONFIG;\n\n    /**\n     * <code>enable.metrics.push</code>\n     */\n    public static final String ENABLE_METRICS_PUSH_CONFIG = CommonClientConfigs.ENABLE_METRICS_PUSH_CONFIG;\n    public static final String ENABLE_METRICS_PUSH_DOC = CommonClientConfigs.ENABLE_METRICS_PUSH_DOC;\n\n    /** <code>compression.type</code> */\n    public static final String COMPRESSION_TYPE_CONFIG = \"compression.type\";\n    private static final String COMPRESSION_TYPE_DOC = \"The compression type for all data generated by the producer. The default is none (i.e. no compression). Valid \"\n                                                       + \" values are <code>none</code>, <code>gzip</code>, <code>snappy</code>, <code>lz4</code>, or <code>zstd</code>. \"\n                                                       + \"Compression is of full batches of data, so the efficacy of batching will also impact the compression ratio (more batching means better compression).\";\n\n    /** <code>compression.gzip.level</code> */\n    public static final String COMPRESSION_GZIP_LEVEL_CONFIG = \"compression.gzip.level\";\n    private static final String COMPRESSION_GZIP_LEVEL_DOC = \"The compression level to use if \" + COMPRESSION_TYPE_CONFIG + \" is set to <code>gzip</code>.\";\n\n    /** <code>compression.lz4.level</code> */\n    public static final String COMPRESSION_LZ4_LEVEL_CONFIG = \"compression.lz4.level\";\n    private static final String COMPRESSION_LZ4_LEVEL_DOC = \"The compression level to use if \" + COMPRESSION_TYPE_CONFIG + \" is set to <code>lz4</code>.\";\n\n    /** <code>compression.zstd.level</code> */\n    public static final String COMPRESSION_ZSTD_LEVEL_CONFIG = \"compression.zstd.level\";\n    private static final String COMPRESSION_ZSTD_LEVEL_DOC = \"The compression level to use if \" + COMPRESSION_TYPE_CONFIG + \" is set to <code>zstd</code>.\";\n\n    /** <code>metrics.sample.window.ms</code> */\n    public static final String METRICS_SAMPLE_WINDOW_MS_CONFIG = CommonClientConfigs.METRICS_SAMPLE_WINDOW_MS_CONFIG;\n\n    /** <code>metrics.num.samples</code> */\n    public static final String METRICS_NUM_SAMPLES_CONFIG = CommonClientConfigs.METRICS_NUM_SAMPLES_CONFIG;\n\n    /**\n     * <code>metrics.recording.level</code>\n     */\n    public static final String METRICS_RECORDING_LEVEL_CONFIG = CommonClientConfigs.METRICS_RECORDING_LEVEL_CONFIG;\n\n    /** <code>metric.reporters</code> */\n    public static final String METRIC_REPORTER_CLASSES_CONFIG = CommonClientConfigs.METRIC_REPORTER_CLASSES_CONFIG;\n\n    // max.in.flight.requests.per.connection should be less than or equal to 5 when idempotence producer enabled to ensure message ordering\n    // The value 5 is aligned with ProducerStateEntry#NUM_BATCHES_TO_RETAIN.\n    private static final int MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_FOR_IDEMPOTENCE = 5;\n\n    /** <code>max.in.flight.requests.per.connection</code> */\n    public static final String MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION = \"max.in.flight.requests.per.connection\";\n    private static final String MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_DOC = \"The maximum number of unacknowledged requests the client will send on a single connection before blocking.\"\n                                                                            + \" Note that if this configuration is set to be greater than 1 and <code>enable.idempotence</code> is set to false, there is a risk of\"\n                                                                            + \" message reordering after a failed send due to retries (i.e., if retries are enabled); \"\n                                                                            + \" if retries are disabled or if <code>enable.idempotence</code> is set to true, ordering will be preserved.\"\n                                                                            + \" Additionally, enabling idempotence requires the value of this configuration to be less than or equal to \" + MAX_IN_FLIGHT_REQUESTS_PER_CONNECTION_FOR_IDEMPOTENCE + \",\"\n                                                                            + \" because broker only retains at most 5 batches for each producer. If the value is more than 5, previous batches may be removed on broker side.\";\n\n    /** <code>retries</code> */\n    public static final String RETRIES_CONFIG = CommonClientConfigs.RETRIES_CONFIG;\n    private static final String RETRIES_DOC = \"Number of times to retry a request that fails with a transient error.\"",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java#L131-L280",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/producer/ProducerConfig.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 131,
  "end_line": 280,
  "last_modified": "2026-02-06T01:16:27.608681",
  "source_type": "github"
}