{
  "id": "kafka_clients_src_main_java_org_apache_kafka_clients_admin_KafkaAdminClient.java_5071",
  "title": "kafka/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "content": "        clientInstanceId = ClientTelemetryUtils.fetchClientInstanceId(clientTelemetryReporter.get(), timeout);\n        return clientInstanceId;\n    }\n\n    private <K, V> void invokeDriver(\n        AdminApiHandler<K, V> handler,\n        AdminApiFuture<K, V> future,\n        Integer timeoutMs\n    ) {\n        long currentTimeMs = time.milliseconds();\n        long deadlineMs = calcDeadlineMs(currentTimeMs, timeoutMs);\n\n        AdminApiDriver<K, V> driver = new AdminApiDriver<>(\n            handler,\n            future,\n            deadlineMs,\n            retryBackoffMs,\n            retryBackoffMaxMs,\n            logContext\n        );\n\n        maybeSendRequests(driver, currentTimeMs);\n    }\n\n    private <K, V> void maybeSendRequests(AdminApiDriver<K, V> driver, long currentTimeMs) {\n        for (AdminApiDriver.RequestSpec<K> spec : driver.poll()) {\n            runnable.call(newCall(driver, spec), currentTimeMs);\n        }\n    }\n\n    private <K, V> Call newCall(AdminApiDriver<K, V> driver, AdminApiDriver.RequestSpec<K> spec) {\n        NodeProvider nodeProvider = spec.scope.destinationBrokerId().isPresent() ?\n            new ConstantNodeIdProvider(spec.scope.destinationBrokerId().getAsInt()) :\n            new LeastLoadedNodeProvider();\n        return new Call(spec.name, spec.nextAllowedTryMs, spec.tries, spec.deadlineMs, nodeProvider) {\n            @Override\n            AbstractRequest.Builder<?> createRequest(int timeoutMs) {\n                return spec.request;\n            }\n\n            @Override\n            void handleResponse(AbstractResponse response) {\n                long currentTimeMs = time.milliseconds();\n                driver.onResponse(currentTimeMs, spec, response, this.curNode());\n                maybeSendRequests(driver, currentTimeMs);\n            }\n\n            @Override\n            void handleFailure(Throwable throwable) {\n                long currentTimeMs = time.milliseconds();\n                driver.onFailure(currentTimeMs, spec, throwable);\n                maybeSendRequests(driver, currentTimeMs);\n            }\n\n            @Override\n            void maybeRetry(long currentTimeMs, Throwable throwable) {\n                if (throwable instanceof DisconnectException) {\n                    // Disconnects are a special case. We want to give the driver a chance\n                    // to retry lookup rather than getting stuck on a node which is down.\n                    // For example, if a partition leader shuts down after our metadata query,\n                    // then we might get a disconnect. We want to try to find the new partition\n                    // leader rather than retrying on the same node.\n                    driver.onFailure(currentTimeMs, spec, throwable);\n                    maybeSendRequests(driver, currentTimeMs);\n                } else {\n                    super.maybeRetry(currentTimeMs, throwable);\n                }\n            }\n        };\n    }\n\n    private static long getOffsetFromSpec(OffsetSpec offsetSpec) {\n        if (offsetSpec instanceof TimestampSpec) {\n            return ((TimestampSpec) offsetSpec).timestamp();\n        } else if (offsetSpec instanceof OffsetSpec.EarliestSpec) {\n            return ListOffsetsRequest.EARLIEST_TIMESTAMP;\n        } else if (offsetSpec instanceof OffsetSpec.MaxTimestampSpec) {\n            return ListOffsetsRequest.MAX_TIMESTAMP;\n        } else if (offsetSpec instanceof OffsetSpec.EarliestLocalSpec) {\n            return ListOffsetsRequest.EARLIEST_LOCAL_TIMESTAMP;\n        } else if (offsetSpec instanceof OffsetSpec.LatestTieredSpec) {\n            return ListOffsetsRequest.LATEST_TIERED_TIMESTAMP;\n        } else if (offsetSpec instanceof OffsetSpec.EarliestPendingUploadSpec) {\n            return ListOffsetsRequest.EARLIEST_PENDING_UPLOAD_TIMESTAMP;\n        }\n        return ListOffsetsRequest.LATEST_TIMESTAMP;\n    }\n\n    /**\n     * Get a sub level error when the request is in batch. If given key was not found,\n     * return an {@link IllegalArgumentException}.\n     */\n    static <K> Throwable getSubLevelError(Map<K, Errors> subLevelErrors, K subKey, String keyNotFoundMsg) {\n        if (!subLevelErrors.containsKey(subKey)) {\n            return new IllegalArgumentException(keyNotFoundMsg);\n        } else {\n            return subLevelErrors.get(subKey).exception();\n        }\n    }\n}\n",
  "url": "https://github.com/apache/kafka/blob/trunk/clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java#L5071-L5171",
  "file_path": "clients/src/main/java/org/apache/kafka/clients/admin/KafkaAdminClient.java",
  "repo_name": "kafka",
  "language": "java",
  "start_line": 5071,
  "end_line": 5171,
  "last_modified": "2026-02-06T01:16:27.585045",
  "source_type": "github"
}